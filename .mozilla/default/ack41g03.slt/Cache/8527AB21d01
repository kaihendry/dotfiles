<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Version Control with Subversion</title><link rel="stylesheet" href="styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.62.4"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="svn"></a>Version Control with Subversion</h1></div><div><h2 class="subtitle">Draft Revision exported</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="surname">Collins-Sussman</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Brian W.</span> <span class="surname">Fitzpatrick</span></h3></div><div class="author"><h3 class="author"><span class="firstname">C. Michael</span> <span class="surname">Pilato</span></h3></div></div></div><div><p class="pubdate">(TBA)</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#svn-ch-0">Preface</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-0-sect-1">Audience</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-2">How This Book is Organized</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-3">Conventions Used in This Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-4">This Book is Free</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-5">Acknowledgments</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-1">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-1-sect-1">What is Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-2">Subversion's History</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-3">Subversion's Features</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-4">Installing Subversion</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-5">Subversion's Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-1-sect-5.1">Client Components (for the User)</a></span></dt><dt><span class="sect2"><a href="#svn-ch-1-sect-5.2">Server Components (for the Administrator)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn-ch-2">2. Basic Concepts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch2-sect-1">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-2-sect-2">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-2.1">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.2">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.3">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-3">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-3.1">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.2">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.3">How Working Copies Track the Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.4">The Limitations of Mixed Revisions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-4">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-3">3. Guided Tour</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-3-sect-1">Help!</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-2">Import</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-3">Revisions: Numbers, Keywords, and Dates, Oh My!</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-3.1">Revision Numbers</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.2">Revision Keywords</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.3">Revision Dates</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-4">Initial Checkout</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-5">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-4.1">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.2">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.3">Examine Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.4">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.5">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-6">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-5.1">svn log</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.2">svn diff</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.3">svn cat</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.4">svn list</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.5">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-7">Other Frequently Used Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-7.1">svn cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-7.3">svn import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-8">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-4">4. Branching and Merging</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-4-sect-1">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-2">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-2.1">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.2">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.3">The Moral of the Story</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-3">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch4-sect-3.1">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect-3.2">The Repeated Merge Problem</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect-3.3">Merging an Entire Branch</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-4">Removing a Change from the Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-5">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-6">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-6.1">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-6.2">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-7">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch4-sect7.1">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect7.2">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-8">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-5">5. Repository Administration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-5-sect-1">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-1.1">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.2">Unversioned Properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-2">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-2.1">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-2.2">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-3">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-3.1">An Administrator's Toolkit</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.2">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.3">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.4">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.5">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-4">Networking a Repository</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-4.1">httpd, the Apache HTTP Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-4.2">svnserve, a Custom Subversion Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-4.3">Which Server to Use?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-5">Repository Permissions</a></span></dt><dt><span class="sect1"><a href="#svn-ch-5-sect-6">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-6.1">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-6.2">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-7">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-6">6. Advanced Topics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-6-sect-1">Runtime Configuration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-1.1">Configuration Area Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-1.2">Configuration and the Windows Registry</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-1.3">Configuration Options</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-2">Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-2.1">Why Properties?</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.2">Manipulating Properties</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.3">Special properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-3">Externals Definitions</a></span></dt><dt><span class="sect1"><a href="#svn-ch-6-sect-4">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-4.1">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.2">svn-load-dirs.pl</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn-ch-7">7. Developer Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-7-sect-1">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-1.1">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.2">Repository Access Layer</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.3">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-2">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-2.1">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.2">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.3">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-3">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-3.1">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-3.2">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-4">WebDAV</a></span></dt><dt><span class="sect1"><a href="#svn-ch-7-sect-5">Programming with Memory Pools</a></span></dt><dt><span class="sect1"><a href="#svn-ch-7-sect-6">Contributing to Subversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-6.1">Join the Community</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.2">Get the Source Code</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.3">Become Familiar with Community Policies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.4">Make and Test Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.5">Donate Your Changes</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn-ch-8">8. Subversion Complete Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-8-sect-1">The Subversion Command Line Client:
      svn</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-1.1">svn Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-1.2">svn Subcommands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-2">svnadmin</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-2.1">svnadmin Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-2.2">svnadmin Subcommands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-3">svnlook</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-3.1">svnlook Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-3.2">svnlook Subcommands</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-a">A. Subversion for CVS Users</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-app-a-sect-1">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-2">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-3">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-4">Distinction Between Status and Update</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-5">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-6">Meta-data Properties</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-7">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-8">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-9">Versioned Modules</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn-ap-b">B. CVS Repository Migration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-b-sect-1">Requirements</a></span></dt><dt><span class="sect1"><a href="#svn-ap-b-sect-2">Running cvs2svn.py</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn-ap-c">C. Troubleshooting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-c-sect-1">Common Problems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-c-sect-1.2">Problems Using Subversion</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-1.3">Problems Building Subversion</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-d">D. WebDAV and Autoversioning</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-app-d-sect-1">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect1.1">Just Plain WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect1.2">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-app-d-sect-2">Subversion and DeltaV</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect2.1">Mapping Subversion to DeltaV</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect2.2">Autoversioning Support</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect2.3">The mod_dav_lock Alternative</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-app-d-sect-3">Autoversioning Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect-3.1">Win32 WebFolders</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.2">Mac OS X</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.3">Unix: Nautilus 2</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.4">Linux davfs2</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-e">E. Other Subversion Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-e-sect-1">Out of One, Many</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn-ap-f">F. Third Party Tools</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-f-sect-1">ViewCVS</a></span></dt><dt><span class="sect1"><a href="#svn-ap-f-sect-2">SubWiki</a></span></dt></dl></dd><dt><span class="glossary"><a href="#svn-glossary">Glossary</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>2.1. <a href="#svn-ch2-dia1">A Typical Client/Server System</a></dt><dt>2.2. <a href="#svn-ch2-dia2">The Problem to Avoid</a></dt><dt>2.3. <a href="#svn-ch2-dia3">The Lock-Modify-Unlock Solution</a></dt><dt>2.4. <a href="#svn-ch2-dia4">The Copy-Modify-Merge Solution</a></dt><dt>2.5. <a href="#svn-ch2-dia5">&#8230;Copy-Modify-Merge Continued</a></dt><dt>2.6. <a href="#svn-ch2-dia6">The Repository's Filesystem</a></dt><dt>2.7. <a href="#svn-ch2-dia7">The Repository</a></dt><dt>4.1. <a href="#svn-ch4-dia1">Branches of Development</a></dt><dt>4.2. <a href="#svn-ch4-dia2">Starting Repository Layout</a></dt><dt>4.3. <a href="#svn-ch4-dia3">Repository With New Copy</a></dt><dt>4.4. <a href="#svn-ch4-dia4">The Branching of One File's History</a></dt><dt>5.1. <a href="#svn-ch5-sect5.1-dia1">One Suggested Repository Layout.</a></dt><dt>5.2. <a href="#svn-ch5-sect5.1-dia2">Another Suggested Repository Layout.</a></dt><dt>7.1. <a href="#svn-ch7-sect1-dia1">Subversion's "Big Picture"</a></dt><dt>7.2. <a href="#svn-ch7-sect1.1-dia1">Files and Directories in Two Dimensions</a></dt><dt>7.3. <a href="#svn-ch7-sect1.1-dia2">Revisioning Time&#8212;the Third Dimension!</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#svn-ch-02-table-1">Repository Access URLs</a></dt><dt>7.1. <a href="#svn-ch-7-table-1">A Brief Inventory of the Subversion Libraries</a></dt><dt>E.1. <a href="#svn-ap-e-table-1">GUI Clients for Subversion</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>5.1. <a href="#svn-ch-7-sect-3.1.3-ex-1">Using svnshell to Navigate the Repository</a></dt><dt>5.2. <a href="#svn-ch-5-sect-3.2-ex-1">txn-info.sh (Reporting Outstanding Transactions)</a></dt><dt>5.3. <a href="#svn-ch-5-sect-3.4-ex-1">Using Incremental Repository Dumps</a></dt><dt>6.1. <a href="#svn-ch-6-sect-1.2-ex-1">Sample Registration Entries (.REG) File.</a></dt><dt>7.1. <a href="#svn-ch-7-sect-1.1-ex-1">Using the Repository Layer</a></dt><dt>7.2. <a href="#svn-ch-7-sect-2.3-ex-1">Using the Repository Layer with Python</a></dt><dt>7.3. <a href="#svn-ch-7-sect-2.3-ex-2">A Simple Script to Check Out a Working Copy.</a></dt><dt>7.4. <a href="#svn-ch-7-sect-3-ex-1">Contents of a Typical .svn/entries
          File</a></dt><dt>7.5. <a href="#svn-ch-7-sect-5-ex-1">Effective Pool Usage</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-0"></a>Preface</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-0-sect-1">Audience</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-2">How This Book is Organized</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-3">Conventions Used in This Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-4">This Book is Free</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-5">Acknowledgments</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><div class="blockquote"><blockquote class="blockquote"><p>&#8220;<span class="quote">If C gives you enough rope to hang yourself, think
        of Subversion as a sort of rope storage facility.</span>&#8221;
        &#8212;Brian Fitzpatrick</p></blockquote></div><p>
      In the world of open-source software, the Concurrent Versions
      System (CVS) has long been the tool of choice for version
      control.  And rightly so.  CVS itself is free software, and its
      wonderful &#8220;<span class="quote">non-locking</span>&#8221; system&#8212;which allows
      dozens of far-flung programmers to share their work&#8212;fits
      the collaborative nature of the open-source world very well.  CVS
      and its semi-chaotic development model have become cornerstones
      of open-source culture.
    </p><p>
      But like many tools, CVS is starting to show its age.
      Subversion is a relatively new version control system designed
      to be the successor to CVS.  The designers set out to win the
      hearts of CVS users in two ways: by creating an open-source
      system with a design (and "look and feel") similar to CVS, and
      by attempting to fix most of CVS's noticeable flaws.  While the
      result isn't necessarily the next great evolution in version
      control design, Subversion <span class="emphasis"><em>is</em></span> very
      powerful, very usable, and very flexible.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-1"></a>Audience</h2></div></div><div></div></div><p>This book is written for computer literate folk who want to
      use Subversion to manage their data.  While Subversion runs on a
      number of different operating systems, its primary user
      interface is command-line based.  For that reason, the examples
      in this book assume the reader is using a Unix-like operating
      system, and is relatively comfortable with Unix and command-line
      interfaces.</p><p>Most readers are probably programmers or sysadmins who need
      to track changes to source code; this is the most common use for
      Subversion, and therefore it is the scenario underlying all of
      the book's examples.  But keep in mind that Subversion can be
      used to manage changes to any sort of information: images,
      music, databases, documentation, and so on.  To Subversion, all
      data is just data.</p><p>While this book is written with the assumption that the
      reader has never used version control, we've also tried to make
      it easy for former CVS users to get up to speed quickly.
      Special sidebars may discuss CVS from time to time, and a
      special appendix summarizes most of the differences between CVS
      and Subversion.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-2"></a>How This Book is Organized</h2></div></div><div></div></div><p>The first three chapters of this book form a general
      introduction to Subversion.  We begin with a discussion of
      Subversion's features, discuss its design and user model, and
      then lead into a guided tour.  All readers, regardless of
      experience, should read these chapters.  They form the backbone
      of the rest of the book.</p><p>Chapters four, five, and six discuss the more complex topics
      of branching, repository administration, and advanced features
      such as properties, externals, and access control.  Sysadmins
      and power-users will definitely want to read these
      chapters.</p><p>Chapter seven is specially written for programmers who want
      to use Subversion's APIs in their own software, or want to work
      on Subversion itself.</p><p>The book ends with reference material: chapter eight is a
      reference guide for all Subversion commands, and the appendices
      cover a number of useful topics.  These are the chapters you're
      mostly likely to come back to after you've finished the
      book.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-3"></a>Conventions Used in This Book</h2></div></div><div></div></div><p>### O'Reilly almost certainly needs to fill this in,
      depending on how they typeset the book.</p><p>Note that the source code examples are just
      that&#8212;examples. While they will compile with the proper
      compiler incantations, they are intended to illustrate the
      problem at hand, not necessarily serve as examples of good
      programming style.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-4"></a>This Book is Free</h2></div></div><div></div></div><p>This book started out as bits of documentation written by
      Subversion project developers, which were then coalesced into a
      single work and rewritten.  As such, it has always had the same
      free, open-source license as Subversion itself.  In fact, the
      book was written in the public eye, as a part of Subversion.
      This means two things:</p><div class="itemizedlist"><ul type="disc"><li><p>You will always find the latest version of this book in
          Subversion's own source tree.</p></li><li><p>You can distribute and make changes to this book however
          you wish &#8212; it's under a free license.  Of course,
          rather than distribute your own private version of this
          book, we'd much rather you send feedback and patches to the
          Subversion developer community.  See <a href="#svn-ch-7-sect-6" title="Contributing to Subversion">the section called &#8220;Contributing to Subversion&#8221;</a> to learn about joining this
          community.</p></li></ul></div><p>You can send publishing comments and questions to O'Reilly
      here: ###insert boilerplate.</p><p>A relatively recent online version of this book can be found
      at <tt class="systemitem">http://svnbook.red-bean.com</tt>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-5"></a>Acknowledgments</h2></div></div><div></div></div><p>### Huge list of thanks to the many svn developers who sent
      patches/feedback on this book. </p><p>### Also, individual-author acknowledgments to specific
      friends and family.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-1"></a>Chapter 1. Introduction</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-1-sect-1">What is Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-2">Subversion's History</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-3">Subversion's Features</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-4">Installing Subversion</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-5">Subversion's Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-1-sect-5.1">Client Components (for the User)</a></span></dt><dt><span class="sect2"><a href="#svn-ch-1-sect-5.2">Server Components (for the Administrator)</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Version control is the art of managing changes to
      information.  It has long been a critical tool for programmers,
      who typically spend their time making small changes to software
      and then undoing those changes the next day.  Imagine a team of
      these programmers working concurrently, and you can see why a
      good system is needed to manage the potential chaos.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-1"></a>What is Subversion?</h2></div></div><div></div></div><p>Subversion is a free/open-source version control system.
      That is, Subversion manages files and directories over time.
      A tree of files is placed into a central
      <i class="firstterm">repository</i>.  The repository is much like
      an ordinary file server, except that it remembers every change
      ever made to your files and directories.  This allows you to
      recover older versions of your data, or examine the history of
      how your data changed.  In this regard, many people think of a
      version control system as a sort of &#8220;<span class="quote">time
      machine</span>&#8221;.</p><p>Some version control systems are also software configuration
      management (SCM) systems.  These systems are specifically
      tailored to manage trees of source code, and have many features
      that are specific to software development&#8212;such as natively
      understanding programming languages, or supplying tools for
      building software.  Subversion, however, is not one of these
      systems; it is a general system that can be used to manage
      <span class="emphasis"><em>any</em></span> collection of files, including
      source code.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-2"></a>Subversion's History</h2></div></div><div></div></div><p>In 1995, Karl Fogel and Jim Blandy founded Cyclic Software,
      a company for commercially supporting and improving the
      Concurrent Versions System (CVS).  Cyclic made the first public
      release of a network-enabled CVS (contributed by Cygnus
      software).  In 1999, Karl Fogel published a book about CVS and
      the open-source development model it enables.  Karl and Jim had
      long talked about writing a replacement for CVS; Jim had even
      drafted a new, theoretical repository design, and had come up
      with a good project name.  Finally, in February of 2000, Brian
      Behlendorf of CollabNet (<tt class="systemitem">http://www.collab.net</tt>) offered Karl a
      full-time job to write a CVS replacement.  Karl gathered a team
      together and work began in May.  Because Subversion was
      developed openly under a free license, it quickly attracted a
      community of developers.</p><p>The original design team settled on some simple goals.  They
      decided that Subversion should be a functional replacement
      for CVS: it should match CVS's features, preserve the same
      development model, but still fix the most obvious flaws.  And
      Subversion should be similar enough to CVS that any CVS
      user could start using it with little effort.</p><p>After fourteen months of coding, Subversion became
      &#8220;<span class="quote">self-hosting</span>&#8221; on August 31, 2001.  That is,
      Subversion developers stopped using CVS to manage Subversion's
      own source code and started using Subversion instead.</p><p>While CollabNet is credited with initiating and funding a
      very large chunk of the work (it pays the salaries of a few
      full-time Subversion developers), the project is still a typical
      open-source project, governed by the usual meritocratic rules.
      CollabNet owns the copyright on the code, but the code is
      available under an Apache/BSD-style license which is fully
      compliant with the Debian Free Software Guidelines. In other
      words, anyone is free to download, modify, and redistribute
      Subversion as he pleases; no permission from CollabNet or
      anyone else is required.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-3"></a>Subversion's Features</h2></div></div><div></div></div><p>How does Subversion improve upon CVS's design?  Here's a
      short list to whet your appetite.  If you're not familiar with
      CVS, you may not understand all of these features.  Fear not:
      Chapter 2 will provide you with a gentle introduction to version
      control.</p><div class="variablelist"><dl><dt><span class="term">Directory versioning</span></dt><dd><p>CVS only tracks the history of individual files,
            but Subversion implements a
            &#8220;<span class="quote">virtual</span>&#8221; versioned filesystem that tracks
            changes to whole directory trees over time.  Files
            <span class="emphasis"><em>and</em></span> directories are versioned.  As a
            result, there are real client-side <span><b class="command">move</b></span>
            and <span><b class="command">copy</b></span> commands that operate on files
            and directories.</p></dd><dt><span class="term">Atomic commits</span></dt><dd><p>A commit either goes into the repository completely,
            or not at all.  This allows developers to construct and
            commit changes as logical chunks.</p></dd><dt><span class="term">Versioned metadata</span></dt><dd><p>Each file and directory has an invisible set of
            &#8220;<span class="quote">properties</span>&#8221; attached.  You can invent and
            store any arbitrary key/value pairs you wish.  Properties
            are versioned over time, just like file contents.</p></dd><dt><span class="term">Choice of network layers</span></dt><dd><p>Subversion has an abstracted notion of repository
            access, making it easy for people to implement new network
            mechanisms.  Subversion's &#8220;<span class="quote">advanced</span>&#8221; network
            server is a module for the Apache web server, which speaks
            a variant of HTTP called WebDAV/DeltaV.  This gives
            Subversion a big advantage in stability and
            interoperability, and provides various key features for
            free: authentication, authorization, wire compression, and
            repository browsing, for example.  A smaller, standalone
            Subversion server process is also available.  This server speaks
            a custom protocol which can be easily tunneled over ssh.
          </p></dd><dt><span class="term">Consistent data handling</span></dt><dd><p>Subversion expresses file differences using a binary
            differencing algorithm, which works identically on both
            text (human-readable) and binary (human-unreadable) files.
            Both types of files are stored equally compressed in the
            repository, and differences are transmitted in both
            directions across the network.</p></dd><dt><span class="term">Efficient branching and tagging</span></dt><dd><p>
            The cost of branching and tagging need not be proportional to the
            project size.  Subversion creates branches and tags by
            simply copying the project, using a mechanism similar to a
            hard-link.  Thus these operations take only a very small,
            constant amount of time.
          </p></dd><dt><span class="term">Hackability</span></dt><dd><p>Subversion has no historical baggage; it is
            implemented as a collection of shared C libraries with
            well-defined APIs.  This makes Subversion extremely
            maintainable and usable by other applications and
            languages.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-4"></a>Installing Subversion</h2></div></div><div></div></div><p>Subversion is built on a portability layer called APR (the
      Apache Portable Runtime library).  This means Subversion should
      work on any operating system that the Apache httpd server runs
      on: Windows, Linux, all flavors of BSD, Mac OS X, Netware, and
      others. </p><p>The easiest way to get Subversion is to download a binary
      package built for your operating system.  Subversion's
      website (<tt class="systemitem">http://subversion.tigris.org</tt>) often has
      binaries available for download, posted by volunteers.  The site
      usually contains graphical installer packages for users of
      Microsoft operating systems.  If you run a Unix-like operating
      system, you can use your system's native package-distribution
      system (rpm, deb, ports tree) to get Subversion.</p><p>Alternately, you can build Subversion directly from source
      code.  From the website, you can download the latest source-code
      release.  After unpacking it, follow the instructions in the INSTALL
      file to build it.  Note that a released source package contains
      everything you need to build a command-line client capable of
      talking to a remote repository (in particular, the apr,
      apr-util, and neon libraries).  But Subversion has many other
      dependencies, such as Berkeley DB and possibly Apache httpd.
      If you want to do a &#8220;<span class="quote">full</span>&#8221; build, make sure you
      have all of the packages documented in the INSTALL file.  If you
      plan to work on Subversion itself, you can use your client
      program to grab the latest, bleeding-edge source code.  This is
      documented in <a href="#svn-ch-7-sect-6.2" title="Get the Source Code">the section called &#8220;Get the Source Code&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-5"></a>Subversion's Components</h2></div></div><div></div></div><p>
      Subversion, once installed, has a number of different pieces.
      Here's a quick overview of what you get.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-1-sect-5.1"></a>Client Components (for the User)</h3></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">svn</span></dt><dd><p>The command-line client program.  This is the main
             tool used to manage data, and its use is covered in
             Chapters 2, 3, 4, and 6.</p></dd><dt><span class="term">svnversion</span></dt><dd><p>A program for reporting the mixed-revision state of a
            working copy.  (See <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a> to understand
            mixed-revision working copies.)</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-1-sect-5.2"></a>Server Components (for the Administrator)</h3></div></div><div></div></div><p>These are all discussed in <a href="#svn-ch-5" title="Chapter 5. Repository Administration">Chapter 5, <i>Repository Administration</i></a>.</p><div class="variablelist"><dl><dt><span class="term">svnlook</span></dt><dd><p>A tool for inspecting a Subversion repository.</p></dd><dt><span class="term">svnadmin</span></dt><dd><p>A tool for creating, tweaking or repairing a Subversion
              repository.</p></dd><dt><span class="term">mod_dav_svn</span></dt><dd><p>A plug-in module for the Apache-2.X web server; used
            to make your repository available to others over a
            network.</p></dd><dt><span class="term">svnserve</span></dt><dd><p>A standalone server program, runnable as a daemon
              process or invokable by SSH; another way to make your
              repository available to others over a network.</p></dd></dl></div></div><p>Assuming you have Subversion installed correctly, you should
      be ready to start.  The next two chapters will walk you through
      the use of <span><b class="command">svn</b></span>, Subversion's command-line client 
      program.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-2"></a>Chapter 2. Basic Concepts</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch2-sect-1">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-2-sect-2">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-2.1">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.2">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.3">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-3">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-3.1">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.2">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.3">How Working Copies Track the Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.4">The Limitations of Mixed Revisions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-4">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</p><p>Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection&#8212;it's not limited to
      helping computer programmers.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch2-sect-1"></a>The Repository</h2></div></div><div></div></div><p>Subversion is a centralized system for sharing information.
      At its core is a <i class="firstterm">repository</i>, which is a
      central store of data.  The repository stores information in the
      form of a <i class="firstterm">filesystem tree</i>&#8212;a typical
      hierarchy of files and directories.  Any number of
      <i class="firstterm">clients</i> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.</p><div class="figure"><a name="svn-ch2-dia1"></a><p class="title"><b>Figure 2.1. A Typical Client/Server System</b></p><div><img src="images/ch02dia1.png" alt="A Typical Client/Server System"></div></div><p>So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <span class="emphasis"><em>is</em></span> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <span class="emphasis"><em>it remembers every change</em></span> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</p><p>When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <span class="emphasis"><em>previous</em></span> states of the filesystem.  For
      example, a client can ask historical questions like, "what did
      this directory contain last Wednesday?", or "who was the last
      person to change this file, and what changes did they make?"
      These are the sorts of questions that are at the heart of any
      <i class="firstterm">version control system</i>: systems that are
      designed to record and track changes to data over time.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-2"></a>Versioning Models</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.1"></a>The Problem of File-Sharing</h3></div></div><div></div></div><p>All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</p><p>Consider this scenario: suppose we have two co-workers,
        Harry and Sally.  They each decide to edit the same repository
        file at the same time.  If Harry saves his changes to the
        repository first, then it's possible that (a few moments
        later) Sally could accidentally overwrite them with her own
        new version of the file.  While Harry's version of the file
        won't be lost forever (because the system remembers every
        change), any changes Harry made <span class="emphasis"><em>won't</em></span> be
        present in Sally's newer version of the file, because she
        never saw Harry's changes to begin with.  Harry's work is
        still effectively lost&#8212;or at least missing from the
        latest version of the file&#8212;and probably by accident.
        This is definitely a situation we want to avoid!</p><div class="figure"><a name="svn-ch2-dia2"></a><p class="title"><b>Figure 2.2. The Problem to Avoid</b></p><div><img src="images/ch02dia2.png" alt="The Problem to Avoid"></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.2"></a>The Lock-Modify-Unlock Solution</h3></div></div><div></div></div><p>Many version control systems use a
        <i class="firstterm">lock-modify-unlock</i> model to address
        this problem, which is a very simple solution.  In such a
        system, the repository allows only one person to change a file
        at a time.  First Harry must "lock" the file before he can begin
        making changes to it.  Locking a file is a lot like borrowing
        a book from the library; if Harry has locked a file, then Sally
        cannot make any changes to it.  If she tries to lock the file,
        the repository will deny the request.  All she can do is read
        the file, and wait for Harry to finish his changes and release
        his lock.  After Harry unlocks the file, his turn is over, and
        now Sally can take her turn by locking and editing.</p><div class="figure"><a name="svn-ch2-dia3"></a><p class="title"><b>Figure 2.3. The Lock-Modify-Unlock Solution</b></p><div><img src="images/ch02dia3.png" alt="The Lock-Modify-Unlock Solution"></div></div><p>The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</p><div class="itemizedlist"><ul type="disc"><li><p>
            <span class="emphasis"><em>Locking may cause administrative problems.</em></span>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.</p></li><li><p>
            <span class="emphasis"><em>Locking may cause unnecessary serialization.</em></span>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</p></li><li><p>
            <span class="emphasis"><em>Locking may create a false sense of security.</em></span>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore. The locking system was
            powerless to prevent the problem&#8212;yet it somehow
            provided a sense of false security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus inhibits them from
            discussing their incompatible changes early
            on.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.3"></a>The Copy-Modify-Merge Solution</h3></div></div><div></div></div><p>Subversion, CVS, and other version control systems use a
        <i class="firstterm">copy-modify-merge</i> model as an
        alternative to locking.  In this model, each user's client
        reads the repository and creates a personal <i class="firstterm">working
        copy</i> of the file or project.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</p><p>Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file "A" within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <i class="firstterm">out-of-date</i>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <i class="firstterm">merge</i>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.</p><div class="figure"><a name="svn-ch2-dia4"></a><p class="title"><b>Figure 2.4. The Copy-Modify-Merge Solution</b></p><div><img src="images/ch02dia4.png" alt="The Copy-Modify-Merge Solution"></div></div><div class="figure"><a name="svn-ch2-dia5"></a><p class="title"><b>Figure 2.5. &#8230;Copy-Modify-Merge Continued</b></p><div><img src="images/ch02dia5.png" alt="&#8230;Copy-Modify-Merge Continued"></div></div><p>But what if Sally's changes <span class="emphasis"><em>do</em></span> overlap
        with Harry's changes?  What then?  This situation is called a
        <i class="firstterm">conflict</i>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes (perhaps by
        discussing the conflict with Sally!), he can safely save the
        merged file back to the repository.</p><p>The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</p><p>In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-3"></a>Subversion in Action</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.1"></a>Working Copies</h3></div></div><div></div></div><p>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</p><p>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.</p><p>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to "publish" your changes to the
        other people working with you on your project (by writing to
        the repository).  If other people publish their own changes,
        Subversion provides you with commands to merge those changes
        into your working directory (by reading from the
        repository).</p><p>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <tt class="filename">.svn</tt>, also known as
        the working copy <i class="firstterm">administrative
        directory</i>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</p><p>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</p><p>For example, suppose you have a repository that contains
        two software projects.</p><div class="figure"><a name="svn-ch2-dia6"></a><p class="title"><b>Figure 2.6. The Repository's Filesystem</b></p><div><img src="images/ch02dia6.png" alt="The Repository's Filesystem"></div></div><p>In other words, the repository's root directory has two
        subdirectories: <tt class="filename">paint</tt> and
        <tt class="filename">calc</tt>.</p><p>To get a working copy, you must <i class="firstterm">check
        out</i> some subtree of the repository.  (The term
        "check out" may sound like it has something to do with locking
        or reserving resources, but it doesn't; it simply creates a
        private copy of the project for you.) For example, if you
        check out <tt class="filename">/calc</tt>, you will get a working
        copy like this: </p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c

$ ls -a calc
Makefile  integer.c  button.c  .svn/
</pre><p>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <tt class="filename">/calc</tt>
        directory, with one additional
        entry&#8212;<tt class="filename">.svn</tt>&#8212;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</p><div class="sidebar"><a name="svn-ch-02-sidebar-1"></a><p class="title"><b>Repository URLs</b></p><p>Subversion repositories can be accessed through many
          different methods&#8212;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  The URL schema indicates the access
          method:</p><div class="table"><a name="svn-ch-02-table-1"></a><p class="title"><b>Table 2.1. Repository Access URLs</b></p><table summary="Repository Access URLs" border="1"><colgroup><col><col></colgroup><thead><tr><th>Schema</th><th>Access Method</th></tr></thead><tbody><tr><td><tt class="literal">file:///</tt></td><td>direct repository access (on local disk)</td></tr><tr><td><tt class="literal">http://</tt></td><td>access via WebDAV protocol to Subversion-aware
                  Apache server</td></tr><tr><td><tt class="literal">https://</tt></td><td>same as <tt class="literal">http://</tt>, but with
                  SSL encryption.</td></tr><tr><td><tt class="literal">svn://</tt></td><td>unauthenticated TCP/IP access via custom protocol to an
                  <tt class="literal">svnserve</tt> server</td></tr><tr><td><tt class="literal">svn+ssh://</tt></td><td>authenticated, encrypted TCP/IP access via
                custom protocol to an <tt class="literal">svnserve</tt>
                server</td></tr></tbody></table></div><p>For the most part, Subversion's URLs use the standard
          syntax, allowing for server names and port numbers to be
          specified as part of the URL.  Remember that the
          <tt class="literal">file:</tt> access method is valid only for
          locations on the same server as the client&#8212;in fact, in
          accordance with convention, the server name portion of the
          URL is required to be either absent or
          <tt class="literal">localhost</tt>:</p><pre class="screen">
$ svn checkout file:///path/to/repos
&#8230;
$ svn checkout file://localhost/path/to/repos
&#8230;
</pre><p>Also, users of the <tt class="literal">file:</tt> scheme on
          Windows platforms will need to use an unofficially
          &#8220;<span class="quote">standard</span>&#8221; syntax for accessing repositories
          that are on the same machine, but on a different drive than
          the client's current working drive.  Either of the two
          following URL path syntaxes will work where
          <tt class="literal">X</tt> is the drive on which the repository
          resides:</p><pre class="screen">
C:\&gt; svn checkout file:///X:/path/to/repos
&#8230;
C:\&gt; svn checkout "file:///X|/path/to/repos"
&#8230;
</pre><p>In the second syntax, you need to quote the URL so that
          the vertical bar character is not interpreted as a pipe.</p><p>Note that a URL uses ordinary slashes even though the native
          (non-URL) form of a path on Windows uses backslashes.</p></div><p>Suppose you make changes to <tt class="filename">button.c</tt>.
        Since the <tt class="filename">.svn</tt> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <i class="firstterm">committing</i> (or <i class="firstterm">checking
        in</i>) changes to the repository.</p><p>To publish your changes to others, you can use
        Subversion's <span><b class="command">commit</b></span> command:</p><pre class="screen">
$ svn commit button.c
Sending button.c
Transmitting file data..
Committed revision 57.
</pre><p>Now your changes to <tt class="filename">button.c</tt> have
        been committed to the repository; if another user checks out a
        working copy of <tt class="filename">/calc</tt>, they will see
        your changes in the latest version of the file.</p><p>Suppose you have a collaborator, Sally, who checked out a
        working copy of <tt class="filename">/calc</tt> at the same time
        you did.  When you commit your change to
        <tt class="filename">button.c</tt>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</p><p>To bring her project up to date, Sally can ask
        Subversion to <i class="firstterm">update</i> her working copy,
        by using the Subversion <span><b class="command">update</b></span> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</p><pre class="screen">
$ pwd
/home/sally/calc

$ ls -a 
.svn/ Makefile integer.c button.c

$ svn update
U button.c
</pre><p>The output from the <span><b class="command">svn update</b></span> command
        indicates that Subversion updated the contents of
        <tt class="filename">button.c</tt>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <tt class="filename">.svn</tt> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.2"></a>Revisions</h3></div></div><div></div></div><p>An <span><b class="command">svn commit</b></span> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</p><p>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</p><p>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <i class="firstterm">revision</i>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</p><p>A nice way to visualize the repository is as a series of
        trees.  Imagine an array of revision numbers, starting at 0,
        stretching from left to right.  Each revision number has a
        filesystem tree hanging below it, and each tree is a
        &#8220;<span class="quote">snapshot</span>&#8221; of the way the repository looked after
        each commit. </p><div class="figure"><a name="svn-ch2-dia7"></a><p class="title"><b>Figure 2.7. The Repository</b></p><div><img src="images/ch02dia7.png" alt="The Repository"></div></div><div class="sidebar"><p class="title"><b>Global Revision Numbers</b></p><p>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <span class="emphasis"><em>entire
          trees</em></span>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When a
          Subversion user talks about ``revision 5 of
          <tt class="filename">foo.c</tt>'', they really mean
          ``<tt class="filename">foo.c</tt> as it appears in revision 5.''
          Notice that in general, revisions N and M of a file do
          <span class="emphasis"><em>not</em></span> necessarily differ!  Because CVS
          uses per-file revisions numbers, CVS users might want to
          look at Appendix A, "SVN for CVS Users", for more details.
          </p></div><p>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:4
</pre><p>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <tt class="filename">button.c</tt>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:5
</pre><p>Suppose that, at this point, Sally commits a change to
        <tt class="filename">integer.c</tt>, creating revision 6.  If you
        use <span><b class="command">svn update</b></span> to bring your working copy
        up to date, then it will look like this:</p><pre class="screen">
calc/Makefile:6
     integer.c:6
     button.c:6
</pre><p>Sally's changes to <tt class="filename">integer.c</tt> will
        appear in your working copy, and your change will still be
        present in <tt class="filename">button.c</tt>.  In this example,
        the text of <tt class="filename">Makefile</tt> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <tt class="filename">Makefile</tt> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.3"></a>How Working Copies Track the Repository</h3></div></div><div></div></div><p>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <tt class="filename">.svn/</tt> administrative area:</p><div class="itemizedlist"><ul type="disc"><li><p>what revision your working file is based on
            (this is called the file's <i class="firstterm">working
             revision</i>), and</p></li><li><p>a timestamp recording when the local copy was
            last updated by the repository.</p></li></ul></div><p>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</p><div class="variablelist"><dl><dt><span class="term">Unchanged, and current</span></dt><dd><p>The file is unchanged in the working
          directory, and no changes to that file have been committed
          to the repository since its working revision.  A
          <span><b class="command">svn commit</b></span> of the file will do nothing,
          and an <span><b class="command">svn update</b></span> of the file will do
          nothing. </p></dd><dt><span class="term">Locally changed, and current</span></dt><dd><p>The file has been changed in the working
          directory, and no changes to that file have been committed
          to the repository since its base revision.  There are local
          changes that have not been committed to the repository, thus
          an <span><b class="command">svn commit</b></span> of the file will succeed in
          publishing your changes, and an <span><b class="command">svn update</b></span>
          of the file will do nothing.</p></dd><dt><span class="term">Unchanged, and out-of-date</span></dt><dd><p>The file has not been changed in the working
          directory, but it has been changed in the repository.  The
          file should eventually be updated, to make it current with
          the public revision.  An <span><b class="command">svn commit</b></span> of the
          file will do nothing, and an <span><b class="command">svn update</b></span> of
          the file will fold the latest changes into your working
          copy.</p></dd><dt><span class="term">Locally changed, and out-of-date</span></dt><dd><p>The file has been changed both in the
          working directory, and in the repository.  An <span><b class="command">svn
          commit</b></span> of the file will fail with an "out-of-date"
          error.  The file should be updated first; an <span><b class="command">svn
          update</b></span> command will attempt to merge the public
          changes with the local changes.  If Subversion can't
          complete the merge in a plausible way automatically, it
          leaves it to the user to resolve the
          conflict.</p></dd></dl></div><p>This may sound like a lot to keep track of, but the
        <span><b class="command">svn status</b></span> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.4"></a>The Limitations of Mixed Revisions</h3></div></div><div></div></div><p>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing mixed revision
        numbers.</p><p>At first, it may not be entirely clear why this sort of
        flexibility is considered a feature, and not a liability.
        After completing a commit to the repository, the freshly
        committed files and directories are at more recent working
        revision than the rest of the working copy.  It looks like a
        bit of a mess.  As demonstrated earlier, the working copy can
        always be brought to a single working revision by running
        <span><b class="command">svn update</b></span>.  Why would someone
        <span class="emphasis"><em>deliberately</em></span> want a mixture of working
        revisions?</p><p>Assuming your project is sufficiently complex, you'll
        discover that it's sometimes nice to forcibly
        &#8220;<span class="quote">backdate</span>&#8221; portions of your working copy to an
        earlier revision; you'll learn how to do that in Chapter 3.
        Perhaps you'd like to test an earlier version of a sub-module,
        contained in a subdirectory, or perhaps you'd like to examine
        a number of previous versions of a file in the context of the
        latest tree.</p><p>However you make use of mixed-revisions in your working
        copy, there are limitations to this flexibility.</p><p>First, you cannot commit the deletion of a file or
        directory which isn't fully up-to-date.  If a newer version of
        the item exists in the repository, your attempt to delete will
        be rejected, to prevent you from accidentally
        destroying changes you've not yet seen.</p><p>Second, you cannot commit a metadata change to a directory
        unless it's fully up-to-date.  You'll learn about attaching
        &#8220;<span class="quote">properties</span>&#8221; to items in Chapter 6.  A
        directory's working revision defines a specific set of entries
        and properties, and thus committing a property change to an
        out-of-date directory may destroy properties you've not yet
        seen.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-4"></a>Summary</h2></div></div><div></div></div><p>We've covered a number of fundamental Subversion concepts in
    this chapter:</p><div class="itemizedlist"><ul type="disc"><li><p>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</p></li><li><p>We've seen some simple examples of how two collaborators
        can use Subversion to publish and receive changes from one
        another, using the 'copy-modify-merge' model.</p></li><li><p>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</p></li></ul></div><p>At this point, you should have a good idea of how Subversion
    works in the most general sense.  Armed with this knowledge, you
    should now be ready to jump into the next chapter, which is a
    detailed tour of Subversion's commands and features. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-3"></a>Chapter 3. Guided Tour</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-3-sect-1">Help!</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-2">Import</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-3">Revisions: Numbers, Keywords, and Dates, Oh My!</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-3.1">Revision Numbers</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.2">Revision Keywords</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.3">Revision Dates</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-4">Initial Checkout</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-5">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-4.1">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.2">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.3">Examine Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.4">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-4.5">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-6">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-5.1">svn log</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.2">svn diff</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.3">svn cat</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.4">svn list</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.5">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-7">Other Frequently Used Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-7.1">svn cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-7.3">svn import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-8">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Now we will go into the details of using Subversion.  By the
      time you reach the end of this chapter, you will be able to
      perform almost all the tasks you need to use Subversion in a
      normal day's work.  You'll start with an initial checkout of
      your code, and walk through making changes and examining those
      changes. You'll also see how to bring changes made by others
      into your working copy, examine them, and work through any
      conflicts that might arise.</p><p>Note that this chapter is not meant to be an exhaustive list
      of all Subversion's commands&#8212;rather, it's a conversational
      introduction to the most common Subversion tasks you'll
      encounter.  This chapter assumes that you've read and understood
      <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a> and are familiar with the general
      model of Subversion.  For a complete reference of all commands,
      see <a href="#svn-ch-8" title="Chapter 8. Subversion Complete Reference">Chapter 8, <i>Subversion Complete Reference</i></a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-1"></a>Help!</h2></div></div><div></div></div><p>Before reading on, here is the most important command you'll
      ever need when using Subversion: <span><b class="command">svn help</b></span>.
      The Subversion command-line client tries to be
      self-documenting&#8212;at any time, a quick <span><b class="command">svn help
      &lt;subcommand&gt;</b></span> will describe the syntax, switches,
      and behavior of the <span><b class="command">subcommand</b></span>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-2"></a>Import</h2></div></div><div></div></div><p>You use <span><b class="command">svn import</b></span> to import a new
    project into a Subversion repository.  While this is most likely
    the very first thing you will do when you set up your Subversion
    server, it's not something that happens very often.  For a
    detailed description of import, see <a href="#svn-ch-3-sect-7.3" title="svn import">the section called &#8220;svn import&#8221;</a> later in this chapter.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-3"></a>Revisions: Numbers, Keywords, and Dates, Oh My!</h2></div></div><div></div></div><p>Before we go on, you should know a bit about how to identify
      a particular revision in your repository.  As you learned in
      <a href="#svn-ch-2-sect-3.2" title="Revisions">the section called &#8220;Revisions&#8221;</a>, a revision is a
      &#8220;<span class="quote">snapshot</span>&#8221; of the repository at a particular moment
      in time.  As you continue to commit and grow your repository,
      you need a mechanism for identifying these snapshots.</p><p>You specify these revisions by using the
      <tt class="option">--revision</tt> (<tt class="option">-r</tt>) switch plus
      the revision you want (<span><b class="command">svn --revision REV</b></span>) or
      you can specify a range by separating two revisions with a colon
      (<span><b class="command">svn --revision REV1:REV2</b></span>).  And Subversion
      lets you refer to these revisions by number, keyword, or
      date.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.1"></a>Revision Numbers</h3></div></div><div></div></div><p>When you create a new Subversion repository, it begins its
        life at revision zero and each successive commit increases the
        revision number by one.  After your commit completes, the
        Subversion client informs you of the new revision
        number:</p><pre class="screen">
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
      </pre><p>If at any point in the future you want to refer to that
        revision (we'll see how and why we might want to do that later
        in this chapter), you can refer to it as
        &#8220;<span class="quote">3</span>&#8221;.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.2"></a>Revision Keywords</h3></div></div><div></div></div><p>The Subversion client understands a number of
        <i class="firstterm">revision keywords</i>.  These keywords
        can be used instead of integer arguments to the
        <tt class="option">--revision</tt> switch, and are resolved into
        specific revision numbers by Subversion:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Each directory in your working copy contains an
        <tt class="filename">.svn</tt> administrative area.  For every file
        in a directory, Subversion keeps a copy of each file in the
        administrative area.  This copy is an unmodified (no keyword
        expansion, no end-of-line translation, no nothing) copy of the
        file as it existed in the last revision (called the
        &#8220;<span class="quote">BASE</span>&#8221; revision) that you updated it to in your
        working copy.  We refer to this file as a
        &#8220;<span class="quote">pristine</span>&#8221; copy.</p></div><div class="variablelist"><dl><dt><span class="term">HEAD</span></dt><dd><p>The latest revision in the repository.</p></dd><dt><span class="term">BASE</span></dt><dd><p>The &#8220;<span class="quote">pristine</span>&#8221; revision of an item in a
              working copy.</p></dd><dt><span class="term">COMMITTED</span></dt><dd><p>The last revision in which an item changed before (or
              at) BASE.</p></dd><dt><span class="term">PREV</span></dt><dd><p>The revision just <span class="emphasis"><em>before</em></span> the last
              revision in which an item changed.  (Technically,
              COMMITTED - 1.)</p></dd></dl></div><p>Here are some examples of revision keywords in action
        (don't worry if the commands don't make sense yet; we'll be
        explaining these commands as we go through the
        chapter):</p><pre class="screen">
$ svn diff --revision PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log --revision HEAD
# shows log message for the latest repository commit

$ svn diff --revision HEAD
# compares your working file (with local mods) to the latest version
# in the repository.

$ svn diff --revision BASE:HEAD foo.c
# compares your &#8220;<span class="quote">pristine</span>&#8221; foo.c (no local mods) with the 
# latest version in the repository

$ svn log --revision BASE:HEAD
# shows all commit logs since you last updated

$ svn update --revision PREV foo.c
# rewinds the last change on foo.c.
# (foo.c's working revision is decreased.)
      </pre><p>These keywords allow you to perform many common (and
        helpful) operations without having to look up specific
        revision numbers or remember the exact revision of your
        working copy.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.3"></a>Revision Dates</h3></div></div><div></div></div><p>Anywhere that you specify a revision number or revision
        keyword, you can also specify a date by specifying the date
        inside curly braces &#8220;<span class="quote">{}</span>&#8221;.  You can even access
        a range of changes in the repository using both dates and
        revisions together!</p><p>Subversion accepts an incredible number of date formats
        &#8212;just remember to use quotes around any date that
        contains spaces.  Here are just a few of the formats that
        Subversion accepts:</p><pre class="screen">
$ svn checkout --revision {2002-02-17}
$ svn checkout --revision {2/17/02}
$ svn checkout --revision {"17 Feb"}
$ svn checkout --revision {"17 Feb 2002"}
$ svn checkout --revision {"17 Feb 2002 15:30"}
$ svn checkout --revision {"17 Feb 2002 15:30:12 GMT"}
$ svn checkout --revision {"10 days ago"} 
$ svn checkout --revision {"last week"} 
$ svn checkout --revision {"yesterday"} 
&#8230;
      </pre><p>When you specify a date as a revision, Subversion finds
        the most recent revision of the repository as of that
        date:</p><pre class="screen">
$ svn log --revision {11/28/2002}
------------------------------------------------------------------------
r12 | ira | 2002-11-27 12:31:51 -0600 (Wed, 27 Nov 2002) | 6 lines
&#8230;
      </pre><div class="sidebar"><p class="title"><b>Is Subversion a Day Early?</b></p><p>If you specify a single date as a revision without
          specifying a time of day (for example
          <tt class="literal">11/27/02</tt>, you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <span class="emphasis"><em>most recent revision of the
          repository</em></span> as of the date you give.  If you give
          a date without a timestamp, like
          <tt class="literal">11/27/02</tt>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the day of the 27th.</p><p>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<tt class="literal">"27 Nov 2002
          23:59"</tt>), or just specify the next day
          (<tt class="literal">"28 Nov 2002"</tt>).</p></div><p>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</p><pre class="screen">
$ svn log --revision {2002-11-20}:{2002-11-29}
&#8230;
      </pre><p>As we pointed out, you can also mix dates and revisions:</p><pre class="screen">
$ svn log -r {11/20/02}:4040
      </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-4"></a>Initial Checkout</h2></div></div><div></div></div><p>Most of the time, you will start using a Subversion
      repository by doing a <i class="firstterm">checkout</i> of your
      project.  &#8220;<span class="quote">Checking out</span>&#8221; a repository creates a
      copy of it on your local machine.  This copy contains the
      <tt class="literal">HEAD</tt> (latest revision) of the Subversion
      repository that you specify on the command line:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
&#8230;
Checked out revision 2499.
    </pre><div class="sidebar"><p class="title"><b>Repository Layout</b></p><p>If you're wondering what <tt class="literal">trunk</tt> is all
        about in the above URL, it's part of the way we recommend
        you lay out your Subversion repository which we'll talk a lot
        more about in <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>.</p></div><p>Although the above example checks out the trunk directory,
      you can just as easily check out any deep subdirectory of a
      repository by specifying the subdirectory in the checkout
      URL:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools
A  tools/readme-dblite.html
A  tools/fo-stylesheet.xsl
A  tools/svnbook.el
A  tools/dtd
A  tools/dtd/dblite.dtd
&#8230;
Checked out revision 3678.
    </pre><p>Since Subversion uses a &#8220;<span class="quote">copy-modify-merge</span>&#8221;
      model instead of &#8220;<span class="quote">lock-modify-unlock</span>&#8221; (see <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>), you're now ready to start making changes
      to the files and directories that you've checked out (known
      collectively as your <i class="firstterm">working
      copy</i>).</p><p>In other words, your &#8220;<span class="quote">working copy</span>&#8221; is now just
      like any other collection of files and/or directories on your
      system<sup>[<a name="id2884940" href="#ftn.id2884940">1</a>]</sup>.  You can edit and
      change them, move them around, you can even delete the entire
      working copy and forget about it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While your working copy is &#8220;<span class="quote">just like any other
          collection of files and directories on your system</span>&#8221;,
          you need to let Subversion know if you're going to be
          rearranging anything inside of your working copy.  If you
          want to copy or move an item in a working copy, you should
          use <span><b class="command">svn copy</b></span> or <span><b class="command">svn
          move</b></span> instead of the copy and move commands
          provided by your operating system.  We'll talk more about
          them later in this chapter.</p></div><p>Unless you're ready to <i class="firstterm">commit</i> a new
      file or directory, or changes to existing ones, there's no need
      to further notify the Subversion server that you've done
      anything.</p><div class="sidebar"><p class="title"><b>What's with the <tt class="filename">.svn</tt> directory?</b></p><p>Every directory in a working copy contains an
        <i class="firstterm">administrative area</i>, a subdirectory
        named <tt class="filename">.svn</tt>.  Usually, directory listing
        commands won't show this subdirectory, but it is nevertheless
        an important directory.  Whatever you do, don't delete or
        change anything in the administrative area!  Subversion
        depends on it to manage your working copy.</p></div><p>While you can certainly check out a working copy with the
      URL of the repository as the only argument, you can also specify
      a directory after your repository URL.  This places your working
      copy into the new directory that you name.  For example:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
&#8230;
Checked out revision 2499.
    </pre><p>That will place your working copy in a directory named
      <tt class="literal">subv</tt> instead of a directory named
      <tt class="literal">trunk</tt> as we did previously.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-5"></a>Basic Work Cycle</h2></div></div><div></div></div><p>Subversion has numerous features, options, bells and whistles, but on
      a day-to-day basis, odds are that you will only use a few of them. In
      this section we'll run through the most common things that you might
      find yourself doing with Subversion in the course of a day's work.</p><p>The typical work cycle looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p>Update your working copy</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn update</b></span></p></li></ul></div></li><li><p>Make changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn add</b></span></p></li><li><p><span><b class="command">svn delete</b></span></p></li><li><p><span><b class="command">svn move</b></span></p></li><li><p><span><b class="command">svn copy</b></span></p></li></ul></div></li><li><p>Examine your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn status</b></span></p></li><li><p><span><b class="command">svn diff</b></span></p></li><li><p><span><b class="command">svn revert</b></span></p></li></ul></div></li><li><p>Merge others' changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn merge</b></span></p></li><li><p><span><b class="command">svn resolved</b></span></p></li></ul></div></li><li><p>Commit your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn commit</b></span></p></li></ul></div></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-4.1"></a>Update Your Working Copy</h3></div></div><div></div></div><p>When working on a project with a team, you'll want to
        <i class="firstterm">update</i> your working copy: that is,
        receive any changes from other developers on the
        project. You'll use <span><b class="command">svn update</b></span> to bring
        your working copy into sync with the latest revision in the
        repository.</p><pre class="screen">
$ svn update
U  ./foo.c
U  ./bar.c
Updated to revision 2.
      </pre><p>In this case, someone else checked in modifications to
        both <tt class="filename">foo.c</tt> and <tt class="filename">bar.c</tt>
        since the last time you updated, and Subversion has updated
        your working copy to include those changes.</p><p>Let's examine the output of <span><b class="command">svn update</b></span>
        a bit more.  When the server sends changes to your working
        copy, a letter code is displayed next to each item to let you
        know what actions Subversion performed to bring your working
        copy up-to-date:</p><div class="variablelist"><dl><dt><span class="term"><tt class="computeroutput">U      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> was
              <tt class="computeroutput">U</tt>pdated (received changes
              from the server).</p></dd><dt><span class="term"><tt class="computeroutput">A      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">A</tt>dded to your working
              copy.</p></dd><dt><span class="term"><tt class="computeroutput">D      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">D</tt>eleted from your working
              copy.</p></dd><dt><span class="term"><tt class="computeroutput">R      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">R</tt>eplaced in your working
              copy; that is, <tt class="filename">foo</tt> was deleted, and a
              new item with the same name was added.  While they may have
              the same name, the repository considers them to be distinct
              objects with distinct histories.</p></dd><dt><span class="term"><tt class="computeroutput">G      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> received new changes
              from the repository, but your local copy of the file had
              your modifications.  The changes did not intersect,
              however, so Subversion has
              mer<tt class="computeroutput">G</tt>ed the repository's
              changes into the file without a problem.</p></dd><dt><span class="term"><tt class="computeroutput">C      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> received
              <tt class="computeroutput">C</tt>onflicting changes from
              the server.  The changes from the server directly overlap
              your own changes to the file.  No need to panic, though.
              This overlap needs to be resolved by a human (you); we
              discuss this situation later in this chapter.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-4.2"></a>Make Changes to Your Working Copy</h3></div></div><div></div></div><p>Now you can get to work and make changes in your
        working copy. It's usually most convenient to decide on a
        particular change (or set of changes) to make, such as writing
        a new feature, fixing a bug, etc.  The Subversion commands
        that you will use here are <span><b class="command">svn add</b></span>,
        <span><b class="command">svn delete</b></span>, <span><b class="command">svn copy</b></span>,
        and <span><b class="command">svn move</b></span>.  However, if you are merely
        editing a file (or files) that is already in Subversion, you
        may not need to use any of these commands until you commit.
        Changes you can make to your working copy:</p><div class="variablelist"><dl><dt><span class="term">File changes</span></dt><dd><p>This is the simplest sort of change.  You don't need
              to tell Subversion that you intend to change a file;
              just make your changes.  Subversion will be able to
              automatically detect which files have been
              changed.</p></dd><dt><span class="term">Tree changes</span></dt><dd><p>You can ask Subversion to &#8220;<span class="quote">mark</span>&#8221; files
              and directories for scheduled removal, addition,
              copying, or moving.  While these changes may take place
              immediately in your working copy, no additions or
              removals will happen in the repository until you commit
              them.</p></dd></dl></div><p>To make file changes, use your text editor, word
        processor, graphics program, or whatever tool you would
        normally use.  Subversion handles binary files just as easily
        as it handles text files&#8212;and just as efficiently
        too.</p><p>Here is an overview of the four Subversion subcommands
        that you'll use most often to make tree changes (we'll cover
        <span><b class="command">svn import</b></span> and <span><b class="command">svn mkdir</b></span>
        later).</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">svn add foo</b></span></span></dt><dd><p>Schedule <tt class="filename">foo</tt> to be added to the
              repository.  When you next commit,
              <tt class="filename">foo</tt> will become a child of its
              parent directory.  Note that if <tt class="filename">foo</tt>
              is a directory, everything underneath <tt class="filename">foo</tt>
              will be scheduled for addition.  If you only want to
              schedule <tt class="filename">foo</tt> itself, pass the
              <tt class="option">--non-recursive</tt> (<tt class="option">-N</tt>)
              switch.</p></dd><dt><span class="term"><span><b class="command">svn delete foo</b></span></span></dt><dd><p>Schedule <tt class="filename">foo</tt> to be deleted from
              the repository.  If <tt class="filename">foo</tt> is a file,
              it is immediately deleted from your working copy.  If
              <tt class="filename">foo</tt> is a directory, it is not
              deleted, but Subversion schedules it for deletion.  When
              you commit your changes, <tt class="filename">foo</tt> will
              be removed from your working copy and the repository.
              <sup>[<a name="id2886151" href="#ftn.id2886151">2</a>]</sup></p></dd><dt><span class="term"><span><b class="command">svn copy foo bar</b></span></span></dt><dd><p>Create a new item <tt class="filename">bar</tt> as a
              duplicate of <tt class="filename">foo</tt>.
              <tt class="filename">bar</tt> is automatically scheduled for
              addition.  When <tt class="filename">bar</tt> is added to the
              repository on the next commit, its copy-history is
              recorded (as having originally come from
              <tt class="filename">foo</tt>).</p></dd><dt><span class="term"><span><b class="command">svn move foo bar</b></span></span></dt><dd><p>This command is exactly the same as running
              <span><b class="command">svn copy foo bar; svn delete foo</b></span>.
              That is, <tt class="filename">bar</tt> is scheduled for
              addition as a copy of <tt class="filename">foo</tt>, and
              <tt class="filename">foo</tt> is scheduled for
              removal.</p></dd></dl></div><div class="sidebar"><p class="title"><b>Changing the Repository Without a Working Copy</b></p><p>Earlier in this chapter, we said that you have to commit
          any changes that you make in order for the repository to
          reflect these changes. That's not entirely true&#8212;there
          <span class="emphasis"><em>are</em></span> some use-cases that immediately
          commit tree changes to the repository.  This only happens
          when a subcommand is operating directly on a URL, rather
          than on a working-copy path. In particular, specific uses
          of <span><b class="command">svn mkdir</b></span>, <span><b class="command">svn
          copy</b></span>, <span><b class="command">svn move</b></span>, and
          <span><b class="command">svn delete</b></span> can work with URLs.</p><p>URL operations behave in this manner because commands
          that operate on a working copy can use the working copy as a
          sort of &#8220;<span class="quote">staging area</span>&#8221; to set up your changes
          before committing them to the repository.  Commands that
          operate on URLs don't have this luxury, so when you operate
          directly on a URL, any of the above actions represent an
          immediate commit.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-4.3"></a>Examine Your Changes</h3></div></div><div></div></div><p>Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you cannot only
        make a more accurate log message, but you may discover that
        you've inadvertently changed a file, and this gives you a
        chance to revert those changes before committing.
        Additionally, this is a good opportunity to review and
        scrutinize changes before publishing them.  You can see
        exactly what changes you've made by using <span><b class="command">svn
        status</b></span>, <span><b class="command">svn diff</b></span>, and
        <span><b class="command">svn revert</b></span>.  You will usually use the first
        two commands to find out what files have changed in your
        working copy, and then perhaps the third to revert some (or
        all) of those changes.</p><p>Subversion has been optimized to help you with this task,
        and is able to do many things without communicating with the
        repository.  In particular, your working copy contains a
        secret cached &#8220;<span class="quote">pristine</span>&#8221; copy of each version
        controlled file within the <tt class="filename">.svn</tt> area.
        Because of this, Subversion can quickly show you how your
        working files have changed, or even allow you to undo your
        changes without contacting the repository.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.3.1"></a><span><b class="command">svn status</b></span></h4></div></div><div></div></div><p>You'll probably use the <span><b class="command">svn status</b></span>
          command more than any other Subversion command.</p><div class="sidebar"><p class="title"><b>CVS Users: Hold That Update!</b></p><p>You're probably used to using <span><b class="command">cvs
              update</b></span> to see what changes you've made to your
            working copy.  <span><b class="command">svn status</b></span> will give
            you all the information you need regarding what has
            changed in your working copy&#8212;without accessing the
            repository or potentially incorporating new changes
            published by other users.</p><p>In Subversion, <span><b class="command">update</b></span> does just
            that&#8212;it updates your working copy with any changes
            committed to the repository since the last time you've
            updated your working copy.  You'll have to break the habit
            of using the <span><b class="command">update</b></span> command to see what
            local modifications you've made.</p></div><p> If you run <span><b class="command">svn status</b></span> at the top of
          your working copy with no arguments, it will detect all file
          and tree changes you've made.  This example is designed to
          show all the different status codes that <span><b class="command">svn
          status</b></span> can return.  The text following
          <tt class="literal">#</tt> is not printed by <span><b class="command">svn
          status</b></span>.</p><pre class="screen">
$ svn status
  L    ./abc.c               # svn has a lock in its .svn directory for abc.c
M      ./bar.c               # the content in bar.c has local modifications
 M     ./baz.c               # baz.c has property but no content modifications
?      ./foo.o               # svn doesn't manage foo.o
!      ./some_dir            # svn manages this, but it's either missing or incomplete
~      ./qux                 # versioned as dir, but is file, or vice versa
A  +   ./moved_dir           # added with history of where it came from
M  +   ./moved_dir/README    # added with history and has local modifications
D      ./stuff/fish.c        # this file is scheduled for deletion
A      ./stuff/loot/bloo.h   # this file is scheduled for addition
C      ./stuff/loot/lump.c   # this file has conflicts from an update
    S  ./stuff/squawk        # this file or dir has been switched to a branch
        </pre><p>In this output format <span><b class="command">svn status</b></span>
          prints five columns of characters, followed by several
          whitespace characters, followed by a file or directory name.
          The first column tells the status of a file or directory
          and/or its contents.  The codes printed here are:</p><div class="variablelist"><dl><dt><span class="term"><tt class="computeroutput">A      file_or_dir</tt></span></dt><dd><p>The file or directory
                <tt class="filename">file_or_dir</tt> has been scheduled for
                addition into the repository.
              </p></dd><dt><span class="term"><tt class="computeroutput">M      file</tt></span></dt><dd><p>The contents of file <tt class="filename">file</tt> have
                been modified.</p></dd><dt><span class="term"><tt class="computeroutput">D      file_or_dir</tt></span></dt><dd><p>The file or directory
                <tt class="filename">file_or_dir</tt> has been scheduled for
                deletion from the repository.</p></dd><dt><span class="term"><tt class="computeroutput">X      dir</tt></span></dt><dd><p>The directory <tt class="filename">dir</tt> is
                unversioned, but is related to a Subversion externals
                definition.  To find out more about externals
                definitions, see <a href="#svn-ch-6-sect-3" title="Externals Definitions">the section called &#8220;Externals Definitions&#8221;</a>.</p></dd><dt><span class="term"><tt class="computeroutput">?      file_or_dir</tt></span></dt><dd><p>The file or directory
                <tt class="filename">file_or_dir</tt> is not under version
                control.  You can silence the question marks by either
                passing the <tt class="option">--quiet</tt>
                (<tt class="option">-q</tt>) switch to <span><b class="command">svn
                status</b></span>, or by setting the
                <tt class="literal">svn:ignore</tt> property on the parent
                directory.  For more information on ignored files, see
                <a href="#svn-ch-6-sect-2.3.3" title="svn:ignore">the section called &#8220;svn:ignore&#8221;</a>.</p></dd><dt><span class="term"><tt class="computeroutput">!      file_or_dir</tt></span></dt><dd><p>The file or directory
                <tt class="filename">file_or_dir</tt> is under version
                control but is missing or somehow incomplete.  The
                item can be missing if it's removed using a
                non-Subversion command.  In the case of a directory,
                it can be incomplete if you happened to interrupt a
                checkout or update.  A quick <span><b class="command">svn
                update</b></span> will refetch the file or directory
                from the repository, or <span><b class="command">svn revert
                file</b></span> will restore a missing file.</p></dd><dt><span class="term"><tt class="computeroutput">~     file_or_dir</tt></span></dt><dd><p>The file or directory
                <tt class="filename">file_or_dir</tt> is in the repository as
                one kind of object, but what's actually in your working
                copy is some other kind.  For example, Subversion might
                have a file in the repository, but you removed the file
                and created a directory in its place, without using the
                <span><b class="command">svn delete</b></span> nor <span><b class="command">svn add</b></span>
                commands.</p></dd><dt><span class="term"><tt class="computeroutput">C     file</tt></span></dt><dd><p><tt class="filename">file_or_dir</tt> is in a state of
                conflict.  That is, changes received from the server
                during an update overlap with local changes that you
                have in your working copy.  You must resolve this
                conflict before committing your changes to the
                repository.</p></dd></dl></div><p>The second column tells the status of a file or
          directory's properties (see <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a> for more information on
          properties).  If an <tt class="computeroutput">M</tt>
          appears in the second column, then the properties have been
          modified, otherwise a whitespace will be printed.</p><p>The third column will only show whitespace or an
          <tt class="computeroutput">L</tt> which means that
          Subversion has locked the item in
          the <tt class="filename">.svn</tt> working area.  You will see an
          <tt class="computeroutput">L</tt> if you run <span><b class="command">svn
          status</b></span> in a directory where an <span><b class="command">svn
          commit</b></span> is in progress&#8212;perhaps when you are
          editing the log message.  If Subversion is not running, then
          presumably Subversion was interrupted and the lock needs to
          be cleaned up by running <span><b class="command">svn cleanup</b></span>
          (more about that later in this chapter).</p><p>The fourth column will only show whitespace or a
          <tt class="computeroutput">+</tt> which means that the file
          or directory is scheduled to be added or modified with
          additional attached history.  This typically happens when you
          <span><b class="command">svn move</b></span> or <span><b class="command">svn copy</b></span> a file
          or directory.  If you see
          <tt class="computeroutput">A  +</tt>, this means
          the item is scheduled for addition-with-history.  It could be
          a file, or the root of a copied directory.
          <tt class="computeroutput">+</tt>
          means the item is part of a subtree scheduled for
          addition-with-history, i.e. some parent got copied, and it's
          just coming along for the ride.
          <tt class="computeroutput">M  +</tt> means the item
          is part of a subtree scheduled for addition-with-history,
          <span class="emphasis"><em>and</em></span> it has local modifications.  When you
          commit, first the parent will be added-with-history (copied),
          which means this file will automatically exist in the copy.
          Then the local modifications will be uploaded into the
          copy.</p><p>The fifth column will only show whitespace or an
          <tt class="computeroutput">S</tt>.  This signifies that the
          file or directory has been switched from the path of the
          rest of the working copy (using <span><b class="command">svn
          switch</b></span>) to a branch.</p><p>If you pass a specific path to <span><b class="command">svn
          status</b></span>, it gives you information about that item
          alone:</p><pre class="screen">
$ svn status stuff/fish.c
D      stuff/fish.c
        </pre><p><span><b class="command">svn status</b></span> also has a
          <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) switch,
          which will show you the status of <span class="emphasis"><em>every</em></span>
          item in your working copy, even if it has not been
          changed:</p><pre class="screen">
$ svn status --verbose
M               44        23    sally     ./README
                44        30    sally     ./INSTALL
M               44        20    harry     ./bar.c
                44        18    ira       ./stuff
                44        35    harry     ./stuff/trout.c
D               44        19    ira       ./stuff/fish.c
                44        21    sally     ./stuff/things
A                0         ?     ?        ./stuff/things/bloo.h
                44        36    harry     ./stuff/things/gloo.c
        </pre><p>This is the &#8220;<span class="quote">long form</span>&#8221; output of
          <span><b class="command">svn status</b></span>.  The first column remains
          same, but the second column shows the working-revision of
          the item.  The third and fourth columns show the revision in
          which the item last changed, and who changed it.</p><p>None of the above invocations to <span><b class="command">svn
          status</b></span> contact the repository, they work only
          locally by comparing the metadata in the
          <tt class="filename">.svn</tt> directory with the working copy.
          Finally, there is the <tt class="option">--show-updates</tt>
          (<tt class="option">-u</tt>) switch, which contacts the repository
          and adds information about things that are
          <i class="firstterm">out-of-date</i>:</p><pre class="screen">
$ svn status --show-updates --verbose
M      *        44        23    sally     ./README
M               44        20    harry     ./bar.c
       *        44        35    harry     ./stuff/trout.c
D               44        19    ira       ./stuff/fish.c
A                0         ?     ?        ./stuff/things/bloo.h
        </pre><p>Notice the two asterisks: if you were to run
          <span><b class="command">svn update</b></span> at this point, you would
          receive changes to <tt class="filename">README</tt>
          and <tt class="filename">trout.c</tt>.  This tells you some very
          useful information&#8212;you'll need to update and get the
          server changes on <tt class="filename">README</tt> before you
          commit, or the repository will reject your commit for being
          out-of-date.  (More on this subject later.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.3.2"></a><span><b class="command">svn diff</b></span></h4></div></div><div></div></div><p>Another way to examine your changes is with the
          <span><b class="command">svn diff</b></span> command.  You can find out
          <span class="emphasis"><em>exactly</em></span> how you've modified things by
          running <span><b class="command">svn diff</b></span> with no arguments, which
          prints out file changes in unified diff
          format:<sup>[<a name="id2887457" href="#ftn.id2887457">3</a>]</sup></p><pre class="screen">
$ svn diff
Index: ./bar.c
===================================================================
--- ./bar.c
+++ ./bar.c	Mon Jul 15 17:58:18 2002
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
return 0;
}

Index: ./README
===================================================================
--- ./README
+++ ./README	Mon Jul 15 17:58:18 2002
@@ -193,3 +193,4 @@ 
+Note to self:  pick up laundry.

Index: ./stuff/fish.c
===================================================================
--- ./stuff/fish.c
+++ ./stuff/fish.c  Mon Jul 15 17:58:18 2002
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: ./stuff/things/bloo.h
===================================================================
--- ./stuff/things/bloo.h
+++ ./stuff/things/bloo.h  Mon Jul 15 17:58:18 2002
+Here is a new file to describe
+things about bloo.
        </pre><p>The <span><b class="command">svn diff</b></span> command produces this
          output by comparing your working files against the cached
          &#8220;<span class="quote">pristine</span>&#8221; copies within the
          <tt class="filename">.svn</tt> area.  Files scheduled for
          addition are displayed as all added-text, and files
          scheduled for deletion are displayed as all deleted
          text.</p><p>Output is displayed in <i class="firstterm">unified diff
          format</i>.  That is, removed lines are prefaced
          with a <tt class="literal">-</tt> and added lines are prefaced
          with a <tt class="literal">+</tt>.  <span><b class="command">svn diff</b></span>
          also prints filename and offset information useful to the
          <span><b class="command">patch</b></span> program, so you can generate
          &#8220;<span class="quote">patches</span>&#8221; by redirecting the diff output to a
          file:</p><pre class="screen">
$ svn diff &gt; patchfile
        </pre><p>You could, for example, email the patchfile to another
          developer for review or testing prior to commit.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.3.3"></a><span><b class="command">svn revert</b></span></h4></div></div><div></div></div><p>Now suppose you see the above diff output, and realize
          that your changes to <tt class="filename">README</tt> are a
          mistake; perhaps you accidentally typed that text into the
          wrong file in your editor.</p><p>This is a perfect opportunity to use <span><b class="command">svn
          revert</b></span>.</p><pre class="screen">
$ svn revert README
Reverted ./README
        </pre><p>Subversion reverts the file to its pre-modified state by
          overwriting it with the cached &#8220;<span class="quote">pristine</span>&#8221; copy
          from the <tt class="filename">.svn</tt> area.  But also note that
          <span><b class="command">svn revert</b></span> can undo
          <span class="emphasis"><em>any</em></span> scheduled operations&#8212;for
          example, you might decide that you don't want to add a new
          file after all:</p><pre class="screen">
$ svn status foo
?      foo

$ svn add foo
A         foo

$ svn revert foo
Reverted foo

$ svn status foo
?      foo
        </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span><b class="command">svn revert</b></span>
          <i class="replaceable"><tt>ITEM</tt></i> has exactly the same effect as
          deleting <i class="replaceable"><tt>ITEM</tt></i> from your working
          copy and then running <span><b class="command">svn update</b></span>
          <i class="replaceable"><tt>ITEM</tt></i>.  However, if you're reverting
          a file, <span><b class="command">svn revert</b></span> has one very noticeable
          difference&#8212;it doesn't have to communicate with the
          repository to restore your file.</p></div><p>Or perhaps you mistakenly removed a file from version
          control:</p><pre class="screen">
$ svn status README 
       README

$ svn delete README 
D         README

$ svn revert README
Reverted README

$ svn status README
       README
        </pre></div><div class="sidebar"><p class="title"><b>Look Ma! No Network!</b></p><p>All three of these commands (<span><b class="command">svn
          status</b></span>, <span><b class="command">svn diff</b></span>, and
          <span><b class="command">svn revert</b></span>) can be used without any
          network access.  This makes it easy to manage your
          changes-in-progress when you are somewhere without a network
          connection such as traveling on an airplane, riding a
          commuter train or hacking on the beach.</p><p>Subversion does this by keeping private caches of
          pristine versions of each versioned file inside of the
          <tt class="filename">.svn</tt> administrative areas.  This allows
          Subversion to report&#8212;and revert&#8212;local
          modifications to those files <span class="emphasis"><em>without network
          access</em></span>.  This cache (called the "text-base") also
          allows Subversion to send the user's local modifications
          during a commit to the server as a compressed delta against
          the pristine version.  Having this cache is a tremendous
          benefit&#8212;even if you have a fast net connection, it's
          much faster to send only a file's changes rather than the
          whole file to the server.  At first glance, this might not
          seem that important, but imagine the repercussions if you
          try to commit a one line change to a 400MB file and have to
          send the whole file to the server!</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-4.4"></a>Resolve Conflicts (Merging Others' Changes)</h3></div></div><div></div></div><p>We've already seen how <span><b class="command">svn status -u</b></span>
          can predict conflicts.  Suppose you run <span><b class="command">svn
          update</b></span> and some interesting things occur:</p><pre class="screen">
$ svn update
U  ./INSTALL
G  ./README
C  ./bar.c
      </pre><p>The <tt class="computeroutput">U</tt> and
        <tt class="computeroutput">G</tt> codes are no cause for
        concern; those files cleanly absorbed changes from the
        repository.  The files marked with
        <tt class="computeroutput">U</tt> contained no local changes
        but were <tt class="computeroutput">U</tt>pdated with changes
        from the repository.  The <tt class="computeroutput">G</tt>
        stands for mer<tt class="computeroutput">G</tt>ed, which
        means that the file had local changes to begin with, but the
        changes coming from the repository didn't overlap in any
        way.</p><p>But the <tt class="computeroutput">C</tt> stands for
        conflict.  This means that the changes from the server overlapped
        with your own, and now you have to manually choose between
        them.</p><p>Whenever a conflict occurs, your Subversion client does
      the three things:</p><div class="itemizedlist"><ul type="disc"><li><p>Subversion prints a <tt class="computeroutput">C</tt> during
            the update, and remembers that the file is
            &#8220;<span class="quote">conflicted</span>&#8221;.</p></li><li><p>Subversion places <i class="firstterm">conflict
            markers</i> into the file to visibly demonstrate
            the overlapping areas.</p></li><li><p>For every conflicted file, Subversion places three
            extra files in your working copy:</p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">filename.mine</tt></span></dt><dd><p> This is your file as it existed in your working
                  copy before you updated your working copy&#8212;that
                  is, without conflict markers.  This file has your
                  latest changes in it and nothing else.</p></dd><dt><span class="term"><tt class="filename">filename.rOLDREV</tt></span></dt><dd><p>This is the file that was the BASE revision
                  before you updated your working copy.  That is, the
                  file that you checked out before you made your
                  latest edits.</p></dd><dt><span class="term"><tt class="filename">filename.rNEWREV</tt></span></dt><dd><p>This is the file that your Subversion client
                  just received from the server when you updated your
                  working copy.  This file corresponds to the HEAD
                  revision of the repository.</p></dd></dl></div><p>Here <tt class="literal">OLDREV</tt> is the revision number
            of the file in your <tt class="filename">.svn</tt> directory
            and <tt class="literal">NEWREV</tt> is the revision number of
            the repository HEAD.
          </p></li></ul></div><p>For example, Sally makes changes to the file
        <tt class="filename">sandwich.txt</tt> in the repository.  Harry has
        just changed the file in his working copy and checked it in.
        Sally updates her working copy before checking in and she gets
        a conflict:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
      </pre><p>At this point, Subversion will <span class="emphasis"><em>not</em></span>
        allow you to commit the file <tt class="filename">sandwich.txt</tt>
        until the three temporary files are removed.</p><pre class="screen">
$ svn commit --message "Add a few more things"
svn: A conflict in the working copy obstructs the current operation
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict.
      </pre><p>If you get a conflict, you need to do one of three
        things:</p><div class="itemizedlist"><ul type="disc"><li><p>Merge the conflicted text &#8220;<span class="quote">by hand</span>&#8221; (by
              examining and editing the conflict markers within the
              file).
            </p></li><li><p>Copy one of the temporary files on top of your
        working file.
            </p></li><li><p>Run <span><b class="command">svn revert &lt;filename&gt;</b></span>
              to throw away all of your local changes.</p></li></ul></div><p>Once you've resolved the conflict, you need to let
        Subversion know by running <span><b class="command">svn resolved</b></span>.
        This removes the three temporary files and Subversion no
        longer considers the file to be in a state of
        conflict.<sup>[<a name="id2888293" href="#ftn.id2888293">4</a>]</sup></p><pre class="screen">
$ svn resolved sandwich.txt
Resolved conflicted state of sandwich.txt
      </pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.4.1"></a>Merging Conflicts by Hand</h4></div></div><div></div></div><p>Merging conflicts by hand can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</p><p>Here's an example.  Let's say that, due to a
          miscommunication between you and your collaborator, Sally,
          both edit the file named <tt class="filename">sandwich.txt</tt>
          at the same time.  Sally commits her changes, and when you
          go to update your working copy, you get a conflict and we're
          going to have to edit <tt class="filename">sandwich.txt</tt> to
          resolve the conflicts.  First, let's take a look at the
          file:</p><pre class="screen">
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
        </pre><p>The strings of less-than signs, equal signs, and
          greater-than signs are called <i class="firstterm">conflict
          markers</i>.  The text between the first two sets of
          markers is composed of the changes you made in the
          conflicting area:</p><pre class="screen">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
        </pre><p>Whereas the text between the second and third sets of
        conflict markers is the text from Sally's commit:</p><pre class="screen">
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
        </pre><p>Usually you won't want to just delete the conflict
        markers and Sally's changes&#8212;she's going to be awfully
        surprised when the sandwich arrives and it's not what she
        wanted.  So this is where you pick up the phone or walk across
        the office and explain to Sally that you can't get sauerkraut
        from an Italian deli.<sup>[<a name="id2888069" href="#ftn.id2888069">5</a>]</sup>  Once you've agreed on the changes you
        will check in, edit your file and remove the conflict markers.</p><pre class="screen">
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
        </pre><p>Now run <span><b class="command">svn resolved</b></span> and you're now
          ready to commit your changes:</p><pre class="screen">
$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
        </pre><p>Remember, if you ever get confused while editing the
          conflicted file, you can always consult the three files that
          Subversion creates for you in your working
          copy&#8212;including your file as it was before you
          updated.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.4.2"></a>Copying a File Onto Your Working File</h4></div></div><div></div></div><p>If you get a conflict and decide that you want to throw
          out your changes, you can merely copy one of the temporary
          files created by Subversion over the file in your working
          copy:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ cp sandwich.txt.r2 sandwich.txt
$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use Sally's sandwich, discarding my edits."
        </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-4.4.3"></a>Punting: Using <span><b class="command">svn revert</b></span></h4></div></div><div></div></div><p>If you get a conflict, and upon examination decide that
        you want to throw out your changes and start your edits again,
        just revert your changes:</p><pre class="screen">
$ svn revert sandwich.txt
Reverted sandwich.txt
$ ls sandwich.*
sandwich.txt
        </pre><p>Note that when you revert a conflicted file, you don't
        have to run <span><b class="command">svn resolved</b></span>.</p></div><p>Now you're ready to check in your changes.  Note that
        <span><b class="command">svn resolved</b></span>, unlike most of the other
        commands we've dealt with in this chapter, requires an
        argument.  In any case, you want to be careful and only run
        <span><b class="command">svn resolved</b></span> when you're certain that you've
        fixed the conflict in your file&#8212;once the temporary files
        are removed, Subversion will let you commit the file even if
        it still contains conflict markers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-4.5"></a>Commit Your Changes</h3></div></div><div></div></div><p>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</p><p>The <span><b class="command">svn commit</b></span> command sends all of
           your changes to the repository.  When you commit a change,
           you need to supply a <i class="firstterm">log message</i>,
           describing your change.  Your log message will be attached
           to the new revision you create.  If your log message is
           brief, you may wish to supply it on the command line using
           the <tt class="option">--message</tt> (or
           <tt class="option">-m</tt>) option:</p><pre class="screen">
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
      </pre><p>However, if you've been composing your log message as you
        work, you may want to tell Subversion to get the message from
        a file by passing the filename with the
        <tt class="option">--file</tt> switch:</p><pre class="screen">
svn commit --file logmsg 
Sending        sandwich
Transmitting file data .
Committed revision 4.
      </pre><p>If you fail to specify either the
        <tt class="option">--message</tt> or <tt class="option">--file</tt> switch,
        then Subversion will automatically launch your favorite editor
        (as defined in the environment variable
        <tt class="literal">$EDITOR</tt>) for composing a log
        message.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete the text and save
          again.</p><pre class="screen">
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
a)bort, c)ontinue, e)dit
a
$
        </pre></div><p>The repository doesn't know or care if your changes make
        any sense as a whole; it only checks to make sure that nobody
        else has changed any of the same files that you did when you
        weren't looking.  If somebody <span class="emphasis"><em>has</em></span> done
        that, the entire commit will fail with a message informing you
        that one or more of your files is out-of-date:</p><pre class="screen">
$ svn commit --message "Add another rule"
Sending        rules.txt
svn: Transaction is out of date
svn: Commit failed (details follow):
svn: out of date: `rules.txt' in txn `g'
$
</pre><p>At this point, you need to run <span><b class="command">svn
        update</b></span>, deal with any merges or conflicts that
        result, and attempt your commit again.</p><p>That covers the basic work cycle for using Subversion.
        There are many other features in Subversion that you can use
        to manage your repository and working copy, but you can get by
        quite easily using only the commands that we've discussed so
        far in this chapter.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-6"></a>Examining History</h2></div></div><div></div></div><p>As we mentioned earlier, the repository is like a time
      machine.  It keeps a record of every change ever committed,
      and allows you to explore this history by examining previous
      versions of files and directories as well as the metadata that
      accompanies them.  With a single Subversion command, you can
      check out (or restore an existing working copy) the repository
      exactly as it was at any date or revision number in the past.
      However, sometimes you just want to <span class="emphasis"><em>peer
      into</em></span> the past instead of <span class="emphasis"><em>going
      into</em></span> the past.</p><p>There are several commands that can provide you with
      historical data from the repository:</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">svn log </b></span></span></dt><dd><p>Shows you broad information: log messages attached
              to revisions, and which paths changed in each
              revision.</p></dd><dt><span class="term"><span><b class="command">svn diff </b></span></span></dt><dd><p>Shows you the specific details of how a file changed
              over time.</p></dd><dt><span class="term"><span><b class="command">svn cat </b></span></span></dt><dd><p>This is used to retrieve any file as it existed in a
              particular revision number and display it on your
              screen.</p></dd><dt><span class="term"><span><b class="command">svn list </b></span></span></dt><dd><p>Displays the files in a directory for any given
              revision.</p></dd></dl></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.1"></a><span><b class="command">svn log</b></span></h3></div></div><div></div></div><p>To find out information about the history of a file or
        directory, use the <span><b class="command">svn log</b></span>
        command. <span><b class="command">svn log</b></span> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision, and,
        if it was provided, the log message that accompanied the
        commit.</p><pre class="screen">
$ svn log
------------------------------------------------------------------------
r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 2 lines

Initial import
------------------------------------------------------------------------
      </pre><p>Note that the log messages are printed in
        <span class="emphasis"><em>reverse chronological order</em></span> by default.
        If you wish to see a different range of revisions in a
        particular order, or just a single revision, pass the
        <tt class="option">--revision</tt> (<tt class="option">-r</tt>)
        switch:</p><pre class="screen">
$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order

$ svn log -r 19:5            # shows logs 5 through 19 in reverse order

$ svn log -r 8               # shows log for revision 8
      </pre><p>You can also examine the log history of a single file or directory.
      For example:</p><pre class="screen">
$ svn log foo.c
&#8230;
$ svn log http://foo.com/svn/trunk/code/foo.c
&#8230;
      </pre><p>These will display log messages <span class="emphasis"><em>only</em></span>
        for those revisions in which the working file (or URL)
        changed.</p><p>If you want even more information about a file or
        directory, <span><b class="command">svn log</b></span> also takes a
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) switch.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem, so in verbose mode, <span><b class="command">svn
        log</b></span> will include a list of
        <i class="firstterm">changed-paths</i> in a revision in its
        output:</p><pre class="screen">
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
U /trunk/code/foo.c
U /trunk/code/bar.h
A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
      </pre><div class="sidebar"><p class="title"><b>Why Does <span><b class="command">svn log</b></span> Give Me an Empty
          Response?</b></p><p>After working with Subversion for a bit, most users will
          come across something like this:</p><pre class="screen">
$ svn log -r 2
------------------------------------------------------------------------
$
        </pre><p>At first glance, this seems like an error, but you need
          to remember that while revisions are repository-wide,
          <span><b class="command">svn log</b></span> operates on a path in the
          repository (if you supply no path, Subversion defaults to
          <tt class="literal">"."</tt>).  As a result, if you're operating
          in a subdirectory of your working copy and attempt to log a
          revision where nothing beneath your current directory
          changed, Subversion will give you an empty log.  If you want
          to see what changed in that revision, try running the same
          command from the top directory of your working copy.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.2"></a>svn diff</h3></div></div><div></div></div><p>We've already seen <span><b class="command">svn diff</b></span>
        before&#8212;it displays file differences in unified diff
        format; it was used to show the local modifications made to
        our working copy before committing to the repository.</p><p>In fact, it turns out that there are
        <span class="emphasis"><em>three</em></span> distinct uses of <span><b class="command">svn
          diff</b></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>Examine local changes</p></li><li><p>Compare your working copy to the repository</p></li><li><p>Compare repository to repository</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.2.1"></a>Examining Local Changes</h4></div></div><div></div></div><p>As we've seen, invoking <span><b class="command">svn diff</b></span> with
          no switches will compare your working files to the cached
          &#8220;<span class="quote">pristine</span>&#8221; copies in
          the<tt class="filename">.svn</tt> area:</p><pre class="screen">
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
        </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.2.2"></a>Comparing Working Copy to Repository</h4></div></div><div></div></div><p>If a single <tt class="option">--revision</tt>
          (<tt class="option">-r</tt>) number is passed, then your
          working copy is compared to the specified revision in the
          repository.</p><pre class="screen">
$ svn diff --revision 3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
        </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.2.3"></a>Comparing Repository to Repository</h4></div></div><div></div></div><p>If two revision numbers, separated by a colon, are
          passed via <tt class="option">--revision</tt>
          (<tt class="option">-r</tt>), then the two revisions are directly
          compared.</p><pre class="screen">
$ svn diff --revision 2:3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth closed 
$
        </pre><p>Not only can you use <span><b class="command">svn diff</b></span> to
           compare files in your working copy to the repository, but
           if you supply a URL argument, you can examine the
           differences between items in the repository without even
           having a working copy.  This is especially useful if you
           wish to inspect changes in a file when you don't have a
           working copy on your local machine:</p><pre class="screen">
$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt
&#8230;
$
        </pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.3"></a><span><b class="command">svn cat</b></span></h3></div></div><div></div></div><p>If you want to examine an earlier version of a file and
        not necessarily the differences between two files, you can use
        <span><b class="command">svn cat</b></span>:</p><pre class="screen">
$ svn cat --revision 2 rules.txt 
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth closed
$
      </pre><p>You can also redirect the output directly into a
        file:</p><pre class="screen">
$ svn cat --revision 2 rules.txt &gt; rules.txt.v2
$
      </pre><p>You're probably wondering why we don't just use
        <span><b class="command">svn update --revision</b></span> to update the file to
        the older revision.  There are a few reasons why we might
        prefer to use <span><b class="command">svn cat</b></span>.</p><p>First, you may want to see the differences between two
        revisions of a file using an external diff program (perhaps a
        graphical one, or perhaps your file is in such a format that
        the output of unified diff is nonsensical).  In this case,
        you'll need to grab a copy of the old revision, redirect it to
        a file, and pass both that and the file in your working copy
        to your external diff program.</p><p>Sometimes it's easier to look at an older version of a
        file in its entirety as opposed to just the differences
        between it and another revision.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.4"></a><span><b class="command">svn list</b></span></h3></div></div><div></div></div><p>The <span><b class="command">svn list</b></span> command shows you what
        files are in a repository directory without actually
        downloading the files to your local machine:</p><pre class="screen">
$ svn list http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
      </pre><p>If you want a more detailed listing, pass the
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) flag to get
        output like this.</p><pre class="screen">
$ svn list --verbose http://svn.collab.net/repos/svn
   2755 harry          1331 Jul 28 02:07 README
   2773 sally               Jul 29 15:07 branches/
   2769 sally               Jul 29 12:07 clients/
   2698 harry               Jul 24 18:07 tags/
   2785 sally               Jul 29 19:07 trunk/
      </pre><p>The columns tell you the revision at which the file or
        directory was last modified, the user who modified it, the size
        if it is a file, the date it was last modified, and the item's
        name.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.5"></a>A Final Word on History</h3></div></div><div></div></div><p>In addition to all of the above commands, you can use
        <span><b class="command">svn update</b></span> and <span><b class="command">svn
        checkout</b></span> with the <tt class="option">--revision</tt> switch
        to take an entire working copy &#8220;<span class="quote">back in time</span>&#8221;
        <sup>[<a name="id2889593" href="#ftn.id2889593">6</a>]</sup>:</p><pre class="screen">
$ svn checkout --revision 1729 # Checks out a new working copy at r1729
&#8230;
$ svn update --revision 1729 # Updates an existing working copy to r1729
&#8230;
      </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-7"></a>Other Frequently Used Commands</h2></div></div><div></div></div><p>While not as frequently used as the commands previously
      discussed in this chapter, you will need these commands on
      occasion.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-7.1"></a><span><b class="command">svn cleanup</b></span></h3></div></div><div></div></div><p>When Subversion modifies your working copy (or any
        information within <tt class="filename">.svn</tt>), it tries to do
        so as safely as possible.  Before changing anything, it writes
        its intentions to a logfile, executes the commands in the
        logfile, then removes the logfile (this is similar in design
        to a journaled filesystem).  If a Subversion operation is
        interrupted (if you hit Control-C, or if the machine crashes,
        for example), the logfiles remain on disk.  By re-executing
        the logfiles, Subversion can complete the previously started
        operation, and your working copy can get itself back into a
        consistent state.</p><p>And this is exactly what <span><b class="command">svn cleanup</b></span>
        does: it searches your working copy and runs any leftover
        logs, removing locks in the process.  If Subversion ever tells
        you that some part of your working copy is
        &#8220;<span class="quote">locked</span>&#8221;, then this is the command that you
        should run.  Also, <span><b class="command">svn status</b></span> will display
        an <tt class="literal">L</tt> next to locked items:</p><pre class="screen">
$ svn status
  L    ./somedir
M      ./somedir/foo.c 

$ svn cleanup
$ svn status
M      ./somedir/foo.c
      </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-7.3"></a><span><b class="command">svn import</b></span></h3></div></div><div></div></div><p>The import command is a quick way to move an unversioned
        tree of files into a repository.</p><pre class="screen">
$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/fooproject
Adding  mytree/foo.c
Adding  mytree/bar.c
Adding  mytree/subdir
Adding  mytree/subdir/quux.h
Transmitting file data....
Committed revision 1.
      </pre><p>The above example places the contents of directory
        <tt class="filename">mytree</tt> under the directory
        <tt class="filename">fooproject</tt> in the repository:</p><pre class="screen">
/fooproject/foo.c
/fooproject/bar.c
/fooproject/subdir
/fooproject/subdir/quux.h
      </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-8"></a>Summary</h2></div></div><div></div></div><p>Now we've covered most of the Subversion client
          commands.  Notable exceptions are those dealing with
          branching and merging (see <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>) and
          properties (see <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a>).
          However, you may want to take a moment to skim through <a href="#svn-ch-8" title="Chapter 8. Subversion Complete Reference">Chapter 8, <i>Subversion Complete Reference</i></a> to get an idea of all the many
          different commands that Subversion has&#8212;and how you can
          use them to make your work easier.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2884940" href="#id2884940">1</a>] </sup>Well, except for the fact that every
      directory within your &#8220;<span class="quote">working copy</span>&#8221; also contains a
      <tt class="filename">.svn</tt> subdirectory.  But that's getting a
      little ahead of ourselves.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2886151" href="#id2886151">2</a>] </sup>Of course, nothing is ever totally
              deleted from the repository&#8212;just from the HEAD of
              the repository.  You can get back anything you delete by
              checking out (or updating your working copy) a revision
              earlier than the one in which you deleted it.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2887457" href="#id2887457">3</a>] </sup>Subversion uses its internal diff
          engine, which produces unified diff format, by default.  If
          you want diff output in a different format, specify an
          external diff program using <tt class="option">--diff-cmd</tt> and
          pass any flags you'd like to it using the
          <tt class="option">--extensions</tt> switch.  For example, to see
          local differences in file <tt class="filename">foo.c</tt> in
          context output format while ignoring whitespace changes, you
          might run &#8220;<span class="quote">svn diff --diff-cmd /usr/bin/diff
          --extensions '-bc' foo.c</span>&#8221;.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2888293" href="#id2888293">4</a>] </sup>You can always remove the temporary
        files yourself, but would you really want to do that when
        Subversion can do it for you?  We didn't think so.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2888069" href="#id2888069">5</a>] </sup>And if you ask them for
        it, they may very well ride you out of town on a
        rail</p></div><div class="footnote"><p><sup>[<a name="ftn.id2889593" href="#id2889593">6</a>] </sup>See?  We told you that Subversion was a time
        machine.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-4"></a>Chapter 4. Branching and Merging</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-4-sect-1">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-2">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-2.1">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.2">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.3">The Moral of the Story</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-3">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch4-sect-3.1">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect-3.2">The Repeated Merge Problem</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect-3.3">Merging an Entire Branch</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-4">Removing a Change from the Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-5">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-6">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-6.1">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-6.2">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-7">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch4-sect7.1">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch4-sect7.2">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-8">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</p><p>Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-1"></a>What's a Branch?</h2></div></div><div></div></div><p>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      'tweaked' for them, since they do things slightly
      differently.</p><p>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</p><p>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</p><p>This is the basic concept of a <i class="firstterm">branch</i>
      &#8212; namely, a line of development that exists independently of
      another line, yet still shares a common history if you look far
      enough back in time.  A branch always begins life as a copy of
      something, and moves on from there, generating its own
      history.</p><div class="figure"><a name="svn-ch4-dia1"></a><p class="title"><b>Figure 4.1. Branches of Development</b></p><div><img src="images/ch04dia1.png" alt="Branches of Development"></div></div><p>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      "mix and match" different lines of development in your daily
      work.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-2"></a>Using Branches</h2></div></div><div></div></div><p>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a "revision") in the
      repository.  If not, go back and read about revisions in  <a href="#svn-ch-2-sect-3.2" title="Revisions">the section called &#8220;Revisions&#8221;</a>.</p><p>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <tt class="filename">paint</tt> and <tt class="filename">calc.</tt>
      Notice, however, that this time somebody has created two new
      top-level directories in the repository, called
      <tt class="filename">trunk</tt> and <tt class="filename">branches</tt>.
      The projects themselves are subdirectories of
      <tt class="filename">trunk</tt>, which we'll explain later on.</p><div class="figure"><a name="svn-ch4-dia2"></a><p class="title"><b>Figure 4.2. Starting Repository Layout</b></p><div><img src="images/ch04dia2.png" alt="Starting Repository Layout"></div></div><p>As before, assume that you and Sally both have working
      copies of the <tt class="filename">/trunk/calc</tt> project.</p><p>Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to write, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project is
      always usable.  If you start committing your changes bit-by-bit,
      you'll surely break things for Sally.</p><p>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <tt class="filename">/trunk/calc</tt> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  Finally,
      when you're finished, you might find it very difficult to commit
      your changes.  Sally (or others) may have made many other
      changes in the repository that are difficult to merge into your
      working copy&#8212;especially all at once.</p><p>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.1"></a>Creating a Branch</h3></div></div><div></div></div><p>Creating a branch is very simple&#8212;you make a copy of the
        project in the repository using the <span><b class="command">svn
        copy</b></span> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <tt class="filename">/trunk/calc</tt> directory.  Where should the
        new copy live?  Wherever you wish&#8212;it's a matter of project
        policy.  Let's say that your team has a policy of creating
        branches in the <tt class="filename">/branches/calc</tt> area of
        the repository, and you want to name your branch
        "my-calc-branch".  You'll want to create a new directory,
        <tt class="filename">/branches/calc/my-calc-branch</tt>, which
        starts as a copy of <tt class="filename">/trunk/calc</tt>. </p><p>There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the root
        (<tt class="filename">/</tt>) of the repository:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos bigwc
A  bigwc/branches/
A  bigwc/branches/calc
A  bigwc/branches/paint
A  bigwc/trunk/
A  bigwc/trunk/calc
A  bigwc/trunk/calc/Makefile
A  bigwc/trunk/calc/integer.c
A  bigwc/trunk/calc/button.c
A  bigwc/trunk/paint
A  bigwc/trunk/paint/Makefile
A  bigwc/trunk/paint/canvas.c
A  bigwc/trunk/paint/brush.c
Checked out revision 340.
</pre><p>Making a copy is now simply a matter of passing two
        working-copy paths to the <span><b class="command">svn copy</b></span>
        command:</p><pre class="screen">
$ cd bigwc
$ svn copy trunk/calc branches/calc/my-calc-branch
$ svn status
A  +   branches/calc/my-calc-branch
</pre><p>In this case, the <span><b class="command">svn copy</b></span> command
        recursively copies the <tt class="filename">trunk/calc</tt>
        working directory to a new working directory,
        <tt class="filename">branches/calc/my-calc-branch</tt>.  As you
        can see from the <span><b class="command">svn status</b></span> command, the
        new directory is now scheduled for addition to the repository.
        But also notice the + sign next to the letter A.  This
        indicates that the scheduled addition is a
        <span class="emphasis"><em>copy</em></span> of something, not something new.
        When you commit your changes, Subversion will create
        <tt class="filename">/branches/calc/my-calc-branch</tt> in the
        repository by copying <tt class="filename">/trunk/calc</tt>,
        rather than resending all of the working copy data over the
        network:</p><pre class="screen">
$ svn commit -m "Creating a private branch of /trunk/calc."
Adding      branches/calc/my-calc-branch
Committed revision 341.
</pre><p>And now the easier method of creating a branch, which we
        should have told you about in first place: <span><b class="command">svn
        copy</b></span> is able to operate on two URLs.</p><pre class="screen">
$ svn copy http://svn.example.com/repos/trunk/calc \
           http://svn.example.com/repos/branches/calc/my-calc-branch \
      -m "Creating a private branch of /trunk/calc"

Committed revision 341.
</pre><p>There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <tt class="filename">/trunk/calc</tt>.  Notice that the second
        method, however, performs an <span class="emphasis"><em>immediate</em></span>
        commit.<sup>[<a name="id2895723" href="#ftn.id2895723">7</a>]</sup>
        It's an easier procedure, because it doesn't require you to
        check out a large mirror of the repository.  In fact, this
        technique doesn't even require you to have a working copy at
        all.</p><div class="figure"><a name="svn-ch4-dia3"></a><p class="title"><b>Figure 4.3. Repository With New Copy</b></p><div><img src="images/ch04dia3.png" alt="Repository With New Copy"></div></div><div class="sidebar"><p class="title"><b>Cheap Copies</b></p><p>Subversion's repository has a clever design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&#8212;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <span class="emphasis"><em>existing</em></span> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be "lazy".  That
          is, if you commit a change to one file within the copied
          directory, then only that file changes&#8212;the rest of the
          files continue to exist as links to the original files in
          the original directory.</p><p>This is why you'll often hear Subversion users talk
          about "cheap copies".  It doesn't matter how large the
          directory is&#8212;it takes a very tiny, constant amount of
          time to make a copy of it.  In fact, this feature is the
          basis of how commits work in Subversion: each revision is a
          "cheap copy" of the previous revision, with a few items
          lazily changed within.  (To read more about this, visit
          Subversion's website and read about the "bubble up" method
          in Subversion's design documents.)</p><p>The point here is that copies are cheap, both in time
          and space.  Make branches as often as you want. </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.2"></a>Working with Your Branch</h3></div></div><div></div></div><p>Now that you've created a new branch of the project, you
        can check out a new working copy to start using it:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/branches/calc/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</pre><p>There's nothing special about this working copy; it simply
        mirrors a different location of the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <tt class="filename">/trunk/calc</tt>.</p><p>Let's pretend that a week goes by, and the following
      commits happen:</p><div class="itemizedlist"><ul type="disc"><li><p>
          You make a change to
          <tt class="filename">/branches/calc/my-calc-branch/button.c</tt>,
          which creates revision 342.</p></li><li><p>
          You make a change to
          <tt class="filename">/branches/calc/my-calc-branch/integer.c</tt>,
          which creates revision 343.</p></li><li><p>
          Sally makes a change to
          <tt class="filename">/trunk/calc/integer.c</tt>, which creates
          revision 344.</p></li></ul></div><p>There are now two independent lines of development
        happening on <tt class="filename">integer.c</tt>:</p><div class="figure"><a name="svn-ch4-dia4"></a><p class="title"><b>Figure 4.4. The Branching of One File's History</b></p><div><img src="images/ch04dia4.png" alt="The Branching of One File's History"></div></div><p>Things get interesting when you look at the history of
        changes made to your copy of
        <tt class="filename">integer.c</tt>:</p><pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn log integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Notice that Subversion is tracing the history of your
      <tt class="filename">integer.c</tt> all the way back through time,
      traversing the point where it was copied.  (Remember that your
      branch was created in revision 341.)  Now look what happens when
      Sally runs the same command on her copy of the file:</p><pre class="screen">
$ pwd
/home/sally/calc

$ svn log integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Sally sees her own revision 344 change, but not the change
      you made in revision 343.  As far as Subversion is concerned,
      these two commits affected different files in different
      repository locations.  However, Subversion
      <span class="emphasis"><em>does</em></span> show that the two files share a common
      history.  Before the branch-copy was made in revision 341, they
      used to be the same file.  That's why you and Sally both see
      revisions 303 and 98.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.3"></a>The Moral of the Story</h3></div></div><div></div></div><p>There are two important lessons that you should remember
      from this section.</p><div class="orderedlist"><ol type="1"><li><p>Unlike many other version control systems,
            Subversion's branches exist as <span class="emphasis"><em>normal filesystem
            directories</em></span> in the repository, not in some
            extra dimension.</p></li><li><p>Subversion has no internal concept of a "branch"
          &#8212; only copies.  When you copy a directory, the
          resulting directory is only a "branch" because
          <span class="emphasis"><em>you</em></span> attach that meaning to it.  You may
          think of the directory differently, or treat it differently,
          but to Subversion it's just an ordinary directory that
          happens to have been created by copying.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-3"></a>Copying Changes Between Branches</h2></div></div><div></div></div><p>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <i class="firstterm">trunk</i>, or main line of
      development.</p><p>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p><p>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the "crawl in a hole" strategy is that by the time
      you're finished with your branch, it may be near-impossible to
      merge your changes back into the trunk without a huge number of
      conflicts.</p><p>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively "copy"
      changes between branches.  And when you're completely finished
      with your branch, your entire set of branch changes can be
      copied back into the trunk.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch4-sect-3.1"></a>Copying Specific Changes</h3></div></div><div></div></div><p>In the previous section, we mentioned that both you and
        Sally made changes to <tt class="filename">integer.c</tt> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <span class="emphasis"><em>before</em></span> you start working too heavily
        in the same places.</p><p>It's time to use the <span><b class="command">svn merge</b></span> command.
        This command, it turns out, is a very close cousin to the
        <span><b class="command">svn diff</b></span> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <span><b class="command">svn diff</b></span> to show you the exact
        change made by Sally in revision 344:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/trunk/calc

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</pre><p>The <span><b class="command">svn merge</b></span> is almost exactly the
        same.  Instead of printing the differences to your terminal,
        however, it applies them directly to your working copy as
        <span class="emphasis"><em>local modifications</em></span>:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/trunk/calc
U  integer.c

$ svn status
M  integer.c
</pre><p>The output of <span><b class="command">svn merge</b></span> shows that your
        copy of <tt class="filename">integer.c</tt> was patched.  It now
        contains Sally's change &#8212; it has been "copied" from the
        trunk to your working copy of your private branch, and now
        exists as a local modification.  At this point, it's up to you
        to review the local modification and make sure it works
        correctly.</p><p>In another scenario, it's possible that things may not have
        gone so well, and that <tt class="filename">integer.c</tt> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <span><b class="command">svn revert</b></span> the local change.</p><p>But assuming the you've reviewed the merged change, you can
        <span><b class="command">svn commit</b></span> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <i class="firstterm">porting</i> changes.</p><div class="sidebar"><p class="title"><b>Why Not Use Patches Instead?</b></p><p>A question may be on your mind, especially if you're a
          Unix user: why bother to use <span><b class="command">svn merge</b></span> at
          all?  Why not simply use the operating system's
          <span><b class="command">patch</b></span> command to accomplish the same job?
          For example:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/trunk/calc &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre><p>In this particular case, yes, there really is no
          difference.  But <span><b class="command">svn merge</b></span> has special
          abilities that surpass the <span><b class="command">patch</b></span> program.
          The file format used by <span><b class="command">patch</b></span> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <span><b class="command">svn diff</b></span>
          wouldn't have mentioned it at all.  <span><b class="command">svn
          diff</b></span> only outputs the limited patch-format, so
          there are some ideas it simply can't express.  <sup>[<a name="id2896533" href="#ftn.id2896533">8</a>]</sup>
          The <span><b class="command">svn merge</b></span> command, however, can express
          tree-changes by directly applying them to your working
          copy.</p></div><p>A word of warning: while <span><b class="command">svn diff</b></span> and
        <span><b class="command">svn merge</b></span> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 8 for details, or ask <span><b class="command">svn
        help</b></span>.  For example, <span><b class="command">svn merge</b></span>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</p><div class="orderedlist"><ol type="1"><li><p>You want to merge directory changes into your
            current working directory.</p></li><li><p>You want to merge the changes in a specific file into
            a file by the same name which exists in your current working 
            directory.</p></li></ol></div><p>If you are merging a directory and haven't specified a
        target path, <span><b class="command">svn merge</b></span> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <span><b class="command">svn merge</b></span> assumes the second case and tries
        to apply the changes to a local file with the same name.</p><p>If you want changes applied somewhere else, you'll
        need to say so:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/trunk/calc my-calc-branch
U   my-calc-branch/integer.c
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch4-sect-3.2"></a>The Repeated Merge Problem</h3></div></div><div></div></div><p>Merging changes sounds simple enough, but in practice it
        can become a headache.  The problem is that if you repeatedly
        merge changes from one branch to another, you may accidentally
        merge the same change <span class="emphasis"><em>twice</em></span>.  When this
        happens, sometimes things will work fine.  When patching a
        file, Subversion typically notices if the file already has the
        change, and does nothing.  But if the already-existing change
        has been modified in any way, you'll get a conflict.  Ideally,
        Subversion would automatically prevent applying changes more
        than once.</p><p>This is a problem that plagues many version control
        systems, including both CVS and Subversion.  For now, the only
        way to avoid this problem in Subversion is to carefully keep
        track of which changes have been merged, and which haven't.
        When you create a branch directory, you need to track what
        revision it was created in &#8212; make a note somewhere to
        yourself.  When you merge a revision (or range of revisions)
        into your working copy, you'll need to remember them as well.
        If you forget any of this information, you can rediscover it
        by examining the output of <span><b class="command">svn log -v
        branch-dir</b></span>.  But the point is that each subsequent
        merge needs to be carefully constructed by hand, making sure
        that previously-merged revisions aren't re-merged
        again.</p><p>Of course, Subversion has plans to solve this problem
        sometime after release 1.0.  All of this merging information
        can be tracked in property metadata (see <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a>), and thus Subversion will someday
        be able to automatically avoid repeated merges.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch4-sect-3.3"></a>Merging an Entire Branch</h3></div></div><div></div></div><p>To complete our running example, we'll move forward in
        time.  Several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bugfix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.  </p><p>So how do we use the <span><b class="command">svn merge</b></span> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that you still have your original one lying around
        (fully updated), or that you checked out a new working copy of
        <tt class="filename">/trunk/calc</tt>.</p><p>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware &#8212; this
        assumption is <span class="emphasis"><em>wrong</em></span>, and has burned many
        a new user!  Since <span><b class="command">svn merge</b></span> operates like
        <span><b class="command">svn diff</b></span>, comparing the latest trunk and 
        branch trees will <span class="emphasis"><em>not</em></span> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <span class="emphasis"><em>removal</em></span>
        of trunk changes that never happened on your branch.</p><p>To express only changes that happened on your branch, you
        need to compare the initial state of your branch to its final
        state.  Using <span><b class="command">svn log</b></span> on your branch, 
        you can see that your branch was created in revision 341.
        And the final state of your branch is simply a matter of 
        using the HEAD revision.</p><p>Here's the final merging procedure, then:</p><pre class="screen">
$ cd trunk/calc

$ svn merge -r 341:HEAD http://svn.example.com/repos/branches/calc/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

[examine the diffs, compile, test, etc.]

$ svn commit -m "Merged all my-calc-branch changes into the trunk."
&#8230;
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-4"></a>Removing a Change from the Repository</h2></div></div><div></div></div><p>A common use for <span><b class="command">svn merge</b></span> is to roll
      back a change that has already been committed.  Suppose you
      decide that the change made way back in revision 303, which
      changed <tt class="filename">integer.c</tt>, is completely wrong.
      It never should have been committed.  You can use <span><b class="command">svn
      merge</b></span> to "undo" the change in your working copy, and
      then commit the local modification to the repository.  All you
      need to do is do specify a <span class="emphasis"><em>reverse</em></span>
      difference:</p><pre class="screen">
$ svn merge -r 303:302 http://svn.example.com/trunk/calc
U  integer.c

$ svn status
M  integer.c

$ svn commit -m "Undoing change committed in r303."
Sending    integer.c
Transmitting file data .
Committed revision 350.
</pre><p>One way to think about a repository revision is as a
      specific group of changes (some version control systems call
      these <i class="firstterm">changesets</i>).  By using the
      <tt class="option">-r</tt> switch, you can ask <span><b class="command">svn
      merge</b></span> to apply a changeset, or whole range of
      changesets, to your working copy.  In our case of undoing a
      change, we're asking <span><b class="command">svn merge</b></span> to apply
      changeset #303 to our working copy
      <span class="emphasis"><em>backwards</em></span>.</p><p>Keep in mind that rolling back a change like this is just
      like any other <span><b class="command">svn merge</b></span> operation, so you
      should use <span><b class="command">svn status</b></span> and <span><b class="command">svn
      diff</b></span> to confirm that your work is in the state you
      want it to be in, and then use <span><b class="command">svn commit</b></span> to
      send the final version to the repository.  After committing,
      this particular changeset is no longer reflected in the HEAD
      revision.</p><p>Again, you may be thinking: well, that really didn't undo
      the commit, did it?  The change still exists in revision 303.
      If somebody checks out a version of the
      <tt class="filename">calc</tt> project between revisions 303 and
      349, they'll still see the bad change, right?</p><p>Yes, that's true.  When we talk about "removing" a change,
      we're really talking about "removing it from HEAD".  The
      original change still exists in the repository's history.  For
      most situations, this is good enough.  Most people are only
      interested in tracking the HEAD of a project anyway.  There are
      special cases, however, where you really might want to destroy
      all evidence of the commit.  (Perhaps somebody accidentally
      committed a confidential document.)  This isn't so easy, it
      turns out, because Subversion was deliberately designed to never
      lose information.  Revisions are immutable trees which build
      upon one another.  Removing a revision from history would cause
      a domino effect, creating chaos in all subsequent revisions and
      possibly invalidating all working copies.
      <sup>[<a name="id2897249" href="#ftn.id2897249">9</a>]</sup>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-5"></a>Switching a Working Copy</h2></div></div><div></div></div><p> The <span><b class="command">svn switch</b></span> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <tt class="filename">/trunk/calc</tt> to mirror the new branch
      location:</p><pre class="screen">
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/trunk/calc

$ svn switch http://svn.example.com/branches/calc/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/branches/calc/my-calc-branch
</pre><p>After "switching" to the branch, your working copy is no
      different than what you would get from doing a fresh checkout of
      the directory.  And it's usually more efficient to use this
      command, because often branches only differ by a small degree.
      The server sends only the minimal set of changes necessary to
      make your working copy reflect the branch directory.</p><p>The <span><b class="command">svn switch</b></span> command also takes a
      <tt class="option">--revision</tt> (<tt class="option">-r</tt>) option, so you
      need not always move your working copy to the &#8220;<span class="quote">tip</span>&#8221;
      of the branch.</p><p>Of course, most projects are more complicated than our
      <tt class="filename">calc</tt> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</p><div class="orderedlist"><ol type="1"><li><p>Copy the project's entire 'trunk' to a new
        branch directory.</p></li><li><p>Switch only <span class="emphasis"><em>part</em></span> of the trunk
          working copy to mirror the branch.</p></li></ol></div><p>In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <span><b class="command">svn switch</b></span> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal 'trunk' updates to most of their working copy,
      but the switched portions will remain immune (unless someone
      commits a change to their branch).  This feature adds a whole
      new dimension to the concept of a "mixed working copy" &#8212;
      not only can working copies contain a mixture of working
      revisions, but a mixture of repository locations as well.</p><p>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</p><p>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <span class="emphasis"><em>same</em></span> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<sup>[<a name="id2897476" href="#ftn.id2897476">10</a>]</sup></p><div class="sidebar"><p class="title"><b>Switches and Updates</b></p><p>Have you noticed that the output of <span><b class="command">svn
          switch</b></span> and <span><b class="command">svn update</b></span> look the
        same?  The switch command is actually a superset of the
        update command.</p><p>When you run <span><b class="command">svn update</b></span>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client. The only difference between <span><b class="command">svn
        switch</b></span> and <span><b class="command">svn update</b></span> is that the
        update command always compares two identical paths.</p><p>That is, if your working copy is a mirror of
        <tt class="filename">/trunk/calc</tt>, then <span><b class="command">svn
        update</b></span> will automatically compare your working copy
        of <tt class="filename">/trunk/calc</tt> to
        <tt class="filename">/trunk/calc</tt> in the HEAD revision.  If
        you're switching your working copy to a branch, then
        <span><b class="command">svn switch</b></span> will compare your working copy
        of <tt class="filename">/trunk/calc</tt> to some
        <span class="emphasis"><em>other</em></span> branch-directory in the HEAD
        revision.</p><p>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <span class="emphasis"><em>and</em></span> space.</p></div><p>Because <span><b class="command">svn switch</b></span> is essentially a
      variant of <span><b class="command">svn update</b></span>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</p><p>For example, suppose you have a working copy of
      <tt class="filename">/trunk</tt> and make a number of changes to it.
      Then you suddenly realize that you meant to make the changes to
      a branch instead.  No problem!  When you <span><b class="command">svn
      switch</b></span> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-6"></a>Tags</h2></div></div><div></div></div><p>Another common version control concept is a
      <i class="firstterm">tag</i>.  A tag is just a "snapshot" of a
      project in time.  In Subversion, this idea already seems to be
      everywhere.  Each repository revision is exactly that &#8212; a
      snapshot of the filesystem after each commit.</p><p>However, people often want to give more human-friendly names
      to tags, like "release-1.0".  And they want to make snapshots of
      smaller subdirectories of the filesystem.  After all, it's not
      so easy to remember that release-1.0 of a piece of software is a
      particular subdirectory of revision 4822.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-6.1"></a>Creating a Simple Tag</h3></div></div><div></div></div><p>Once again, <span><b class="command">svn copy</b></span> comes to the
        rescue.  If you want to create a snapshot of
        <tt class="filename">/trunk/calc</tt> exactly as it looks in the
        HEAD revision, then make a copy of it:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/trunk/calc \
           http://svn.example.com/repos/tags/calc/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</pre><p>This example assumes that a
        <tt class="filename">/tags/calc</tt> directory already exists.
        After the copy completes, the new
        <tt class="filename">release-1.0</tt> directory is forever a
        snapshot of how the project looked in the HEAD revision at the
        time you made the copy.  Of course you might want to be more
        precise about exactly which revision you copy, in case
        somebody else may have committed changes to the project when
        you weren't looking.  So if you know that revision 350 of
        <tt class="filename">/trunk/calc</tt> is exactly the snapshot you
        want, you can specify it by passing <tt class="option">-r 350</tt>
        to the <span><b class="command">svn copy</b></span> command.</p><p>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a "tag" is because <span class="emphasis"><em>humans</em></span>
        have decided to treat it that way: as long as nobody ever
        commits to the directory, it forever remains a snapshot.  If
        people start committing to it, it becomes a branch.</p><p>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is "hands off": as a matter of project policy, decide where
        your tags will live, and make sure all users know how to treat
        the directories they copy in there.  (That is, make sure they
        know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access-control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags-area (###cross-ref a
        section that demonstrates how to use these scripts?).  The
        paranoid approach, however, isn't usually necessary.  If a
        user accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-6.2"></a>Creating a Complex Tag</h3></div></div><div></div></div><p>Sometimes you may want your "snapshot" to be more
        complicated than a single directory at a single
        revision.</p><p>For example, pretend your project is much larger than our
        <tt class="filename">calc</tt> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bugfixes.
        You can accomplish this by selectively pinning files or
        directories at particular revisions (using <span><b class="command">svn update
        -r</b></span> liberally), or by switching files and directories
        to particular branches (making use of <span><b class="command">svn
        switch</b></span>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</p><p>Time to make a snapshot.  Copying one URL to another won't
        work here. In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, the <span><b class="command">svn copy</b></span> actually has four
        different uses (which you can read about in Chapter 8),
        including the ability to copy a working-copy tree to the
        repository:</p><pre class="screen">
$ ls
./    ../   my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/tags/calc/mytag

Committed revision 352.
</pre><p>Now there is a new directory in the repository,
        <tt class="filename">/tags/calc/mytag</tt>, which is an exact
        snapshot of your working copy &#8212; mixed revisions, urls,
        and all.</p><p>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <span><b class="command">svn
        diff</b></span> and sending a patchfile (which won't capture
        tree changes), you can instead use <span><b class="command">svn copy</b></span>
        to "upload" your working copy to a private area of the
        repository.  Your collaborator can then either checkout a
        verbatim copy of your working copy, or use <span><b class="command">svn
        merge</b></span> to receive your exact changes.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-7"></a>Branch Maintenance</h2></div></div><div></div></div><p>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <span class="emphasis"><em>too</em></span>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch4-sect7.1"></a>Repository Layout</h3></div></div><div></div></div><p>There are some standard, recommended ways to organize a
        repository.  Most people create a <tt class="filename">trunk</tt>
        directory to hold the "main line" of development, a
        <tt class="filename">branches</tt> directory to contain branch
        copies, and a <tt class="filename">tags</tt> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</p><pre class="screen">
/trunk
/branches
/tags
</pre><p>If a repository contains multiple projects, people often
        index their layout by branch:</p><pre class="screen">
/trunk/paint
/trunk/calc
/branches/paint
/branches/calc
/tags/paint
/tags/calc
</pre><p>&#8230;or by project:</p><pre class="screen">
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre><p>Of course, you're free to ignore these common layouts.  You
        can create any sort of variation, whatever works best for you or
        your team.  Remember that whatever you choose, it's not a
        permanent commitment.  You can reorganize your repository at any
        time.  Because branches and tags are ordinary directories, the
        <span><b class="command">svn move</b></span> command can move or rename them
        however you wish.  Switching from one layout to another is just
        a matter of issuing a series of server-side moves; if you don't
        like the way things are organized in the repository, just juggle
        the directories around.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch4-sect7.2"></a>Data Lifetimes</h3></div></div><div></div></div><p>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <tt class="filename">calc</tt> project.  After merging all of your
        changes back into <tt class="filename">/trunk/calc</tt>, there's
        no need for your private branch directory to stick around
        anymore:</p><pre class="screen">
$ svn delete http://svn.example.com/repos/branches/calc/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</pre><p>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the HEAD revision,
        no longer distracting anyone.  If you look at an earlier
        revision (by means of <span><b class="command">svn checkout -r</b></span>,
        <span><b class="command">svn switch -r</b></span>, or <span><b class="command">svn list
        -r</b></span>), you'll still be able to see your old
        branch.</p><p>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into HEAD, simply use <span><b class="command">svn
        copy -r</b></span> to copy it from the old revision:</p><pre class="screen">
$ svn copy -r 374 http://svn.example.com/repos/branches/calc/my-calc-branch \
                  http://svn.example.com/repos/branches/calc/my-calc-branch

Committed revision 376.
</pre><p>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two "main" branches running side-by-side for very long
        periods.  For example, suppose it's time to release a stable
        <tt class="filename">calc</tt> project to the public, and you know
        it's going to take a couple of months to shake bugs out of the
        software.  You don't want people to add new features to the
        project, but you don't want to tell all developers to stop
        programming either.  So instead, you create a "stable" branch
        of the software that won't change much:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/trunk/calc \
         http://svn.example.com/branches/calc/stable-1.0
         -m "Creating stable branch of calc project."

Committed revision 377.
</pre><p>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <tt class="filename">/trunk/calc</tt>, and you can declare a
        project policy that only bugfixes are to be committed to
        <tt class="filename">/branches/calc/stable-1.0</tt>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bugfixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time &#8212; that is, as long
        as you continue to support that release for customers.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-8"></a>Summary</h2></div></div><div></div></div><p>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <span><b class="command">svn copy</b></span> command.  We've shown how
      to use <span><b class="command">svn merge</b></span> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <span><b class="command">svn switch</b></span> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</p><p>Remember the Subversion mantra: branches are cheap.  So use
      them liberally!</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2895723" href="#id2895723">7</a>] </sup>Subversion does not support
        cross-repository copying.  When using URLs with <span><b class="command">svn
        copy</b></span> or <span><b class="command">svn move</b></span>, you can only
        copy items within the same repository.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2896533" href="#id2896533">8</a>] </sup>In the future, the Subversion project plans to use (or
          invent) an expanded patch format that describes
          tree-changes.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2897249" href="#id2897249">9</a>] </sup>The Subversion project has plans, however, to
        someday implement an <span><b class="command">svnadmin obliterate</b></span>
        command that would accomplish the task of permanently deleting
        information.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2897476" href="#id2897476">10</a>] </sup>You <span class="emphasis"><em>can</em></span>, however, use
      <span><b class="command">svn switch</b></span> with the
      <tt class="option">--relocate</tt> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <span><b class="command">svn switch</b></span> section in <a href="#svn-ch-8" title="Chapter 8. Subversion Complete Reference">Chapter 8, <i>Subversion Complete Reference</i></a> for more information and an example.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-5"></a>Chapter 5. Repository Administration</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-5-sect-1">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-1.1">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.2">Unversioned Properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-2">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-2.1">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-2.2">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-3">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-3.1">An Administrator's Toolkit</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.2">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.3">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.4">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.5">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-4">Networking a Repository</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-4.1">httpd, the Apache HTTP Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-4.2">svnserve, a Custom Subversion Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-4.3">Which Server to Use?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-5">Repository Permissions</a></span></dt><dt><span class="sect1"><a href="#svn-ch-5-sect-6">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-6.1">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-6.2">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-7">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems safely resolved.</p><p>In this chapter, we'll discuss how to create and configure a
      Subversion repository, and how to expose that repository for
      network accessibility.  We'll also talk about repository
      maintenance, including the use of the <span><b class="command">svnlook</b></span>
      and <span><b class="command">svnadmin</b></span> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</p><p>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <sup>[<a name="id2901382" href="#ftn.id2901382">11</a>]</sup>
      you should definitely pay attention to this chapter.</p><p>Of course, one cannot administer a repository unless one has
      a repository to administer.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-1"></a>Repository Basics</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-1.1"></a>Understanding Transactions and Revisions</h3></div></div><div></div></div><p>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</p><p>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</p><p>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or &#8220;<span class="quote">youngest</span>&#8221; tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</p><p>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</p><p>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</p><p>What does all of this have to do with repository
        administration?  The answer is simple: if you're administering
        a Subversion repository, you're going to have to examine
        revisions and transactions as part of monitoring the health of
        your repository.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-1.2"></a>Unversioned Properties</h3></div></div><div></div></div><p>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</p><p>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree&#8212;the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <tt class="literal">svn:date</tt>&#8212;a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<tt class="literal">svn:author</tt>) and a
        property to store the log message attached to that revision
        (<tt class="literal">svn:log</tt>).</p><p>Revision and transaction properties are
        <i class="firstterm">unversioned properties</i>&#8212;as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <tt class="literal">svn:log</tt> property with a new, corrected log
        message.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-2"></a>Repository Creation and Configuration</h2></div></div><div></div></div><p>Creating a Subversion repository is an incredibly simple
      task.  The <span><b class="command">svnadmin</b></span> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</p><pre class="screen">
$ svnadmin create path/to/repos
</pre><p>This creates a new repository in the directory
      <tt class="filename">path/to/repos</tt>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<tt class="filename">/</tt>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <tt class="literal">svn:date</tt>, set to the time at which
      the repository was created.</p><p>You may have noticed that the path argument to
      <span><b class="command">svnadmin</b></span> was just a regular filesystem path
      and not a URL like the <span><b class="command">svn</b></span> client program
      uses when referring to repositories.  Both
      <span><b class="command">svnadmin</b></span> and <span><b class="command">svnlook</b></span> are
      considered server-side utilities&#8212;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even "local"
      <tt class="literal">file:</tt> ones) to these two programs.</p><p>So, after you've run the <span><b class="command">svnadmin create</b></span>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</p><pre class="screen">
$ ls repos
dav/  db/  format  hooks/  locks/  README.txt
</pre><p>With the exception of the <tt class="filename">README.txt</tt> file,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</p><div class="variablelist"><dl><dt><span class="term">dav</span></dt><dd><p>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</p></dd><dt><span class="term">db</span></dt><dd><p>The main Berkeley DB environment, full of DB tables
            that comprise the data store for Subversion's filesystem
            (where all of your versioned data resides).</p></dd><dt><span class="term">format</span></dt><dd><p>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</p></dd><dt><span class="term">hooks</span></dt><dd><p>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</p></dd><dt><span class="term">locks</span></dt><dd><p>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</p></dd><dt><span class="term">README.txt</span></dt><dd><p>A file which merely informs its readers that they
            are looking at a Subversion repository.</p></dd></dl></div><p>In general, you shouldn't tamper with your repository
      &#8220;<span class="quote">by hand</span>&#8221;.  The <span><b class="command">svnadmin</b></span> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-2.1"></a>Hook Scripts</h3></div></div><div></div></div><p>A <i class="firstterm">hook</i> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</p><p>The <tt class="filename">hooks</tt> subdirectory is, by
        default, filled with templates for various repository
        hooks.</p><pre class="screen">
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</pre><p>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <tt class="filename">repos/hooks</tt> directory
        which can be executed as the name (like
        <span><b class="command">start-commit</b></span> or
        <span><b class="command">post-commit</b></span>) of the hook.</p><p>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&#8212;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <tt class="literal">.tmpl</tt> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <tt class="filename">.exe</tt> or <tt class="filename">.com</tt> for
        programs, and <tt class="filename">.bat</tt> for batch
        files.</p><p>Currently there are five true hooks implemented by the
        Subversion repository.</p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">start-commit</tt></span></dt><dd><p>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.</p></dd><dt><span class="term"><tt class="filename">pre-commit</tt></span></dt><dd><p>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and transaction is removed.</p><p>The Subversion distribution includes some access
              control scripts (located in the
              <tt class="filename">tools/hook-scripts</tt> directory of the
              Subversion source tree) that can be called from
              <span><b class="command">pre-commit</b></span> to implement fine-grained
              access control.  At this time, this is the only method
              by which administrators can implement finer-grained access
              control beyond what <tt class="filename">httpd.conf</tt>
              offers.  In a future version of Subversion, we plan to
              implement ACLs directly in the filesystem.</p></dd><dt><span class="term"><tt class="filename">post-commit</tt></span></dt><dd><p>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</p><p>The Subversion distribution includes a
              <span><b class="command">commit-email.pl</b></span> script (located in
              the <tt class="filename">tools/hook-scripts/</tt> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</p><p>Another useful tool provided by Subversion is the
              <span><b class="command">hot-backup.py</b></span> script (located in the
              <tt class="filename">tools/backup/</tt> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</p></dd><dt><span class="term"><tt class="filename">pre-revprop-change</tt></span></dt><dd><p>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <tt class="literal">svn:log</tt> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <tt class="filename">post-revprop-change</tt>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.</p><p>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and name of the property itself.</p></dd><dt><span class="term"><tt class="filename">post-revprop-change</tt></span></dt><dd><p>As mentioned earlier, this hook is the counterpart
              of <tt class="filename">pre-revprop-change</tt> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <tt class="filename">pre-revprop-change</tt> hook
              exists.  When both of these hooks are present, the
              <tt class="filename">post-revprop-change</tt> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and name of
              the property itself.</p><p>The Subversion distribution includes a
              <span><b class="command">propchange-email.pl</b></span> script (located
              in the <tt class="filename">tools/hook-scripts/</tt>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</p></dd></dl></div><p>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-2.2"></a>Berkeley DB Configuration</h3></div></div><div></div></div><p>The Berkeley DB environment has it own set of default
        configuration values for things like the number of locks
        allowed to be taken out at any given time, or the size
        cutoff for Berkeley's journaling log file, etc.
        Subversion's filesystem code additionally chooses default
        values for some of the Berkeley DB configuration options.
        However, sometimes your particular repository, with its
        unique collection of data and access patterns, might require
        a different set of configuration option values.</p><p>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        runtime overriding of many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <tt class="filename">DB_CONFIG</tt> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</p><p>The Berkeley configuration file for your repository is
        located in the <tt class="filename">db</tt> environment directory,
        at <tt class="filename">repos/db/DB_CONFIG</tt>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <tt class="filename">DB_CONFIG</tt> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <tt class="filename">DB_CONFIG</tt> won't take effect until you
        recover the database environment (using <span><b class="command">svnadmin
        recover</b></span>).</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-3"></a>Repository Maintenance</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.1"></a>An Administrator's Toolkit</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.1"></a>svnlook</h4></div></div><div></div></div><p><span><b class="command">svnlook</b></span> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository&#8212;it's a
          &#8220;<span class="quote">read-only</span>&#8221; tool.  <span><b class="command">svnlook</b></span>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <span><b class="command">pre-commit</b></span> hook) or that were just
          committed (in the case of the <span><b class="command">post-commit</b></span>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</p><p><span><b class="command">svnlook</b></span> has a straightforward
          syntax:</p><pre class="screen">
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
&#8230;
</pre><p>Nearly every one of <span><b class="command">svnlook</b></span>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <tt class="option">--revision</tt> and
          <tt class="option">--transaction</tt> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</p><p>In the absence of both the <tt class="option">--revision</tt>
          and <tt class="option">--transaction</tt> options,
          <span><b class="command">svnlook</b></span> will examine the youngest (or
          &#8220;<span class="quote">HEAD</span>&#8221;) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <tt class="filename">/path/to/repos</tt>:</p><pre class="screen">
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</pre><p>The only exception to these rules about subcommands is
          the <span><b class="command">svnlook youngest</b></span> subcommand, which
          takes no options, and simply prints out the HEAD revision
          number.</p><pre class="screen">
$ svnlook youngest /path/to/repos
19
</pre><p>Output from <span><b class="command">svnlook</b></span> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <tt class="literal">info</tt> subcommand:</p><pre class="screen">
$ svnlook info path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</pre><p>The output of the <tt class="literal">info</tt> subcommand is
          defined as:</p><div class="orderedlist"><ol type="1"><li><p>The author, followed by a newline.</p></li><li><p>The date, followed by a newline.</p></li><li><p>The number of characters in the log message,
              followed by a newline.</p></li><li><p>The log message itself, followed by a newline.</p></li></ol></div><p>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&#8212;because the log
          message can contain multiple lines and be unbounded in
          length, <span><b class="command">svnlook</b></span> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</p><p>Another common use of <span><b class="command">svnlook</b></span> is to
          actually view the contents of a revision or transaction
          tree.  Examining the output of <span><b class="command">svnlook
          tree</b></span> command, which displays the directories and
          files in the requested tree (optionally showing the
          filesystem node revision IDs for each of those paths) can be
          extremely helpful to administrators deciding on whether or
          not it is safe to remove a seemingly dead transaction.  It
          is also quite useful for Subversion developers who are
          diagnosing filesystem-related problems when they
          arise.</p><pre class="screen">
$ svnlook tree path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</pre><p><span><b class="command">svnlook</b></span> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <span><b class="command">svnlook</b></span>,
          and the output of those subcommands:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">author</tt></span></dt><dd><p>Print the tree's author.</p></dd><dt><span class="term"><tt class="literal">cat</tt></span></dt><dd><p>Print the contents of a file in the tree.</p></dd><dt><span class="term"><tt class="literal">date</tt></span></dt><dd><p>Print the tree's datestamp.</p></dd><dt><span class="term"><tt class="literal">changed</tt></span></dt><dd><p>List all files and directories that changed in the 
                tree.</p></dd><dt><span class="term"><tt class="literal">diff</tt></span></dt><dd><p>Print unified diffs of changed files.</p></dd><dt><span class="term"><tt class="literal">dirs-changed</tt></span></dt><dd><p>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</p></dd><dt><span class="term"><tt class="literal">history</tt></span></dt><dd><p>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</p></dd><dt><span class="term"><tt class="literal">info</tt></span></dt><dd><p>Print the tree's author, datestamp, log message
                character count, and log message.</p></dd><dt><span class="term"><tt class="literal">log</tt></span></dt><dd><p>Print the tree's log message.</p></dd><dt><span class="term"><tt class="literal">proplist</tt></span></dt><dd><p>Print the names and values of properties set on paths
                in the tree.</p></dd><dt><span class="term"><tt class="literal">tree</tt></span></dt><dd><p>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</p></dd><dt><span class="term"><tt class="literal">youngest</tt></span></dt><dd><p>Print the youngest revision number.</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.2"></a>svnadmin</h4></div></div><div></div></div><p>The <span><b class="command">svnadmin</b></span> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you perform several maintenance operations on those
          repositories.  The syntax of <span><b class="command">svnadmin</b></span> is
          similar to that of <span><b class="command">svnlook</b></span>:</p><pre class="screen">
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   dump
   help (?, h)
&#8230;
</pre><p>We've already mentioned <span><b class="command">svnadmin</b></span>'s
          <tt class="literal">create</tt> subcommand (see <a href="#svn-ch-5-sect-2" title="Repository Creation and Configuration">the section called &#8220;Repository Creation and Configuration&#8221;</a>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">create</tt></span></dt><dd><p>Creates a new Subversion repository.</p></dd><dt><span class="term"><tt class="literal">dump</tt></span></dt><dd><p>Dumps the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</p></dd><dt><span class="term"><tt class="literal">list-dblogs</tt></span></dt><dd><p>Lists the paths of Berkeley DB log files
                associated with the repository.  This list includes
                all logfiles&#8212;those still in use by Subversion, as
                well as those no longer in use.</p></dd><dt><span class="term"><tt class="literal">list-unused-dblogs</tt></span></dt><dd><p>Lists the paths of Berkeley DB log files
                associated with, but no longer used by, the
                repository.  You may safely remove these logfiles from
                the repository layout, possibly archiving them for use
                in the event that you ever need to perform a
                catastrophic recovery of the repository.</p></dd><dt><span class="term"><tt class="literal">load</tt></span></dt><dd><p>Loads a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <tt class="literal">dump</tt> subcommand.</p></dd><dt><span class="term"><tt class="literal">lstxns</tt></span></dt><dd><p>List the names of uncommitted Subversion
                transactions which currently exist in the repository.</p></dd><dt><span class="term"><tt class="literal">recover</tt></span></dt><dd><p>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred which prevented a process from cleanly
                shutting down its communication with the repository.</p></dd><dt><span class="term"><tt class="literal">rmtxns</tt></span></dt><dd><p>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <tt class="literal">lstxns</tt> subcommand).</p></dd><dt><span class="term"><tt class="literal">setlog</tt></span></dt><dd><p>Replace the current value of the
                <tt class="literal">svn:log</tt> (commit log message)
                property on a given revision in the repository with a
                new value.</p></dd><dt><span class="term"><tt class="literal">verify</tt></span></dt><dd><p>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.3"></a>svnshell.py</h4></div></div><div></div></div><p>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <span><b class="command">svnshell.py</b></span> Python script (located in
          <tt class="filename">tools/examples/</tt> in the source tree)
          uses Subversion's language bindings (so you have to have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</p><p>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          &#8220;<span class="quote">positioned</span>&#8221; in the root directory of the HEAD
          revision of the repository, and presented with a command
          prompt.  You can use the <tt class="literal">help</tt> command at
          any time to display a list of available commands and what
          they do.</p><pre class="screen">
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</pre><p>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&#8212;using the <tt class="literal">cd</tt> command.
          At all times, the command prompt will show you what revision
          (prefixed by <tt class="literal">rev:</tt>) or transaction
          (prefixed by <tt class="literal">txn:</tt>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <tt class="literal">setrev</tt> and
          <tt class="literal">settxn</tt> commands, respectively.  As in a
          Unix shell, you can use the <tt class="literal">ls</tt> command to
          display the contents of the current directory, and you can
          use the <tt class="literal">cat</tt> command to display the
          contents of a file.</p><div class="example"><a name="svn-ch-7-sect-3.1.3-ex-1"></a><p class="title"><b>Example 5.1. Using svnshell to Navigate the Repository</b></p><pre class="screen">
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</pre></div><p>As you can see in the previous example, multiple
          commands may be specified at a single command prompt,
          separated by a semicolon.  Also, the shell understands the
          notions of relative and absolute paths, and will properly
          handle the "<tt class="literal">.</tt>" and
          "<tt class="literal">..</tt>" special path components.</p><p>The <tt class="literal">youngest</tt> command displays the
          youngest revision.  This is useful for determining the range
          of valid revisions you can use as arguments to the
          <tt class="literal">setrev</tt> command&#8212;you are allowed to
          browse all the revisions (recalling that they are named with
          integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <span><b class="command">lstxns</b></span> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <span><b class="command">svnadmin lstxns</b></span> returns, and the same
          list that is valid for use with <span><b class="command">svnlook</b></span>'s
          <tt class="option">--transaction</tt> option.</p><p>Once you've finished using the shell, you can exit
          cleanly by using the <span><b class="command">exit</b></span> command.
          Alternatively, you can supply an end-of-file
          character&#8212;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.4"></a>Berkeley DB Utilities</h4></div></div><div></div></div><p>Currently, the Subversion repository has only one
          database back-end&#8212;Berkeley DB.  All of your filesystem's
          structure and data live in a set of tables within the
          <tt class="filename">db</tt> subdirectory of your repository.
          This subdirectory is a regular Berkeley DB environment
          directory, and can therefore be used in conjunction with any
          of Berkeley's database tools (you can see the documentation
          for these tools at SleepyCat's website, <tt class="systemitem">http://www.sleepycat.com/</tt>).  For
          day-to-day Subversion use, these tools are unnecessary,
          however, they do provide some important functionality that
          is currently not provided by Subversion itself.</p><p>For example, because Subversion uses Berkeley DB's
          logging facilities, the database first writes out a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if something goes wrong, the database system can back up to
          a previous <i class="firstterm">checkpoint</i>&#8212;a
          location in the log files known not to be corrupt&#8212;and
          replay transactions until the data is restored to a usable
          state.  This functionality is one of the main reasons why
          Berkeley DB was chosen as Subversion's initial database
          back-end.</p><p>Over time, these log files can accumulate.  That is
          actually a feature of the database system&#8212;you should
          be able to recreate your entire database using nothing but
          the log files, so these files are important for catastrophic
          database recovery.  But typically, you'll want to archive
          the log files that are no longer in use by Berkeley DB, and
          then remove them from disk to conserve space.  Berkeley DB
          provides a <span><b class="command">db_archive</b></span> utility for, among
          other things, listing the log files that are associated with
          a given database and which are no longer in use.  That way,
          you know which files to archive and remove.  The
          <span><b class="command">svnadmin</b></span> utility provides a convenient
          wrapper around this Berkeley DB tool:</p><pre class="screen">
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre><p>Subversion's own repository uses a
          <tt class="literal">post-commit</tt> hook script, which, after
          performing a &#8220;<span class="quote">hot backup</span>&#8221; of the repository,
          removes these excess logfiles.  In the Subversion source
          tree, the script
          <tt class="filename">tools/backup/hot-backup.py</tt> illustrates
          the safe way to perform a backup of a Berkeley DB database
          environment while it's being actively accessed:  recursively
          copy the entire repository directory, then re-copy the
          logfiles listed by <span><b class="command">db_archive -l</b></span>.</p><p>Generally speaking, only the truly paranoid would need
          to backup their entire repository every time a commit
          occurred.  However, assuming that a given repository has
          some other redundancy mechanism in place with relatively
          fine granularity (like per-commit emails), a hot backup of
          the database might be something that a repository
          administrator would want to include as part of a system-wide
          nightly backup.  For more repositories, archived commit
          emails alone are sufficient restoration sources, at least
          for the last few commits.  But it's your data; protect it as
          much as you'd like.</p><p>Berkeley DB also comes with a pair of utilities for
          converting the database tables to and from flat ASCII text
          files.  The <span><b class="command">db_dump</b></span> and
          <span><b class="command">db_load</b></span> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.2"></a>Repository Cleanup</h3></div></div><div></div></div><p>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <span><b class="command">svnadmin</b></span> utility provides some helpful
        functionality to assist you in performing such tasks as</p><div class="itemizedlist"><ul type="disc"><li><p>modifying commit log messages,</p></li><li><p>removing dead transactions,</p></li><li><p>recovering &#8220;<span class="quote">wedged</span>&#8221; repositories, and</p></li><li><p>migrating repository contents to a different
            repository.</p></li></ul></div><p>Perhaps the most commonly used of
        <span><b class="command">svnadmin</b></span>'s subcommands is
        <tt class="literal">setlog</tt>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</p><p>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <tt class="literal">pre-revprop-change</tt> and
        <tt class="literal">post-revprop-change</tt> hooks; see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>) to accept changes to this log
        message after the commit is finished, then the user can
        &#8220;<span class="quote">fix</span>&#8221; her log message remotely using the
        <span><b class="command">svn</b></span> program's <tt class="literal">propset</tt>
        command (see <a href="#svn-ch-8" title="Chapter 8. Subversion Complete Reference">Chapter 8, <i>Subversion Complete Reference</i></a>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&#8212; except by an
        administrator.</p><p>If a log message needs to be changed by an administrator,
        this can be done using <span><b class="command">svnadmin setlog</b></span>.
        This command changes the log message (the
        <tt class="literal">svn:log</tt> property) on a given revision of a
        repository, reading the new value from a provided file.</p><pre class="screen">
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</pre><div class="sidebar"><p class="title"><b>Don't Lose That Log Message!</b></p><p>Administrators should be aware that using
          <span><b class="command">svnadmin setlog</b></span> bypasses any revision
          property hook scripts that might be active for the
          repository.  Be extremely careful with this subcommand,
          ensuring that you are providing the correct revision number
          for the change.</p></div><p>Another common use of <span><b class="command">svnadmin</b></span> is to
        query the repository for outstanding&#8212;possibly
        dead&#8212;Subversion transactions.  In the event that commit
        should fail, the transaction is usually cleaned up.  That is,
        the transaction itself is removed from the repository, and any
        data associated with (and only with) that transaction is
        removed as well.  Occasionally, though, a failure occurs in
        such a way that the cleanup of the transaction never happens.
        This could happen for several reasons: perhaps the client
        operation was inelegantly terminated by the user, or a network
        failure might have occurred in the middle of an operation, etc.
        Regardless of the reason, these dead transactions serve only
        to clutter the repository and consume resources.</p><p>You can use <span><b class="command">svnadmin</b></span>'s
        <tt class="literal">lstxns</tt> command to list the names of the
        currently outstanding transactions.</p><pre class="screen">
$ svnadmin lstxns myrepos
19
3a1
a45
$
</pre><p>Each item in the resultant output can then be used with
        <span><b class="command">svnlook</b></span> (and its
        <tt class="option">--transaction</tt> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&#8212;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <span><b class="command">svnadmin rmtxns</b></span>, which will perform the
        cleanup of the transaction.  In fact, the
        <tt class="literal">rmtxns</tt> subcommand can take its input
        directly from the output of <tt class="literal">lstxns</tt>!</p><pre class="screen">
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</pre><p>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</p><div class="example"><a name="svn-ch-5-sect-3.2-ex-1"></a><p class="title"><b>Example 5.2. txn-info.sh (Reporting Outstanding Transactions)</b></p><pre class="programlisting">
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS=${1}
if [ x$REPOS = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info ${REPOS} --transaction ${TXN}
done
</pre></div><p>You can run the previous script using
        <span><b class="command">/path/to/txn-info.sh /path/to/repos</b></span>.  The
        output is basically a concatenation of several chunks of
        <span><b class="command">svnlook info</b></span> output (see <a href="#svn-ch-5-sect-3.1.1" title="svnlook">the section called &#8220;svnlook&#8221;</a>), and will look something
        like:</p><pre class="screen">
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</pre><p>Usually, if you see a dead transaction that has no log
        message attached to it, this is the result of a failed update
        (or update-like) operation.  These operations use Subversion
        transactions under the hood to mimic working copy state.
        Since they are never intended to be committed, Subversion
        doesn't require a log message for those transactions.
        Transactions that do have log messages attached are almost
        certainly failed commits of some sort.  Also, a transaction's
        datestamp can provide interesting information&#8212;for
        example, how likely is it that an operation begun nine months
        ago is still active?</p><p>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&#8212;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&#8212;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.3"></a>Repository Recovery</h3></div></div><div></div></div><p>In order to protect the data in your repository, the
        database back-end uses a locking mechanism.  This mechanism
        ensures that portions of the database are not simultaneously
        modified by multiple database accessors, and that each process
        sees the data in the correct state when that data is being
        read from the database.  When a process needs to change
        something in the database, it first checks for the existence
        of a lock on the target data.  If the data is not locked, the
        process locks the data, makes the change it wants to make, and
        then unlocks the data.  Other processes are forced to wait
        until that lock is removed before they are permitted to
        continue accessing that section of the database.</p><p>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets &#8220;<span class="quote">wedged</span>&#8221;.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&#8212;which isn't going to happen).</p><p>First, if this happens to your repository, don't panic.
        Subversion's filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <sup>[<a name="id2904960" href="#ftn.id2904960">12</a>]</sup>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</p><p>Secondly, use the following recipe to attempt to
        &#8220;<span class="quote">unwedge</span>&#8221; your repository:</p><div class="orderedlist"><ol type="1"><li><p>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</p></li><li><p>Become the user who owns and manages the repository.</p></li><li><p>Run the command <span><b class="command">svnadmin recover
            /path/to/repos</b></span>.  You should see output like
            this:</p><pre class="screen">
Acquiring exclusive lock on repository db, and running recovery procedures.
Please stand by...
Recovery completed.
The latest repos revision is 19.
</pre></li><li><p>Restart the Subversion server.</p></li></ol></div><p>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <tt class="literal">root</tt>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <tt class="literal">root</tt> will create those files such that they
        are owned by <tt class="literal">root</tt>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</p><p>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion developer list (at
        <tt class="email">&lt;<a href="mailto:dev@subversion.tigris.org">dev@subversion.tigris.org</a>&gt;</tt>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.4"></a>Migrating a Repository</h3></div></div><div></div></div><p>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <span><b class="command">svnadmin</b></span> subcommands:
        <tt class="literal">dump</tt> and <tt class="literal">load</tt>.</p><p>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  The
        recommended course of action when you are upgrading across one
        of those compatibility boundaries is a relatively simple
        process:</p><div class="orderedlist"><ol type="1"><li><p>Using your <span class="emphasis"><em>current</em></span> version of
            <span><b class="command">svnadmin</b></span>, dump your repositories to
            dump files.</p></li><li><p>Upgrade to the new version of Subversion.</p></li><li><p>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <span class="emphasis"><em>new</em></span> <span><b class="command">svnadmin</b></span>.</p></li><li><p>Again using your <span class="emphasis"><em>new</em></span>
            <span><b class="command">svnadmin</b></span>, load your dump files into
            their respective, just-created repositories.</p></li><li><p>Finally, be sure to copy any customizations from your
            old repositories to the new ones, including
            <tt class="filename">DB_CONFIG</tt> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</p></li></ol></div><p><span><b class="command">svnadmin dump</b></span> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</p><pre class="screen">
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&#8230;
* Dumped revision 25.
* Dumped revision 26.
</pre><p>At the end of the process, you will have a single file
        (<tt class="filename">dumpfile</tt> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.</p><p>The other subcommand in the pair, <span><b class="command">svnadmin
        load</b></span>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &#8230;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&#8230;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</pre><p>Note that because <span><b class="command">svnadmin</b></span> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <span><b class="command">svnadmin</b></span> on each side of the pipe):</p><pre class="screen">
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</pre><p>We mentioned previously that <span><b class="command">svnadmin
        dump</b></span> outputs a range of revisions.  Use the
        <tt class="option">--revision</tt> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</p><pre class="screen">
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</pre><p>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <span><b class="command">svnadmin dump</b></span>
        command.</p><p>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <span><b class="command">svnadmin dump</b></span> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</p><p>However, you can change this default behavior.  If you add
        the <tt class="option">--incremental</tt> option when you dump your
        repository, <span><b class="command">svnadmin</b></span> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&#8212;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</p><pre class="screen">
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</pre><p>These dump files could be loaded into a new repository with
        the following command sequence:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</pre><p>Another neat trick you can perform with this
        <tt class="option">--incremental</tt> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <tt class="literal">post-commit</tt> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script like the
        following that runs nightly to append dump file data for all
        the revisions that were added to the repository since the last
        time the script ran.</p><div class="example"><a name="svn-ch-5-sect-3.4-ex-1"></a><p class="title"><b>Example 5.3. Using Incremental Repository Dumps</b></p><pre class="programlisting">
#!/usr/bin/perl

$repos_path  = '/path/to/repos';
$dumpfile    = '/usr/backup/svn-dumpfile';
$last_dumped = '/var/log/svn-last-dumped';
 
# Figure out the starting revision (0 if we cannot read the last-dumped file,
# else use the revision in that file incremented by 1).
if (open LASTDUMPED, "$last_dumped")
{
    $new_start = &lt;LASTDUMPED&gt;;
    chomp $new_start;
    $new_start++;
    close LASTDUMPED;
}
else
{
    $new_start = 0;
}

# Query the youngest revision in the repos.
$youngest = `svnlook youngest $repos_path`;
chomp $youngest;

# Do the backup.
`svnadmin dump $repos_path --revision $new_start:$youngest --incremental &gt;&gt; $dumpfile`;

# Store a new last-dumped revision
open LASTDUMPED, "&gt; $last_dumped" or die;
print LASTDUMPED "$youngest\n";
close LASTDUMPED;

# All done!
</pre></div><p>Used like this, <span><b class="command">svnadmin</b></span>'s
        <tt class="literal">dump</tt> and <tt class="literal">load</tt> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</p><p>Finally, another possible use of the Subversion repository
        dump file format is conversion from a different storage
        mechanism or version control system altogether.  Because the
        dump file format is, for the most part, human-readable,
        <sup>[<a name="id2905644" href="#ftn.id2905644">13</a>]</sup>
        it should be relatively easy to describe generic sets of
        changes&#8212;each of which should be treated as a new
        revision&#8212;using this file format.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.5"></a>Repository Backup</h3></div></div><div></div></div><p>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&#8212;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&#8212;how to make backup copies your repository
        data.</p><p>There are generally two types of backup methods available
        for Subversion repository administrators&#8212;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <span><b class="command">svnadmin dump --incremental</b></span> to
        perform an incremental backup (see <a href="#svn-ch-5-sect-3.4" title="Migrating a Repository">the section called &#8220;Migrating a Repository&#8221;</a>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</p><p>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        the Berkeley database environment).  Now, unless you
        temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a defunct backup, since someone might be currently
        writing to the database.</p><p>Fortunately, Sleepycat's Berkeley DB documents describe a
        certain order in which database files can be copied which will
        guarantee a valid backup copy.  And better still, you don't
        have to implement that algorithm yourself, because the
        Subversion development team has already done so.  The
        <span><b class="command">hot-backup.py</b></span> script is found in the
        <tt class="filename">tools/backup/</tt> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <span><b class="command">hot-backup.py</b></span> will perform the
        necessary steps for backing up your live
        repository&#8212;without requiring that you bar public
        repository access at all&#8212;and then will clean out the
        dead Berkeley logfiles from your live repository.</p><p>Even if you also have an incremental backup, you might want to run
        this program on a regular basis.  For example, you might
        consider adding <span><b class="command">hot-backup.py</b></span> to a program
        scheduler (such as <span><b class="command">crond</b></span> on Unix systems).
        Or, if you prefer fine-grained backup solutions, you could
        have your post-commit hook script call
        <span><b class="command">hot-backup.py</b></span> (see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <tt class="filename">hooks/post-commit</tt> script in your live
        repository directory:</p><pre class="programlisting">
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</pre><p>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</p><p>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</p><p>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        full repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&#8212;and
        restoration from&#8212;incremental backups takes longer, as
        each commit is effectively replayed into either the dumpfile
        or the repository.</p><p>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <sup>[<a name="id2905862" href="#ftn.id2905862">14</a>]</sup>  
        And since you can change revision properties without respect
        to chronological order&#8212;you can change any revision's
        properties at any time&#8212;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</p><p>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <sup>[<a name="id2905924" href="#ftn.id2905924">15</a>]</sup>
        it should certainly help you recover from those trying 
        times.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-4"></a>Networking a Repository</h2></div></div><div></div></div><p>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides.  But the typical Subversion setup involves a single
      server machine being accessed from clients on computers all over
      the office&#8212;or, perhaps, all over the world.</p><p>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover each of Subversion's currently available server
      mechanisms, discussing the configuration and use of each one.
      After reading this section, you should be able to decide which
      networking setup is right for your needs, and understand how to
      enable such a setup on your host computer.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-4.1"></a><span><b class="command">httpd</b></span>, the Apache HTTP Server</h3></div></div><div></div></div><p>Subversion's primary network server is the Apache HTTP
        Server (<span><b class="command">httpd</b></span>), speaking the WebDAV/deltaV
        protocol.  This protocol (an extension to HTTP 1.1; see
        <tt class="systemitem">http://www.webdav.org/</tt>)
        takes the ubiquitous HTTP protocol that is core of the World
        Wide Web, and adds writing&#8212;specifically, versioned
        writing&#8212;capabilities.  The result is a standardized,
        robust system that is conveniently packaged as part of the
        Apache 2.0 software, is supported by numerous pieces of core
        operating system and third-party products, and which doesn't
        require network administrators to open up yet another custom
        port.
        <sup>[<a name="id2906043" href="#ftn.id2906043">16</a>]</sup>
      </p><p>Much of the following discussion includes references to
        Apache configuration directives.  While some examples are
        given of the use of these directives, describing them in full
        is outside the scope of this chapter.  The Apache team
        maintains excellent documentation, publicly available on their
        website at <tt class="systemitem">http://httpd.apache.org</tt>.  For
        example, a general reference for the configuration directives
        is located at <tt class="systemitem">http://httpd.apache.org/docs-2.0/mod/directives.html</tt>.</p><p>Also, as you make changes to your Apache setup, it is
        likely that somewhere along the way a mistake will be made.
        If you are not already familiar with Apache's logging
        subsystem, you should become aware of it.  In your
        <tt class="filename">httpd.conf</tt> file are directives which
        specify the on-disk locations of the access and error logs
        generated by Apache (the <tt class="literal">CustomLog</tt> and
        <tt class="literal">ErrorLog</tt> directives, respectively).
        Subversion's mod_dav_svn uses Apache's error logging interface
        as well.  You can always browse the contents of those files
        for information that might reveal the source of a problem
        which is not clearly noticeable otherwise.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.1"></a>What You Need for HTTP-based Repository Access</h4></div></div><div></div></div><p>To network your repository over HTTP, you basically need
          four components, available in two packages.  You'll need
          Apache <span><b class="command">httpd</b></span> 2.0, the
          <span><b class="command">mod_dav</b></span> DAV module that comes with it,
          Subversion, and the <span><b class="command">mod_dav_svn</b></span>
          filesystem provider module distributed with Subversion.
          Once you have all of those components, the process of
          networking your repository is as simple as:</p><div class="itemizedlist"><ul type="disc"><li><p>getting httpd 2.0 up and running with the mod_dav
              module,</p></li><li><p>installing the mod_dav_svn plugin to mod_dav, which
              uses Subversion's libraries to access the repository,
              and</p></li><li><p>configuring your <tt class="filename">httpd.conf</tt>
              file to export (or expose) the repository.</p></li></ul></div><p>You can accomplish the first two items either by
          compiling <span><b class="command">httpd</b></span> and Subversion from
          source code, or by installing pre-built binary packages of
          them on your system.  For the most up-to-date information on
          how to compile Subversion for use with Apache HTTP Server,
          as well as how to compile and configure Apache itself for
          this purpose, see the <tt class="filename">INSTALL</tt> file in
          the top level of the Subversion source code tree.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.2"></a>Basic Apache Configuration</h4></div></div><div></div></div><p>Once you have all the necessary components installed on
          your system, all that remains is the configuration of Apache
          via its <tt class="filename">httpd.conf</tt> file.  Instruct
          Apache to load the mod_dav_svn module using the
          <tt class="literal">LoadModule</tt> directive.  This directive
          must precede any other Subversion-related configuration
          items.  If your Apache was installed using the default
          layout, your <span><b class="command">mod_dav_svn</b></span> module should
          have been installed in the <tt class="filename">modules</tt>
          subdirectory of the Apache install location (often
          <tt class="filename">/usr/local/apache2</tt>).  The
          <tt class="literal">LoadModule</tt> directive has a simple syntax,
          mapping a named module to the location of a shared library
          on disk:</p><pre class="screen">
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>Note that if <span><b class="command">mod_dav</b></span> was compiled as
          a shared object (instead of statically linked, directly to
          the <span><b class="command">httpd</b></span> binary), you'll need a similar
          <tt class="literal">LoadModule</tt> statement for it, too.</p><p>At a later location in your configuration file, you now
          need to tell Apache where you keep your Subversion
          repository (or repositories).  The
          <tt class="literal">Location</tt> directive has an XML-like
          notation, starting with an opening tag, and ending with a
          closing tag, with various other configuration directives in
          the middle.  The purpose of the <tt class="literal">Location</tt>
          directive is to instruct Apache to do something special when
          handling requests that are directed at a given URL or one of
          its children.  In the case of Subversion, you want Apache to
          simply hand off support for URLs that point at versioned
          resources to the DAV layer.  You can instruct Apache to
          delegate the handling of all URLs whose path portions (the
          part of the URL that follows the server's name and the
          optional port number) begin with
          <tt class="filename">/repos/</tt> to a DAV provider whose
          repository is located at
          <tt class="filename">/absolute/path/to/repository</tt> using the
          following <tt class="filename">httpd.conf</tt> syntax:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</pre><p>If you plan to support multiple Subversion repositories
          that will reside in the same parent directory on your local
          disk, you can use an alternative directive, the
          <tt class="literal">SVNParentPath</tt> directive, to indicate that
          common parent directory.  For example, if you know you will
          be creating multiple Subversion repositories in a directory
          <tt class="filename">/usr/local/svn</tt> that would be accessed
          via URLs like <tt class="systemitem">http://my.server.com/svn/repos1</tt>,
          <tt class="systemitem">http://my.server.com/svn/repos2</tt>,
          and so on, you could use the <tt class="filename">httpd.conf</tt>
          configuration syntax in the following example:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>Using the previous syntax, Apache will delegate the
          handling of all URLs whose path portions begin with
          <tt class="filename">/svn/</tt> to the Subversion DAV provider,
          which will then assume that any items in the directory
          specified by the <tt class="literal">SVNParentPath</tt> directive
          are actually Subversion repositories.  This is a
          particularly convenient syntax in that, unlike the use of
          the <tt class="filename">SVNPath</tt> directive, you don't have
          to restart Apache in order to create and network new
          repositories.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.3"></a>Permissions, Authentication, and Authorization</h4></div></div><div></div></div><p>At this stage, you should strongly consider the question
          of permissions.  If you've been running Apache for some time
          now as your regular web server, you probably already have a
          collection of content&#8212;web pages, scripts and such.
          These items have already been configured with a set of
          permissions that allows them to work with Apache, or more
          appropriately, that allows Apache to work with those files.
          Apache, when used as a Subversion server, will also need the
          correct permissions to read and write to your Subversion
          repository.</p><p>You will need to determine a permission system setup
          that satisfies Subversion's requirements without messing up
          any previously existing web page or script installations.
          This might mean changing the permissions on your Subversion
          repository to match those in use by other things the Apache
          serves for you, or it could mean using the
          <tt class="literal">User</tt> and <tt class="literal">Group</tt>
          directives in <tt class="filename">httpd.conf</tt> to specify
          that Apache should run as the user and group that owns your
          Subversion repository.  There is no single correct way to
          set up your permissions, and each administrator will have
          different reasons for doing things a certain way.  Just be
          aware that permission-related problems are perhaps the most
          common oversight when configuring a Subversion repository
          for use with Apache.</p><p>And while we are speaking about permissions, we should
          address how the authorization and authentication mechanisms
          provided by Apache fit into the scheme of things.  Unless
          you have some system-wide configuration of these things, the
          Subversion repositories you make available via the
          <tt class="filename">Location</tt> directives will be generally
          accessible to everyone.  In other words,</p><div class="itemizedlist"><ul type="disc"><li><p>anyone can use their Subversion client to checkout a
              working copy of a repository URL (or any of its
              subdirectories),</p></li><li><p>anyone can interactively browse the repository's
              latest revision simply by pointing their web browser to
              the repository URL, and</p></li><li><p>anyone can commit to the repository.</p></li></ul></div><p>If you want to restrict either read or write access to a
          repository as a whole, you can use Apache's built-in access
          control features.  The easiest such feature is the Basic
          authentication mechanism, which simply uses a username and
          password to verify that a user is who she says she is.
          Apache provides an <span><b class="command">htpasswd</b></span> utility for
          managing the list of acceptable usernames and passwords,
          those to whom you wish to grant special access to your
          Subversion repository.  Let's grant commit access to Sally
          and Harry.  First, we need to add them to the password
          file.</p><pre class="screen">
$ ### First time: use -c to create the file
$ htpasswd -c /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</pre><p>Next, you need to add some more
          <tt class="filename">httpd.conf</tt> directives inside your
          <tt class="literal">Location</tt> block to tell Apache what to do
          with your new password file.  The
          <tt class="literal">AuthType</tt> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <tt class="literal">Basic</tt> authentication system.
          <tt class="literal">AuthName</tt> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <tt class="literal">AuthUserFile</tt> directive to specify
          the location of the password file you created using
          <span><b class="command">htpasswd</b></span>.</p><p>After adding these three directives, your
          <tt class="literal">&lt;Location&gt;</tt> block should look
          something like this:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
</pre><p>Now, at this stage, if you were to restart Apache, any
          Subversion operations which required authentication would
          harvest a username and password from the Subversion client,
          which would either provide previously cached values for
          these things, or prompt the user for the information.  All
          that remains is to tell Apache which operations actually
          require that authentication.</p><p>You can restrict access on all repository operations by
          adding the <tt class="literal">Require valid-user</tt> directive
          to your <tt class="literal">&lt;Location&gt;</tt> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <tt class="literal">harry</tt> or
          <tt class="literal">sally</tt>, and which provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository.</p><p>Sometimes you don't need to run such a tight ship.  The
          repository at <tt class="systemitem">http://svn.collab.net/repos/svn</tt>
          which holds the Subversion source code, for example, allows
          anyone in the world to perform read-only repository tasks
          (like checking out working copies and browsing the
          repository with a web browser), but restricts all write
          operations to authenticated users.  To do this type of
          selective restriction, you can use the
          <tt class="literal">Limit</tt> and <tt class="literal">LimitExcept</tt>
          configuration directives.  Like the
          <tt class="literal">Location</tt> directive, these blocks have
          starting and ending tags, and you would nest them inside
          your <tt class="filename">&lt;Location&gt;</tt> block.</p><p>The parameters present on the <tt class="literal">Limit</tt>
          and <tt class="literal">LimitExcept</tt> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <tt class="literal">LimitExcept</tt> directive,
          passing the <tt class="literal">GET</tt>,
          <tt class="literal">PROPFIND</tt>, <tt class="literal">OPTIONS</tt>, and
          <tt class="literal">REPORT</tt> request type parameters.  Then the
          previously mentioned <tt class="literal">Require valid-user</tt>
          directive would be placed inside the
          <tt class="literal">&lt;LimitExcept&gt;</tt> block instead of just
          inside the <tt class="literal">&lt;Location&gt;</tt> block.</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</pre><p>These are only a few simple examples.  For more in-depth
          information about Apache access control, take a look at the
          <tt class="literal">Security</tt> section of the Apache
          documentation's tutorials collection at <tt class="systemitem">http://httpd.apache.org/docs-2.0/misc/tutorials.html</tt>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.4"></a>Server Names and the COPY Request</h4></div></div><div></div></div><p>Subversion makes use of the <tt class="literal">COPY</tt>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <tt class="literal">ServerName</tt> directive in
          <tt class="filename">httpd.conf</tt> to accomplish this.</p><pre class="screen">
ServerName svn.red-bean.com
</pre><p>If you are using Apache's virtual hosting support via
          the <tt class="literal">NameVirtualHost</tt> directive, you may
          need to use the <tt class="literal">ServerAlias</tt> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.5"></a>Browsing the HEAD of the Repository</h4></div></div><div></div></div><p>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a Web browser.  Your browser will
          issue a <tt class="literal">GET</tt> request for that URL, and
          based on whether that URL represents a versioned directory
          or file, mod_dav_svn will respond with a directory listing
          or with file contents.</p><p>Since the URLs do not contain any information about
          which version of the resource you wish to see, mod_dav_svn
          will always answer with the youngest version.  This
          functionality has the wonderful side-effect that you can
          pass around Subversion URLs to your peers as references to
          documents, and those URLs will always point at the latest
          manifestation of that document.  Of course, you can even use
          the URLs as hyperlinks from other web sites, too.</p><p>You generally will get more use out of URLs to versioned
          files&#8212;after all, that's where the interesting content
          tends to lie.  But you might have occasion to browse a
          Subversion directory listing, where you'll quickly note that
          the generated HTML used to display that listing is very
          basic, and certainly not intended to be aesthetically
          pleasing (or even interesting).  To enable customization of
          these directory displays, Subversion provides an XML index
          feature.  A single <tt class="literal">SVNIndexXSLT</tt> directive
          in your repository's <tt class="literal">Location</tt> block of
          <tt class="filename">httpd.conf</tt> will instruct mod_dav_svn to
          generate XML output when displaying a directory listing, and
          to reference the XSLT stylesheet of your choice:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  SVNIndexXSLT "/svnindex.xsl"
  &#8230;
&lt;/Location&gt;
</pre><p>Using the <tt class="literal">SVNIndexXSLT</tt> directive and
          a creative XSLT stylesheet, you can make your directory
          listings match the color schemes and imagery used in other
          parts of your website.  Or, if you'd prefer, you can use the
          sample stylesheets provided in the Subversion source
          distribution's <tt class="filename">tools/xslt/</tt> directory.
          Keep in mind that the path provided to the
          <tt class="literal">SVNIndexXSLT</tt> directory is actually a URL
          path&#8212;browsers need to be able to read your stylesheets
          in order to make use of them!</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.1.6"></a>Miscellaneous Apache Features</h4></div></div><div></div></div><p>Several of the features already provided by Apache in
          its role as a robust Web server can be leveraged for
          increased functionality or security in Subversion as well.
          Subversion communicates with Apache using Neon, which is a
          generic HTTP/WebDAV library with support for such mechanisms
          as SSL (the secure socket layer) and Deflate compression
          (the same algorithm used by the <span><b class="command">gzip</b></span> and
          <span><b class="command">PKZIP</b></span> programs to &#8220;<span class="quote">shrink</span>&#8221;
          files into smaller chunks of data).  You need only to
          compile support for the features you desire into Subversion
          and Apache, and properly configure the programs to use those
          features.</p><p>This means that SSL-enabled Subversion clients can
          access SSL-enabled Apache servers and perform all
          communication using an encrypted protocol, all by using
          <tt class="literal">https:</tt> URLs with their Subversion clients
          instead of <tt class="literal">http:</tt> ones.  Businesses that
          need to expose their repositories for access outside the
          company firewall should be conscious of the possibility that
          unauthorized parties could be &#8220;<span class="quote">sniffing</span>&#8221; their
          network traffic.  SSL makes that kind of unwanted attention
          less likely to result in sensitive data leaks.  Apache can
          be configured such that only SSL-enabled Subversion clients
          can communicate with the repository.</p><p>Deflate compression places a small burden on the client
          and server to compress and decompress network transmissions
          as a way to minimize the size of the actual transmission.
          In cases where network bandwidth is in short supply, this
          kind of compression can greatly increase the speed at which
          communications between server and client can be sent.  In
          extreme cases, this minimized network transmission could be
          the difference between an operation timing out or completing
          successfully.</p><p>Less interesting, but equally useful, are other features
          of the Apache and Subversion relationship, such as the
          ability to specify a custom port (instead of the default
          HTTP port 80) or a virtual domain name by which the
          Subversion repository should be accessed, or the ability to
          access the repository through a proxy.  These things are all
          supported by Neon, so Subversion gets that support for
          free.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-4.2"></a><span><b class="command">svnserve</b></span>, a Custom Subversion Server</h3></div></div><div></div></div><p>As an alternative to Apache, Subversion also provides a
        stand-alone server program, <span><b class="command">svnserve</b></span>.  This
        program is considerably more lightweight than Apache, and much
        easier to configure.  It speaks a custom protocol with
        Subversion clients over an ordinary TCP/IP connection.</p><p>There are two basic ways that <span><b class="command">svnserve</b></span>
        can be used:</p><div class="variablelist"><dl><dt><span class="term">unauthenticated (anonymous) access</span></dt><dd><p>In this scenario, a daemon
          <span><b class="command">svnserve</b></span> process runs on the server,
          listening for incoming connections.  The svn client connects
          using a custom <tt class="literal">svn://</tt> URL schema.  The
          client connection is accepted unconditionally, and the
          repository is accessed with no authenticated username.  Most
          often, administrators configure the daemon to allow
          read-only operations. </p></dd><dt><span class="term">authenticated (SSH) access</span></dt><dd><p>In this scenario, the svn client uses a
          custom <tt class="literal">svn+ssh://</tt> URL schema; this
          initiates a local Secure Shell (SSH) process which connects
          to the server and authenticates itself.  The user must have
          some sort of system account on the server for this to
          happen.  After authentication is complete, the SSH process
          launches a temporary, private <span><b class="command">svnserve</b></span>
          process on the server, running as the authenticated user.
          The server and client communicate over the encrypted ssh
          tunnel.</p></dd></dl></div><p>Note that these methods of <span><b class="command">svnserve</b></span>
        usage aren't mutually exclusive; you can easily use both
        techniques on your server at the same time.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.2.1"></a>Setting Up Anonymous TCP/IP Access</h4></div></div><div></div></div><p>When run with no options, <span><b class="command">svnserve</b></span>
          writes data to stdout and reads data from stdin, attempting
          to negotiate a session with an svn client:</p><pre class="screen">
$ svnserve
( success ( 1 1 ( ANONYMOUS ) ( ) ) ) 
</pre><p>This isn't immediately useful to anyone;
          <span><b class="command">svnserve</b></span> behaves this way so it can be run
          by the <span><b class="command">inetd</b></span> daemon.  But there are a
          couple of different ways to run <span><b class="command">svnserve</b></span>
          as a daemon.</p><p>One option is to register an <tt class="literal">svn</tt>
          service with the server machine's <span><b class="command">inetd</b></span>.
          Then, when a client attempts to connect to that machine on
          port 3690,
          <sup>[<a name="id2907957" href="#ftn.id2907957">17</a>]</sup>
          <span><b class="command">inetd</b></span> will launch a
          &#8220;<span class="quote">one-off</span>&#8221; <span><b class="command">svnserve</b></span> process
          to handle that client's request.</p><p>When configuring this type of setup, keep in mind that
          you might not want to launch the <span><b class="command">svnserve</b></span>
          process as the user <tt class="literal">root</tt> (or as any other
          user with unlimited permissions).  Depending on the
          ownership and permissions of the repositories you're
          exporting, a different&#8212;perhaps custom&#8212;user might
          be more appropriate.  For example, you might wish to create
          a new user named <tt class="literal">svn</tt>, grant that user
          exclusive rights to the Subversion repositories, and
          configure your <span><b class="command">svnserve</b></span> processes to run
          as that user.</p><p>Of course, this first method is only available on
          machines which have an <span><b class="command">inetd</b></span> (or
          <span><b class="command">inetd</b></span>-like) daemon.  This will generally
          be limited to Unix platforms.  The alternative is to run
          <span><b class="command">svnserve</b></span> as a standalone daemon.  When
          started with the <tt class="option">-d</tt> option,
          <span><b class="command">svnserve</b></span> will immediately detach from the
          current shell process, and will execute as a background
          process which runs indefinitely, again waiting for incoming
          requests on port 3690.</p><pre class="screen">
$ svnserve -d
$ # svnserve is still running, but the user is returned to the prompt 
</pre><p>When a client makes a network connection to the
          <span><b class="command">svnserve</b></span> process (running either as a
          daemon, or as a &#8220;<span class="quote">one-off</span>&#8221; handler), no
          authentication takes place.  The server process accesses the
          repository as whatever user it's running as, and if the
          client performs a commit, the new revision has no
          <tt class="literal">svn:author</tt> property at all.</p><p>Once the <span><b class="command">svnserve</b></span> program is running,
          it makes every repository on your system available to the
          network.  In other words, if a client tries to checkout
          <tt class="systemitem">svn://example.com/usr/local/repos/project</tt>,
          an <span><b class="command">svnserve</b></span> process running on
          example.com would look for a repository at the absolute path
          <tt class="filename">/usr/local/repos/project</tt>.  To increase
          security, you would pass the <tt class="option">-r</tt> option to
          <span><b class="command">svnserve</b></span>, which restricts it to exporting
          only repositories below that path:</p><pre class="screen">
$ svnserve -d -r /usr/local
&#8230;
</pre><p>Using the <tt class="option">-r</tt> option effectively
          modifies the location that the program treats as the root of
          the remote filesystem space.  Clients then use URLs that
          have that path portion removed from them, leaving much
          shorter (and much less revealing) URLs:</p><pre class="screen">
$ svn checkout svn://example.com/repos/project
&#8230;
</pre><p>Finally, to disable write access to your repositories,
          start <span><b class="command">svnserve</b></span> with the
          <tt class="option">-R</tt> option.  This will permit only read
          operations on the data in your repository.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-4.2.2"></a>Setting Up SSH Access</h4></div></div><div></div></div><p>It is generally interesting to know which user (of a
          potentially unbounded number of users) is responsible for a
          set of changes.  It's even more important to be able to
          limit repository write access to a select group of people.
          <sup>[<a name="id2908246" href="#ftn.id2908246">18</a>]</sup>
          To accomplish both of these goals, clients using
          libsvn_ra_svn can tunnel their network sessions over
          SSH.</p><p>In this scenario, each time the client attempts to
          contact the Subversion repository, a new
          <span><b class="command">svnserve</b></span> process is started on the server
          machine by a local SSH process.  There's no need to run a
          standalone <span><b class="command">svnserve</b></span> daemon&#8212;the client's
          authenticated SSH connection launches a private svnserve
          process on the server machine, running as the authenticated
          user.  (This is, in fact, the same way that CVS works when
          using its <tt class="literal">:ext:</tt> access method and SSH.)
          SSH itself requires an authenticated user, so there is no
          anonymity.  And since the access is not anonymous, the
          authenticated username is stored as the author of any
          repository changes.</p><p>A Subversion client can perform SSH tunneling by using
          the <tt class="literal">svn+ssh://</tt> schema, and specifying the
          absolute path to the repository, like so:</p><pre class="screen">
$ svn checkout svn+ssh://example.com/usr/local/repos/project
Password:
&#8230;
</pre><p>By default, the svn client will attempt to launch a
        local program named <span><b class="command">ssh</b></span>, found somewhere in
        the user's <tt class="literal">$PATH</tt>.  The name of the SSH
        program can be overridden, however, in one of two ways.  You
        can either set the <tt class="literal">SVN_SSH</tt> environment
        variable to the new name, or you can set the value of the
        <tt class="literal">ssh</tt> variable with in the
        <tt class="literal">[tunnels]</tt> section of your client's run-time
        <tt class="filename">config</tt> file.</p><p>For example, the <span><b class="command">ssh</b></span> process will use your
        current username when attempting to authenticate with the
        server machine.  You may want <span><b class="command">ssh</b></span> to use a
        different username instead.  To do this, you can either run
        the command</p><pre class="screen">
$ export SVN_SSH="ssh -l username"
</pre><p>&#8230; or you can edit your run-time
        <tt class="filename">config</tt> to contain</p><pre class="programlisting">
[tunnels]
ssh = ssh -l username
</pre><p>For more information about changing the
          <tt class="filename">config</tt> run-time configuration file, see
          <a href="#svn-ch-6-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-4.3"></a>Which Server to Use?</h3></div></div><div></div></div><p>When choosing between Apache HTTP Server and the custom
        <span><b class="command">svnserve</b></span> program, there is no single
        correct decision.  Depending on your particular requirements,
        one of the available solutions might seem more right for you.
        And in fact, these servers can run in parallel, each accessing
        your repositories in its own way, and each without hindering
        the other.  To recap the previous two sections, here's a brief
        list of the highlights of the two available Subversion
        servers&#8212;choose whatever works best for you and your
        users.</p><div class="variablelist"><dl><dt><span class="term">Apache/mod_dav_svn</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>Authentication: http basic/digest auth,
                certificates, LDAP, etc.  Apache has a large
                collection of authentication modules.  No need to
                create real system accounts for users.</p></li><li><p>Authorization: read/write access can be
                restricted per-repository (using httpd.conf
                directives), or per-directory (using
                mod_authz_svn).</p></li><li><p>No need to open a new firewall port.</p></li><li><p>Built-in (limited) repository web browsing.</p></li><li><p>Limited interoperability with other WebDAV clients.
                </p></li><li><p>Ability to use caching HTTP proxies.</p></li><li><p>Time-tested scalability&#8212;Apache is the web
                  server of choice for countless large-volume
                  corporate websites.  It takes a lickin' and keeps
                  traffickin'.</p></li><li><p>Vastly expandable: access to numerous existing
                  authentication and authorization methods,
                  encryption, compression, etc.</p></li></ul></div></dd><dt><span class="term">svnserve</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p>Authentication: only via SSH tunnel.  Users
                require system accounts.</p></li><li><p>Authorization: via shared ownership/permissions
                on repository DB files.</p></li><li><p>Significantly more lightweight than Apache, and
                  faster for most operations.</p></li><li><p>Much easier to configure and run than Apache.</p></li><li><p>Can use existing SSH security infrastructure.</p></li></ul></div></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-5"></a>Repository Permissions</h2></div></div><div></div></div><p>You've seen how a repository can be accessed in many
      different ways.  But is it possible&#8212;or safe&#8212; for
      your repository to be accessed by multiple repository access
      methods simultaneously?  The answer is yes, provided you use a
      bit of foresight.</p><p>At any given time, these processes may require read and/or
      write access to your repository:</p><div class="itemizedlist"><ul type="disc"><li><p>regular system users using a Subversion client (as
          themselves) to access the repository directly;</p></li><li><p>regular system users connecting to SSH-spawned private
          <span><b class="command">svnserve</b></span> processes (running as
          themselves) which access the repository;</p></li><li><p>an <span><b class="command">svnserve</b></span> process&#8212;either a
          daemon or one launched by
          <span><b class="command">inetd</b></span>&#8212;running as a particular fixed
          user;</p></li><li><p>an Apache <span><b class="command">httpd</b></span> process, running as a
          particular fixed user.</p></li></ul></div><p>The most common problem administrators run into is repository
      ownership and permissions.  Does every process (or user) in the
      previous list have the rights to read and write the Berkeley DB
      files?  Assuming you have a Unix-like operating system, a
      straightforward approach might be to place every potential
      repository user into a new <tt class="literal">svn</tt> group, and
      make the repository wholly owned by that group.  But even that's
      not enough, because a process may write to the database files
      using an unfriendly umask&#8212;one which prevents access by
      other users.</p><p>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <span><b class="command">svn</b></span> program into a
      wrapper script that first sets <span><b class="command">umask 002</b></span> and
      then runs the real <span><b class="command">svn</b></span> client program.  You
      can write a similar wrapper script for the
      <span><b class="command">svnserve</b></span> program, and add a <span><b class="command">umask
      002</b></span> command to Apache's own startup script,
      <tt class="filename">apachectl</tt>.</p><p>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write-access to common files are classic
      ones that are not often elegantly solved.</p><p>Fortunately, most repository administrators will never
      <span class="emphasis"><em>need</em></span> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <tt class="literal">file://</tt>
      access URLs&#8212;they can typically contact the Apache HTTP
      server or <span><b class="command">svnserve</b></span> using
      <tt class="literal">localhost</tt> for the server name in their
      <tt class="literal">http://</tt> or <tt class="literal">svn://</tt> URLs.
      And to maintain multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend you choose the server which best meets your needs
      and stick with it!</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-6"></a>Adding Projects</h2></div></div><div></div></div><p>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <span><b class="command">svn</b></span>
      client program's <tt class="literal">import</tt> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-6.1"></a>Choosing a Repository Layout</h3></div></div><div></div></div><p>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By &#8220;<span class="quote">laying out</span>&#8221;
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</p><p>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</p><p>There are benefits to using a single repository for
       multiple projects, most obviously the lack of duplicated
       maintenance.  A single repository means that there is one set
       of hook scripts, one thing to routinely backup, one thing to
       dump and load if Subversion releases an incompatible new
       version, and so on.  Also, you can easily move data between
       projects easily, and without losing any historical versioning
       information.</p><p>The downside of using a single repository is that different
       projects may have different commit mailing lists or different
       authentication and authorization requirements.  Also, remember
       that Subversion uses repository-global revision numbers.  Some
       folks don't like the fact that even though no changes have been
       made to their project lately, the youngest revision number for
       the repository keeps climbing because other projects are
       actively adding new revisions.</p><p>A middle-ground approach can be taken, too.  For example,
       projects can be grouped by how well they relate to each other.
       You might have a few repositories with a handful of projects in
       each repository.  That way, projects that are likely to want to
       share data can do so easily, and as new revisions are added to
       the repository, at least the developers know that those new
       revisions are at least remotely related to everyone who uses
       that repository.</p><p>After deciding how to organize your projects with respect
       to repositories, you'll probably want to think about directory
       hierarchies in the repositories themselves.  Because Subversion
       uses regular directory copies for branching and tagging (see
       <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>), the Subversion community
       recommends using one of two different approaches here.  Both
       approaches employ the use of directories named
       <tt class="filename">trunk</tt>, meaning the directory under which
       the main project development occurs, and
       <tt class="filename">branches</tt>, which is a directory in which to
       create various named branches of the main development line.</p><p>The first is to place each project in a subdirectory of the
       root filesystem directory, with <tt class="filename">trunk</tt> and
       <tt class="filename">branches</tt> directories immediately under
       each project directory, as demonstrated in Figure 5-1.</p><div class="figure"><a name="svn-ch5-sect5.1-dia1"></a><p class="title"><b>Figure 5.1. One Suggested Repository Layout.</b></p><div><img src="images/ch05dia1.png" alt="One Suggested Repository Layout."></div></div><p>The second is do the reverse&#8212;to have the
       <tt class="filename">trunk</tt> and <tt class="filename">branches</tt>
       directories immediately in the top level of the filesystem,
       each with subdirectories for all the projects in the
       repository, as demonstrated in Figure 5-2.</p><div class="figure"><a name="svn-ch5-sect5.1-dia2"></a><p class="title"><b>Figure 5.2. Another Suggested Repository Layout.</b></p><div><img src="images/ch05dia2.png" alt="Another Suggested Repository Layout."></div></div><p>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&#8212;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets your needs and those of the projects that live
        there.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-6.2"></a>Creating the Layout, and Importing Initial Data</h3></div></div><div></div></div><p>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <span><b class="command">svn mkdir</b></span> command (see <a href="#svn-ch-8" title="Chapter 8. Subversion Complete Reference">Chapter 8, <i>Subversion Complete Reference</i></a>) to create each directory in
        your skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <span><b class="command">svn
        import</b></span> command (see <a href="#svn-ch-3-sect-7.3" title="svn import">the section called &#8220;svn import&#8221;</a>.  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</p><pre class="screen">
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
&#8230;
$ svn import projectA file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches

Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</pre><p>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <span><b class="command">svn import</b></span>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <span><b class="command">svn add</b></span> and <span><b class="command">svn
        commit</b></span> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <span><b class="command">svn</b></span> client program, see <a href="#svn-ch-3" title="Chapter 3. Guided Tour">Chapter 3, <i>Guided Tour</i></a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-7"></a>Summary</h2></div></div><div></div></div><p>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  We've covered some of the basic Apache configuration
      steps necessary for making your repository accessible over a
      network.  And throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</p><p>All that remains is for you to decide what exciting data to
      store in your repository.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2901382" href="#id2901382">11</a>] </sup>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2904960" href="#id2904960">12</a>] </sup>e.g.: hard drive + huge electromagnet = disaster</p></div><div class="footnote"><p><sup>[<a name="ftn.id2905644" href="#id2905644">13</a>] </sup>The Subversion repository dump file format resembles
            an RFC-822 format, the same type of format used for most
            email.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2905862" href="#id2905862">14</a>] </sup><span><b class="command">svnadmin setlog</b></span>, for example,
            bypasses the hook interface altogether.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2905924" href="#id2905924">15</a>] </sup>You know&#8212;the collective term for all of her
            &#8220;<span class="quote">fickle fingers</span>&#8221;.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2906043" href="#id2906043">16</a>] </sup>They really hate doing that.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2907957" href="#id2907957">17</a>] </sup>This port number has been assigned by the Internet Assigned
            Numbers Authority (IANA).</p></div><div class="footnote"><p><sup>[<a name="ftn.id2908246" href="#id2908246">18</a>] </sup>&#8220;<span class="quote">Free-for-all</span>&#8221; mode can sometimes be,
              shall we say, a bit chaotic.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-6"></a>Chapter 6. Advanced Topics</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-6-sect-1">Runtime Configuration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-1.1">Configuration Area Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-1.2">Configuration and the Windows Registry</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-1.3">Configuration Options</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-2">Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-2.1">Why Properties?</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.2">Manipulating Properties</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.3">Special properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-3">Externals Definitions</a></span></dt><dt><span class="sect1"><a href="#svn-ch-6-sect-4">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-4.1">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.2">svn-load-dirs.pl</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>If you've been reading this book chapter by chapter, from
      start to finish, you should by now have acquired enough
      knowledge to use the Subversion client to perform the most
      common version control operations.  You understand how to
      checkout a working copy from a Subversion repository.  You are
      comfortable with submitting and receiving changes using the
      <span><b class="command">svn commit</b></span> and <span><b class="command">svn update</b></span>
      functions.  You've probably even developed a reflex which causes
      you to run the <span><b class="command">svn status</b></span> command almost
      unconsciously.  For all intents and purposes, you are ready to
      use Subversion in a typical environment.</p><p>But the Subversion feature set doesn't stop at "common
      version control operations".</p><p>This chapter highlights some of Subversion's features which
      aren't quite so regularly used.  In it, we will discuss
      Subversion's property (or &#8220;<span class="quote">metadata</span>&#8221;) support, and
      how to modify Subversion's default behaviors by tweaking its
      run-time configuration area.  We will describe how you can use
      externals definitions to instruct Subversion to pull data from
      multiple repositories.  We'll cover in detail some of the
      additional client- and server-side tools that are part of the
      Subversion distribution.</p><p>Before reading this chapter, you should be familiar with the
      basic file and directory versioning capabilities of Subversion.
      If you haven't already read about those, or if you need a
      refresher, we recommend that you check out <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a> and <a href="#svn-ch-3" title="Chapter 3. Guided Tour">Chapter 3, <i>Guided Tour</i></a>.  Once
      you've mastered the basics and consumed this chapter, you'll be
      a Subversion power-user&#8212;or we'll refund your money!
      <sup>[<a name="id2909247" href="#ftn.id2909247">19</a>]</sup>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-1"></a>Runtime Configuration Area</h2></div></div><div></div></div><p>Subversion provides many optional behaviors that can be
      controlled by the user.  Many of these options are of the kind
      that a user would wish to apply to all Subversion operations.
      So, rather than forcing users to remember command-line arguments
      for specifying these options, and to use them for each and every
      operation they perform, Subversion uses configuration files,
      segregated into a Subversion configuration area.</p><p>The Subversion <i class="firstterm">configuration area</i> is
      a two-tiered hierarchy of option names and their values.
      Usually, this boils down to a special directory which contains
      <i class="firstterm">configuration files</i> (the first tier),
      which are just text files in standard INI format (with
      &#8220;<span class="quote">sections</span>&#8221; providing the second tier).  These files
      can be easily edited using your favorite text editor (such as
      Emacs or vi), and contain directives read by the client to
      determine which of several optional behaviors the user
      prefers.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-1.1"></a>Configuration Area Layout</h3></div></div><div></div></div><p>The first time that the <span><b class="command">svn</b></span>
        command-line client is executed, it creates a per-user
        configuration area.  On Unix-like systems, this area appears
        as a directory named <tt class="filename">.subversion</tt> in the
        user's home directory.  On Win32 systems, Subversion creates a
        folder named <tt class="filename">Subversion</tt>, typically inside
        the <tt class="filename">Application Data</tt> area of the user's
        profile directory.  However, on this platform the exact
        location differs from system to system, and is dictated by the
        Windows registry.  We will refer to the per-user configuration
        area using its Unix name,
        <tt class="filename">.subversion</tt>.</p><p>In addition to the per-user configuration area, Subversion
        also recognizes the existence of a system-wide configuration
        area.  The gives system administrators the ability to
        establish defaults for all users on a given machine.  Note
        that the system-wide configuration area does not alone dictate
        mandatory policy&#8212;the settings in the per-user
        configuration area override those in the system-wide one, and
        command-line arguments supplied to <span><b class="command">svn</b></span>
        program have the final word on behavior.  On Unix-like
        platforms, the system-wide configuration area is expected to be
        the <tt class="filename">/etc/subversion</tt> directory; on Windows
        machines, it again looks for a <tt class="filename">Subversion</tt>
        directory inside the common Application Data location (again,
        as specified by the Windows Registry).  Unlike the per-user
        case, the <span><b class="command">svn</b></span> program does not attempt to
        create the system-wide configuration area.</p><p>The <tt class="filename">.subversion</tt> directory currently
        contains three files&#8212;two configuration files
        (<tt class="filename">config</tt> and
        <tt class="filename">servers</tt>), and a
        <tt class="filename">README.txt</tt> file which describes the INI
        format.  At the time of their creation, the files contain
        default values for each of the supported Subversion options,
        mostly commented out and grouped with textual descriptions
        about how the values for the key affect Subversion's behavior.
        To change a certain behavior, you need only to load the
        appropriate configuration file into a text editor, and modify
        the desired option value.  If at any time you wish to have the
        default settings restore to one or more of the configuration
        files, you can simply delete the file, and run some innocuous
        <span><b class="command">svn</b></span> command, such as <span><b class="command">svn
        --version</b></span>, and the missing file will be recreated in
        its default state.</p><p>The per-user configuration area also contains a cache of
        authentication data.  The <tt class="filename">auth</tt> directory
        holds a set of subdirectories that contain pieces of cached
        information used by Subversion's various supported
        authentication methods.  This directory is created in such a
        way that only the user herself has permission to read its
        contents.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-1.2"></a>Configuration and the Windows Registry</h3></div></div><div></div></div><p>In addition to the usual INI-based configuration area,
        Subversion clients running on Windows platforms may also use
        the Windows registry to hold the configuration data.  The
        option names and their values are the same as in the INI
        files.  The &#8220;<span class="quote">file/section</span>&#8221; hierarchy is
        preserved as well, though addressed in a slightly different
        fashion&#8212;in this schema, files and sections are just
        levels in the registry key tree.</p><p>Subversion looks for system-wide configuration values
        under the
        <tt class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</tt>
        key.  For example, the <tt class="literal">global-ignores</tt> option,
        which is in the <tt class="literal">miscellany</tt> section of the
        <tt class="filename">config</tt> file, would be found at
        <tt class="literal">HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</tt>.
        Per-user configuration values should be stored under
        <tt class="literal">HKEY_CURRENT_USER\Software\Tigris.org\Subversion</tt>.
      </p><p>Registry-based configuration options are parsed
        <span class="emphasis"><em>before</em></span> their file-based counterparts,
        so are overridden by values found in the configuration
        files.  In other words, configuration priority is granted in
        the following order on a Windows system:</p><div class="orderedlist"><ol type="1"><li><p>Command-line options</p></li><li><p>The per-user INI files</p></li><li><p>The per-user Registry values</p></li><li><p>The system-wide INI files</p></li><li><p>The system-wide Registry values</p></li></ol></div><p>Also, the Windows Registry doesn't really support the
        notion of something being &#8220;<span class="quote">commented out</span>&#8221;.
        However, Subversion will ignore any option key whose name
        begins with a hash (<tt class="literal">#</tt>) character.  This
        allows you to effectively comment out a Subversion option
        without deleting the entire key from the Registry, obviously
        simplifying the process of restoring that option.</p><p>The <span><b class="command">svn</b></span> command-line client never
        attempts to write to the Windows Registry, and will not
        attempt to create a default configuration area there.  You can
        create the keys you need using the <span><b class="command">REGEDIT</b></span>
        program.  Alternatively, you can create a
        <tt class="filename">.REG</tt> file, and then double-click on that
        file from the Explorer shell, which will cause the data to be
        merged into your registry.</p><div class="example"><a name="svn-ch-6-sect-1.2-ex-1"></a><p class="title"><b>Example 6.1. Sample Registration Entries (.REG) File.</b></p><pre class="programlisting">
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\DEFAULT]
"#http-proxy-host"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-proxy-password"=""
"#http-proxy-timeout"="0"
"#http-compression"="yes"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#store-password"="no"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#editor-cmd"="notepad"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#global-ignores"="*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#*"
</pre></div><p>The previous example shows the contents of a
        <tt class="filename">.REG</tt> file which contains some of most
        commonly used configuration options and their default values.
        Note the presence of both system-wide (for network
        proxy-related options) and per-user settings (editor programs
        and password storage, among others).  Also note that all the
        options are effectively commented out.  You need only to
        remove the hash (<tt class="literal">#</tt>) character from the
        beginning of the option names, and set the values as you
        desire.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-1.3"></a>Configuration Options</h3></div></div><div></div></div><p>In this section, we will discuss the specific
        run-time configuration options which are currently supported
        by Subversion.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-1.3.1"></a>Servers</h4></div></div><div></div></div><p>The <tt class="filename">servers</tt> file contains
          Subversion configuration options related to the network
          layers.  There are two special section names in this
          file&#8212;<tt class="literal">groups</tt> and
          <tt class="literal">global</tt>.  The <tt class="literal">groups</tt>
          section is essentially a cross-reference table.  The keys in
          this section are the names of other sections in the file;
          their values are <i class="firstterm">globs</i>&#8212;textual
          tokens which possibly contain wildcard
          characters&#8212;which are compared against the hostnames of
          the machine to which Subversion requests are sent.</p><pre class="programlisting">
[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
&#8230;

[collabnet]
&#8230;
</pre><p>When Subversion is used over a network, it attempts to
          match the name of the server it is trying to reach with a
          group name under the <tt class="literal">groups</tt> section.  If
          a match is made, Subversion then looks for a section in the
          <tt class="filename">servers</tt> file whose name is the matched
          group's name.  From that section it reads the actual network
          configuration settings.</p><p>The <tt class="literal">global</tt> section contains the
          settings which are meant for all of the servers not matched
          by one of the globs under the <tt class="literal">groups</tt>
          section.  The options available in this section are
          exactly the same as those valid for the other server
          sections in the file (except, of course, the special
          <tt class="literal">groups</tt> section), and are as
          follows:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">http-proxy-host</tt></span></dt><dd><p>This specifies the hostname of the proxy computer
                through which your HTTP-based Subversion requests must
                pass.  It defaults to an empty value, which means that
                Subversion will not attempt to route HTTP requests
                through a proxy computer, and will instead attempt to
                contact the destination machine directly.</p></dd><dt><span class="term"><tt class="literal">http-proxy-port</tt></span></dt><dd><p>This specifies the port number on the proxy host
                to use.  It defaults to an empty value.</p></dd><dt><span class="term"><tt class="literal">http-proxy-username</tt></span></dt><dd><p>This specifies the username to supply to the proxy
                machine.  It defaults to an empty value.</p></dd><dt><span class="term"><tt class="literal">http-proxy-password</tt></span></dt><dd><p>This specifies the password to supply to the proxy
                machine.  It defaults to an empty value.</p></dd><dt><span class="term"><tt class="literal">http-timeout</tt></span></dt><dd><p>This specifies the amount of time, in seconds, to
                wait for a server response.  If you experience
                problems with a slow network connection causing
                Subversion operations to timeout, you should increase
                the value of this option.  The default value is
                <tt class="literal">0</tt>, which instructs the underlying
                HTTP library, Neon, to use its default timeout
                setting.</p></dd><dt><span class="term"><tt class="literal">http-compression</tt></span></dt><dd><p>This specifies whether or not Subversion should
                attempt to compress network requests made to DAV-ready
                servers.  The default value is <tt class="literal">yes</tt>
                (though compression will only occur if that capability
                is compiled into the network layer).  Set this to
                <tt class="literal">no</tt> to disable compression, such as
                when debugging network transmissions.</p></dd><dt><span class="term"><tt class="literal">neon-debug-mask</tt></span></dt><dd><p>This is an integer mask which the underlying HTTP
                library, Neon, uses for choosing what type of
                debugging output to yield.  The default value is
                <tt class="literal">0</tt>, which will silence all debugging
                output.  For more information about how Subversion
                makes use of Neon, see <a href="#svn-ch-7" title="Chapter 7. Developer Information">Chapter 7, <i>Developer Information</i></a>.</p></dd><dt><span class="term"><tt class="literal">ssl-authorities-file</tt></span></dt><dd><p>This specifies the path of a file that contains the
                certificates of the certificate authorities (or CAs) that
                are accepted by the Subversion client when accessing the
                repository over HTTPS.</p></dd><dt><span class="term"><tt class="literal">svn-tunnel-agent</tt></span></dt><dd><p>This specifies the external agent program through
                which to tunnel SVN protocol requests.</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-1.3.2"></a>Config</h4></div></div><div></div></div><p>The <tt class="filename">config</tt> file contains the rest
          of the currently available Subversion run-time options,
          those not related to networking.  There are only a few
          options in use at this time, but they are again grouped into
          sections in expectation of future additions.</p><p>The <tt class="literal">auth</tt> section contains settings
          related to Subversion's authentication and authorization
          against the repository.  It contains:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">store-password</tt></span></dt><dd><p>This instructs Subversion to cache, or not to
                cache, passwords that are supplied by the user in
                response to server authentication challenges.  The
                default value is <tt class="literal">yes</tt>.  Set this to
                <tt class="literal">no</tt> to disable this on-disk password
                caching.  You can override this option for a single
                instance of the <span><b class="command">svn</b></span> command using
                the <tt class="option">--no-auth-cache</tt> command-line
                parameter (for those subcommands that support it).</p></dd></dl></div><p>The <tt class="literal">helpers</tt> section controls which
          external applications Subversion uses to accomplish its
          tasks.  Valid options in this section are:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">editor-cmd</tt></span></dt><dd><p>This specifies the program Subversion will use to
                query the user for a log message during a commit
                operation, such as when using <span><b class="command">svn
                commit</b></span> without either the
                <tt class="option">--message</tt> (<tt class="option">-m</tt>) or
                <tt class="option">--file</tt> (<tt class="option">-F</tt>) options.
                This program is also used with the <span><b class="command">svn
                propedit</b></span> command&#8212;a temporary file is
                populated with the current value of the property the
                user wishes to edit, and the edits take places right
                in the editor program (see <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a>).  This option's default
                value is empty.  If the option is not set, Subversion
                will fall back to checking the environment variables
                <tt class="literal">SVN_EDITOR</tt>,
                <tt class="literal">VISUAL</tt>, and
                <tt class="literal">EDITOR</tt> (in that order) for an
                editor command.</p></dd><dt><span class="term"><tt class="literal">diff-cmd</tt></span></dt><dd><p>This specifies the absolute path of a differencing
                program, used when Subversion generates
                &#8220;<span class="quote">diff</span>&#8221; output (such as when using the
                <span><b class="command">svn diff</b></span> command).  The default
                value is the path of the GNU diff utility, as
                determined by the Subversion source code build
                system.</p></dd><dt><span class="term"><tt class="literal">diff3-cmd</tt></span></dt><dd><p>This specifies the absolute path of a three-way
                differencing program.  Subversion uses this program to
                merge changes made by the user with those received
                from the repository.  The default value is the path of
                the GNU diff3 utility, as determined by the Subversion
                source code build system.</p></dd><dt><span class="term"><tt class="literal">diff3-has-program-arg</tt></span></dt><dd><p>This flag should be set to <tt class="literal">true</tt>
              if the program specified by the
              <tt class="literal">diff3-cmd</tt> option accepts a
              <tt class="option">--diff-program</tt> command-line parameter.
              Since the <tt class="literal">diff3-cmd</tt> option's default
              value is determined at compilation time, the default
              value for the <tt class="literal">diff3-has-program-arg</tt>
              is, too.</p></dd></dl></div><p>The <tt class="literal">miscellany</tt> section is where
          everything that doesn't belong elsewhere winds up.
          <sup>[<a name="id2917948" href="#ftn.id2917948">20</a>]</sup>
          In this section, you can find:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">global-ignores</tt></span></dt><dd><p>When running the <span><b class="command">svn status</b></span>
                command, Subversion lists unversioned files and
                directories along with the versioned ones, annotating
                them with a <tt class="literal">?</tt> character (see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>).  Sometimes, it can
                be annoying to see uninteresting, unversioned
                items&#8212;for example, object files that result from
                a program's compilation&#8212;in this display.  The
                <tt class="literal">global-ignores</tt> option is a list of
                whitespace-delimited globs which describe the names of
                files and directories that Subversion should not
                display unless they are versioned.  The default value
                is <tt class="literal">*.o *.lo *.la #*# .*.rej *.rej .*~ *~
                .#*</tt>.</p><p>You can override this option for a single instance
                of the <span><b class="command">svn status</b></span> command by using
                the <tt class="option">--no-ignore</tt> command-line flag.
                For information on more fine-grained control of
                ignored items, see <a href="#svn-ch-6-sect-2.3.3" title="svn:ignore">the section called &#8220;svn:ignore&#8221;</a>.</p></dd></dl></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-2"></a>Properties</h2></div></div><div></div></div><p>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.  But it
      doesn't stop there.</p><p>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <i class="firstterm">properties</i>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must be
      human-readable text.  And the best part about these properties
      is that they, too, are versioned, just like the textual contents
      of your files.  You can modify, commit, and revert property
      changes as easily as committing textual changes.  And you
      receive other people's property changes as you update your
      working copy.</p><div class="sidebar"><p class="title"><b>Other Properties in Subversion</b></p><p>Properties show up elsewhere in Subversion, too.  Just as
        files and directories may have arbitrary property names and
        values attached to them, each revision as a whole may have
        arbitrary properties attached to it.  The same constraints
        apply&#8212;human-readable, text names and anything-you-want,
        binary values&#8212;except that revision properties are not
        versioned.  See <a href="#svn-ch-5-sect-1.2" title="Unversioned Properties">the section called &#8220;Unversioned Properties&#8221;</a> for more
        information on these unversioned properties.</p></div><p>In this section, we will examine the utility&#8212;both to
      users of Subversion, and to Subversion itself&#8212;of property
      support.  You'll learn about the property-related
      <span><b class="command">svn</b></span> subcommands, and how property
      modifications affect your normal Subversion workflow.
      Hopefully, you'll be convinced that Subversion properties can
      enhance your version control experience.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-2.1"></a>Why Properties?</h3></div></div><div></div></div><p>Properties can be very useful additions to your working
        copy.  In fact, Subversion itself uses properties to house
        special information, and as a way to denote that certain
        special processing might be needed.  Likewise, you can use
        properties for your own purposes.  Of course, anything you can
        do with properties you could also do using regular versioned
        files, but consider the following example of Subversion
        property use.</p><p>Say you wish to design a website that houses many digital
        photos, and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.  You can do this with traditional files.  That is,
        you can have your <tt class="filename">image123.jpg</tt> and an
        <tt class="filename">image123-thumbnail.jpg</tt> side-by-side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, like
        <tt class="filename">thumbnails/image123.jpg</tt>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  Soon, your tree of
        files is a mess, and grows in multiples with each new photo
        added to the site.</p><p>Now consider the same setup using Subversion's file
        properties.  Imagine having a single image file,
        <tt class="filename">image123.jpg</tt>, and then properties set on
        that file named <tt class="literal">caption</tt>,
        <tt class="literal">datestamp</tt>, and even
        <tt class="literal">thumbnail</tt>.  Now your working copy directory
        looks much more manageable&#8212;in fact, it looks like there
        are nothing but image files in it.  But your automation
        scripts know better.  They know that they can use
        <span><b class="command">svn</b></span> (or better yet, they can use the
        Subversion language bindings&#8212;see <a href="#svn-ch-7-sect-2.3" title="Using Languages Other than C and C++">the section called &#8220;Using Languages Other than C and C++&#8221;</a>) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</p><p>How (and if) you use Subversion properties is up to you.
        As we mentioned, Subversion has it own uses for properties,
        which we'll discuss a little later in this chapter.  But
        first, let's discuss how to manipulate options using the
        <span><b class="command">svn</b></span> program.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-2.2"></a>Manipulating Properties</h3></div></div><div></div></div><p>The <span><b class="command">svn</b></span> command affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command-line of <span><b class="command">propset</b></span>
        subcommand.</p><pre class="screen">
$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c
property `copyright' set on 'calc/button.c'
$
</pre><p>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multi-line textual, or even binary, property value, you
        probably do not want to supply that value on the command-line.
        So the <span><b class="command">propset</b></span> subcommand takes a
        <tt class="option">--file</tt> (<tt class="option">-F</tt>) option for
        specifying the name of
        a file which contains the new property value.</p><pre class="screen">
$ svn propset license -F /path/to/LICENSE calc/button.c
property `license' set on 'calc/button.c'
$
</pre><p>In addition to the <span><b class="command">propset</b></span> command, the
        <span><b class="command">svn</b></span> program supplies the
        <span><b class="command">propedit</b></span> command.  This command uses the
        configured editor program (see <a href="#svn-ch-6-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>) to add or modify properties.
        When you run the command, <span><b class="command">svn</b></span> invokes your
        editor program on a temporary file that contains the current
        value of the property (or which is empty, if you are adding a
        new property).  Then, you just modify that value in your
        editor program until it represents the new value you wish to
        store for the property, save the temporary file, and then exit
        the editor program.  If Subversion detects that you've
        actually changed the existing value of the property, it will
        accept that as the new property value.  If you exit your
        editor without making any changes, no property modification
        will occur.</p><pre class="screen">
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property `copyright' on `calc/button.c'
$
</pre><p>We should note that, as with other <span><b class="command">svn</b></span>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done:</p><pre class="screen">
$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*
property `copyright' set on 'calc/Makefile'
property `copyright' set on 'calc/button.c'
property `copyright' set on 'calc/integer.c'
&#8230;
$
</pre><p>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <span><b class="command">svn</b></span> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <span><b class="command">svn proplist</b></span>
        command will list the names of properties which exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <span><b class="command">svn
        propget</b></span>.  This command will, given a path (or set of
        paths) and a property name, print the value of the property to
        the standard output stream.</p><pre class="screen">
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2003 Red-Bean Software
</pre><p>There's even a variation of the
        <span><b class="command">proplist</b></span> command which will list both the
        name and value of all of the properties.  Simply supply the
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) option.</p><pre class="screen">
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : ================================================================
Copyright (c) 2003 Red-Bean Software.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions 
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the recipe for Fitz's famous
red-beans-and-rice.
&#8230;
</pre><p>The last property-related subcommand is
        <span><b class="command">propdel</b></span>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <span><b class="command">propedit</b></span> or
        <span><b class="command">propset</b></span>.  For example, this command will
        <span class="emphasis"><em>not</em></span> yield the desired effect:</p><pre class="screen">
$ svn propset license '' calc/button.c
property `license' set on 'calc/button.c'
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
  license : 
$
</pre><p>You need to use the <span><b class="command">propdel</b></span> command to
        delete properties altogether.  The syntax is similar to the
        other property commands:</p><pre class="screen">
$ svn propdel license calc/button.c
property `license' deleted from ''.
$ svn proplist --verbose calc/button.c
Properties on 'calc/button.c':
  copyright : (c) 2003 Red-Bean Software
$
</pre><p>Now that you are now familiar with all of the
        property-related <span><b class="command">svn</b></span> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging&#8212;in cleanly or conflicting fashions&#8212;someone
        else's modifications into your own.</p><div class="sidebar"><p class="title"><b>Modifying Revision Properties</b></p><p>Remember those unversioned revision properties?  You can
          modify those, too, with the <span><b class="command">svn</b></span> program.
          Simply add the <tt class="option">--revprop</tt> command-line
          parameter, and specify the revision whose property you wish
          to modify.  Since revisions are global, you don't need to
          specify a path in this case as long as you are positioned in
          the working copy of the repository whose revision property
          you wish to modify.  For example, you might want to replace
          the commit log message of an existing revision.
          <sup>[<a name="id2918748" href="#ftn.id2918748">21</a>]</sup></p><pre class="screen">
$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop
property `svn:log' set on repository revision '11'
$
</pre><p>Note that the ability to modify these unversioned
          properties must be explicitly added by the repository
          administrator (see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>).
          Since the properties aren't versioned, you run the risk of
          losing information if you aren't careful with your edits.
          The repository administrator can setup methods to protect
          against this lossage, but by default, modification of
          unversioned properties is disabled.</p></div><p>And as with file contents, your property changes are local
        modifications, only made permanent when you commit them to the
        repository with <span><b class="command">svn commit</b></span>.  Your property
        changes can be easily unmade, too&#8212;the <span><b class="command">svn
        revert</b></span> command will restore your files and
        directories to their un-edited states, contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <span><b class="command">svn status</b></span> and <span><b class="command">svn diff</b></span>
        commands.</p><pre class="screen">
$ svn status calc/button.c
 M     calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Name: copyright
   + (c) 2003 Red-Bean Software

$
</pre><p>Notice how the <span><b class="command">status</b></span> subcommand
        displays <tt class="literal">M</tt> in the second column instead of
        the first.  That is because we have modified the properties on
        <tt class="filename">calc/button.c</tt>, but not modified its
        textual contents.  Had we changed both, we would have seen
        <tt class="literal">M</tt> in the first column, too (see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>).</p><div class="sidebar"><p class="title"><b>Property Conflicts</b></p><p>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned resource that clash with your own,
          Subversion will report that the resource is in a conflicted
          state.</p><pre class="screen">
% svn update calc
M  calc/Makefile.in
 C calc/button.c
Updated to revision 143.
$ 
</pre><p>Subversion will also create, in the same directory as
          the conflicted resource, a file with a
          <tt class="filename">.prej</tt> extension which contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <tt class="literal">C</tt> in the second column of <span><b class="command">svn
          status</b></span> output for that resource, and attempts to
          commit your local modifications will fail.</p><pre class="screen">
$ svn status calc
 C     calc/button.c
?      calc/button.c.prej
$ cat calc/button.c.prej 
prop `linecount': user set to '1256', but update set to '1301'.
$
</pre><p>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <span><b class="command">svn resolved</b></span> command to
          alert Subversion that you have manually resolved the
          problem.</p></div><p>You might also have noticed the non-standard way that
        Subversion currently displays property differences.  You can
        still run <span><b class="command">svn diff</b></span> and redirect the output
        to create a usable patch file.  The <span><b class="command">patch</b></span>
        program will ignore property patches&#8212;as a rule, it
        ignores any noise it can't understand.  This does
        unfortunately mean that to fully apply a patch generated by
        <span><b class="command">svn diff</b></span>, any property modifications will
        need to be applied by hand.</p><p>As you can see, the presence of property modifications has
        no outstanding effect on the typical Subversion workflow.
        Your general patterns of updating your working copy, checking
        the status of your files and directories, reporting on the
        modifications you have made, and committing those
        modifications to the repository are completely immune to the
        presence or absence of properties.  The <span><b class="command">svn</b></span>
        program has some additional subcommands for actually making
        property changes, but that is the only noticeable asymmetry.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-2.3"></a>Special properties</h3></div></div><div></div></div><p>Subversion has no particular policy regarding
        properties&#8212;you can use them for any purpose.  Subversion
        asks only that you not use property names that begin with the
        prefix <tt class="literal">svn:</tt>.  That's the namespace that its
        sets aside for its own use.  In fact, Subversion defines
        certain properties that have magical effects on the files and
        directories to which they are attached.  In this section,
        we'll untangle the mystery, and describe how these special
        properties make your life just a little easier.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.1"></a><tt class="literal">svn:executable</tt></h4></div></div><div></div></div><p>The <tt class="literal">svn:executable</tt> property is used
          to control a versioned file's filesystem-level execute
          permission bit in a semi-automated way.  This property has
          no defined values&#8212;its mere presence indicates a desire
          the execute permission bit to be kept enabled by Subversion.
          Removing this property will restore full control of the
          execute bit back to the operating system.</p><p>On many operating systems, the ability to execute a file
          as a command is governed by the presence of an execute
          permission bit.  This bit usually defaults to being
          disabled, and must be explicitly enabled by the user for
          each file that needs it.  In a working copy, new files are
          being created all the time as new versions of existing files
          are received during an update.  This means that you might
          enable the execute bit on a file, then update your working
          copy, and if that file was changed as part of the update,
          its execute bit might get disabled.  So, Subversion provides
          the <tt class="literal">svn:executable</tt> property as a way to
          keep the execute bit enabled.</p><p>This property has no effect on filesystems that have no
          concept of an executable permission bit, such as FAT32 and
          NTFS.
          <sup>[<a name="id2919168" href="#ftn.id2919168">22</a>]</sup>
          Also, although it has no defined values, Subversion will force
          its value to <tt class="literal">*</tt> when setting this property.
          Finally, this property is valid only on files, not on
          directories.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.2"></a><tt class="literal">svn:mime-type</tt></h4></div></div><div></div></div><p>The <tt class="literal">svn:mime-type</tt> property serves
          many purposes in Subversion.  Besides being a
          general-purpose storage location for a file's Multipurpose
          Internet Mail Extensions (MIME) classification, the value of
          this property determines several behavioral characteristics
          of Subversion itself.</p><p>For example, if a file's
          <tt class="literal">svn:mime-type</tt> property is set to a
          non-text MIME type (generally, something that doesn't begin
          with <tt class="literal">text/</tt>, though there are exceptions),
          Subversion will assume that the file contains
          binary&#8212;that is, not human-readable&#8212;data.  One of
          the benefits that Subversion typically provides is
          contextual, line-based merging of changes received from the
          server during an update into your working file.  But for
          files believed to contain binary data, there is no concept
          of a &#8220;<span class="quote">line</span>&#8221;.  So, for those files, Subversion
          does not attempt to perform contextual merges during
          updates.  Instead, any time you have locally modified a
          binary working copy file that is also being updated, your
          file is renamed with a <tt class="filename">.orig</tt> extension,
          and then Subversion stores a new working copy file that
          contains the changes received during the update, but not
          your own local modifications, at the original filename.
          This behavior is really for the protection of the user
          against failed attempts at performing contextual merges on
          files that simply cannot be contextually merged.</p><p>Subversion assists users by running a binary-detection
          algorithm in the <span><b class="command">svn import</b></span> and
          <span><b class="command">svn add</b></span> subcommands.  These subcommands
          use a heuristic to guess at a file's
          &#8220;<span class="quote">binary-ness</span>&#8221;, and then set the
          <tt class="literal">svn:mime-type</tt> property to
          <tt class="literal">application/octet-stream</tt> (the generic
          &#8220;<span class="quote">this is a collection of bytes</span>&#8221; MIME type) on
          any files that are deemed binary.  If Subversion guesses
          wrong, or if you wish to set the
          <tt class="literal">svn:mime-type</tt> property to something more
          accurate&#8212;perhaps <tt class="literal">image/png</tt> or
          <tt class="literal">application/x-shockwave-flash</tt>&#8212;you
          can always remove or hand-edit the property.</p><p>Finally, if the <tt class="literal">svn:mime-type</tt>
          property is set, then the Subversion Apache module will use
          its value to populate the <tt class="literal">Content-type:</tt>
          HTTP header when responding to GET request.  This gives a
          crucial clue about how to display a file when perusing
          your repository with a web browser.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.3"></a><tt class="literal">svn:ignore</tt></h4></div></div><div></div></div><p>The <tt class="literal">svn:ignore</tt> property contains a
          list of file patterns which certain Subversion operations
          will ignore.  Perhaps the most commonly used special
          property, it works in conjunction with the
          <tt class="literal">global-ignores</tt> run-time configuration
          option (see <a href="#svn-ch-6-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>) to
          filter unversioned files and directories out of commands
          like <span><b class="command">svn status</b></span>.</p><p>The rationale behind the <tt class="literal">svn:ignore</tt>
          property is easily explained.  Subversion does not assume
          that every file or subdirectory in a working copy directory
          is intended for version control.  Resources must be
          explicitly placed under Subversion's management using the
          <span><b class="command">svn add</b></span> command.  As a result, there are
          often many resources in a working copy that are not
          versioned.</p><p>Now, the <span><b class="command">svn status</b></span> command displays
          as part of its output every unversioned file or subdirectory
          in a working copy that is not already filtered out by the
          <tt class="literal">global-ignores</tt> option (or its built-in
          default value).  This is done so that users can see if
          perhaps they've forgotten to add a resource to version
          control.</p><p>But Subversion cannot possibly guess the names of
          every resource that should be ignored.  Also, quite often
          there are things that should be ignored in
          <span class="emphasis"><em>every</em></span> working copy of a particular
          repository.  To force every user of that repository to add
          patterns for those resources to their run-time configuration
          areas would be not just a burden, but has the potential to
          clash with the configuration needs of other working copies
          that the user has checked out.</p><p>The solution is to store ignore patterns that are unique
          to the resources likely to appear in a given directory with
          the directory itself.  Common examples of unversioned
          resources that are basically unique to a directory, yet
          likely to appear there, include output from program
          compilations.  Or&#8212;to use an example more appropriate
          to this book&#8212;the HTML, PDF, or PostScript files
          generated as the result of a conversion of some source
          DocBook XML files to a more legible output format.</p><div class="sidebar"><p class="title"><b>Ignore Patterns for CVS Users</b></p><p>The Subversion <tt class="literal">svn:ignore</tt> property
            is very similar in syntax and function to the CVS
            <tt class="filename">.cvsignore</tt> file.  In fact, if you are
            migrating a CVS working copy to Subversion, you can
            directly migrate the ignore patterns by the
            <tt class="filename">.cvsignore</tt> file as input file to the
            <span><b class="command">svn propset</b></span> command:</p><pre class="screen">
$ svn propset svn:ignore -F .cvsignore .
property `svn:ignore' set on '.'
$
</pre><p>There are, however, some differences in the ways that
            CVS and Subversion handle ignore patters.  The two systems
            use the ignore patterns at some different times, and there
            are slight discrepancies in what the ignore patterns apply
            to.  Also, Subversion does not recognize the use of the
            <tt class="literal">!</tt> pattern as a reset back to having no
            ignore patterns at all.</p></div><p>For this purpose, the <tt class="literal">svn:ignore</tt>
          property is the solution.  Its value is a multi-line
          collection of file patterns, one pattern per line.  The
          property is set on the directory in which your wish the
          patterns to be applied.
          <sup>[<a name="id2919648" href="#ftn.id2919648">23</a>]</sup>
          For example, say you have the following output from
          <span><b class="command">svn status</b></span>:</p><pre class="screen">
$ svn status calc
 M     calc/button.c
?      calc/calculator
?      calc/data.c
?      calc/debug_log
?      calc/debug_log.1
?      calc/debug_log.2.gz
?      calc/debug_log.3.gz
</pre><p>In this example, you have made some property
          modifications to <tt class="filename">button.c</tt>, but in your
          working copy you also have some unversioned files, in this
          case, the latest <tt class="filename">calculator</tt> program
          that you've compiled from your source code, a source file
          named <tt class="filename">data.c</tt>, and a set of debugging
          output logfiles.  Now, you know that your build system
          always results in the <tt class="filename">calculator</tt>
          program being generated.
          <sup>[<a name="id2919719" href="#ftn.id2919719">24</a>]</sup>
          And you know that your test suite always leaves those
          debugging log files lying around.  These facts are true for
          all working copies, not just your own.  And you know that
          you aren't interested in seeing those things every time you
          run <span><b class="command">svn status</b></span>.  So you use <span><b class="command">svn
          propedit svn:ignore calc</b></span> to add some ignore
          patterns to the <tt class="filename">calc</tt> directory.  For
          example, you might add this as the new value of the
          <tt class="literal">svn:ignore</tt> property:</p><pre class="programlisting">
calculator
debug_log*
</pre><p>After you've added this property, you will now have a
          local property modification on the <tt class="filename">calc</tt>
          directory.  But notice what else is different about your
          <span><b class="command">svn status</b></span> output:</p><pre class="screen">
$ svn status
 M     calc
 M     calc/button.c
?      calc/data.c
</pre><p>Now, all the cruft is missing from the output!  Of
          course, those files are still in your working copy.
          Subversion is simply not reminding you that they are present
          and unversioned.  And now with all the trivial noise removed
          from the display, you are left with more interesting
          items&#8212; such as that source code file that you probably
          forgot to add to version control.</p><p>If you want to see the ignored files, you can pass the 
          <span><b class="command">--no-ignore</b></span> option to subversion:</p><pre class="screen">
$ svn status --no-ignore
 M     calc/button.c
I      calc/calculator
?      calc/data.c
I      calc/debug_log
I      calc/debug_log.1
I      calc/debug_log.2.gz
I      calc/debug_log.3.gz
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.4"></a><tt class="literal">svn:keywords</tt></h4></div></div><div></div></div><p>Subversion has the ability to substitute
          <i class="firstterm">keywords</i>&#8212;pieces of useful,
          dynamic information about a versioned file&#8212;into the
          contents of the file itself.  Keywords generally describe
          information about the last time the file was known to be
          modified.  Because this information changes each time the
          file changes, and more importantly, just
          <span class="emphasis"><em>after</em></span> the file changes, it is a hassle
          for any process except the version control system to keep
          the data completely up-to-date.  Left to human authors, the
          information would inevitably grow stale.</p><p>For example, say you have a document in which you would
          like to display the last date on which it was modified.  You
          could burden every author of that document to, just before
          committing their changes, also tweak the part of the
          document that describes when it was last changed.  But
          sooner or later, someone would forget to do that.  Instead
          simply ask Subversion to perform keyword substitution on the
          <tt class="literal">LastChangedDate</tt> keyword.  You control
          where the keyword is inserted into your document by placing
          a <i class="firstterm">keyword anchor</i> at the desired
          location in the file.  This anchor is just a string of text
          formatted as
          <tt class="literal">$</tt><i class="replaceable"><tt>KeywordName</tt></i><tt class="literal">$</tt></p><p>Subversion defines the list of keywords available for
          substitution.  That list contains the following five
          keywords, some of which have shorter aliases that you can
          also use:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">LastChangedDate</tt></span></dt><dd><p>This keyword describes the last time the file was
                known to have been changed in the repository, and
                looks something like <tt class="literal">$LastChangedDate:
                2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002)
                $</tt>.  It may be abbreviated as
                <tt class="literal">Date</tt>.</p></dd><dt><span class="term"><tt class="literal">LastChangedRevision</tt></span></dt><dd><p>This keyword describes the last known revision in
                which this file changed in the repository, and looks
                something like <tt class="literal">$LastChangedRevision: 144
                $</tt>.  It may be abbreviated as
                <tt class="literal">Rev</tt>.</p></dd><dt><span class="term"><tt class="literal">LastChangedBy</tt></span></dt><dd><p>This keyword describes the last known user to
                change this file in the repository, and looks
                something like <tt class="literal">$LastChangedBy: harry
                $</tt>.  It may be abbreviated as
                <tt class="literal">Author</tt></p></dd><dt><span class="term"><tt class="literal">HeadURL</tt></span></dt><dd><p>This keyword describes the full URL to the latest
                version of the file in the repository, and looks
                something like <tt class="literal">$HeadURL:
                http://svn.collab.net/repos/trunk/README $</tt>.
                It may be abbreviated as
                <tt class="literal">URL</tt>.</p></dd><dt><span class="term"><tt class="literal">Id</tt></span></dt><dd><p>This keyword is compressed combination of the
                other keywords.  Its substitution looks something like
                <tt class="literal">$Id: calc.c 148 2002-07-28 21:30:43Z sally
                $</tt>, and is interpreted to mean that the file
                <tt class="filename">calc.c</tt> was last changed in revision
                148 on the evening of July 28, 2002 by the user
                <tt class="literal">sally</tt>.</p></dd></dl></div><p>Simply adding keyword anchor text to your file does
          nothing special.  Subversion will never attempt to perform
          textual substitutions on your file contents unless
          explicitly asked to do so.  After all, you might be writing
          a document
          <sup>[<a name="id2920176" href="#ftn.id2920176">25</a>]</sup> 
          about how to use keywords, and you don't want Subversion to
          substitute your beautiful examples of un-substituted keyword
          anchors!</p><p>To tell Subversion whether or not to substitute keywords
          on a particular file, we again turn to the property-related
          subcommands.  The <tt class="literal">svn:keywords</tt> property,
          when set on a versioned file, controls which keywords will
          be substituted on that file.  The value is a space-delimited
          list of the keyword names or aliases found in the previous
          table.</p><p>For example, say you have a versioned file named
          <tt class="filename">weather.txt</tt> that looks like
          this:</p><pre class="programlisting">
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>With no <tt class="literal">svn:keywords</tt> property set on
          that file, Subversion will do nothing special.  Now, let's
          enable substitution of the
          <tt class="literal">LastChangedDate</tt> keyword.</p><pre class="screen">
$ svn propset svn:keywords "LastChangedDate Author" weather.txt
property `svn:keywords' set on 'weather.txt'
$
</pre><p>Now you have made a local property modification on the
          <tt class="filename">weather.txt</tt> file.  You will see no
          changes to the file's contents (unless you made some of your
          own prior to setting the property).  Notice that the file
          contained a keyword anchor for the <tt class="literal">Rev</tt>
          keyword, yet we did not include that keyword in the property
          value we set.  Subversion will happily ignore requests to
          substitute keywords that are not present in the file, and
          will not substitute keywords that are not present in the
          <tt class="literal">svn:keywords</tt> property value.</p><div class="sidebar"><p class="title"><b>Keywords and Spurious Differences</b></p><p>The user-visible result of keyword substitution might
            lead you to think that every version of a file with that
            feature in use differs from the previous version in at
            least the area where the keyword anchor was placed.
            However, this is actually not the case.  While checking
            for local modifications during <span><b class="command">svn
            diff</b></span>, and before transmitting those local
            modifications during <span><b class="command">svn commit</b></span>,
            Subversion &#8220;<span class="quote">un-substitutes</span>&#8221; any keywords that
            it previously substituted.  The result is that the
            versions of the file that are stored in the repository
            contain only the real modifications that users make to the
            file.</p></div><p>Immediately after you commit this property change,
          Subversion will update your working file with the new
          substitute text.  Instead of seeing your keyword anchor
          <tt class="literal">$LastChangedDate$</tt>, you'll see its
          substituted result.  That result also contains the name of
          the keyword, and continues to be bounded by the dollar sign
          (<tt class="literal">$</tt>) characters.  And as we predicted, the
          <tt class="literal">Rev</tt> keyword was not substituted because
          we didn't ask for it to be.</p><pre class="screen">
Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</pre><p>If someone else now commits a change to
          <tt class="filename">weather.txt</tt>, your copy of that file
          will continue to display the same substituted keyword value
          as before&#8212;until you update your working copy.  At that
          time the keywords in your <tt class="filename">weather.txt</tt>
          file will be re-substituted with information that
          reflects the most recent known commit to that file.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.5"></a><tt class="literal">svn:eol-style</tt></h4></div></div><div></div></div><p>Unless otherwise noted using a versioned file's
          <tt class="literal">svn:mime-type</tt> property, Subversion
          assumes that file contains human-readable data.  Generally
          speaking, Subversion only uses this knowledge to determine
          if contextual differences reports for that file are
          possible.  Otherwise, to Subversion, bytes are bytes.</p><p>This means that by default, Subversion doesn't pay any
          attention to the type of <i class="firstterm">end-of-line (EOL)
          markers</i> used in your files.  Unfortunately,
          different operating system use different tokens to represent
          the end of a line of text in a file.  For example, the usual
          line ending token used by software on the Windows platform
          is a pair of ASCII control characters&#8212;carriage return
          (<tt class="literal">CR</tt>) and line feed
          (<tt class="literal">LF</tt>).  Unix software, however, just uses
          the <tt class="literal">LF</tt> character to denote the end of a
          line.</p><p>Not all of the various tools on these operating systems
          are prepared to understand files that contain line endings
          in a format that differs from the <i class="firstterm">native line
          ending style</i> of the operating system on which
          they are running.  Common results are that Unix programs
          treat the <tt class="literal">CR</tt> character present in Windows
          files as a regular character (usually rendered as
          <tt class="literal">^M</tt>), and that Windows programs combine
          all of the lines of a Unix file into one giant line because
          no carriage return-linefeed (or <tt class="literal">CRLF</tt>)
          character combination was found to denote the end of
          line.</p><p>This sensitivity to foreign EOL markers can become
          frustrating for folks who share a file across different
          operating systems.  For example, consider a source code
          file, and developers that edit this file on both Windows and
          Unix systems.  If all the developers always use tools which
          preserve the line ending style of the file, no problems
          occur.</p><p>But in practice, many common tools either fail to
          properly read a file with foreign EOL markers, or they
          convert the file's line endings to the native style when the
          file is saved.  If the former is true for a developer, he
          has to use an external conversion utility (such as
          <span><b class="command">dos2unix</b></span> or its companion,
          <span><b class="command">unix2dos</b></span>) to prepare the file for
          editing.  The latter case requires no extra preparation.
          But both cases result in a file that differs from the
          original quite literally on every line!  Prior to committing
          his changes, the user has two choices.  Either he can use a
          conversion utility to restore the modified file to the same
          line ending style that it was in before his edits were made.
          Or, he can simply commit the file&#8212;new EOL markers and
          all.</p><p>The result of scenarios like these include wasted time
          and unnecessary modifications to committed files.  Wasted
          time is painful enough.  But when commits change every line
          in a file, this complicates the job of determining which of
          those lines were changed in a non-trivial way.  Where was
          that bug really fixed?  On what line was a syntax error
          introduced?</p><p>The solution this problem is the
          <tt class="literal">svn:eol-style</tt> property.  When this
          property is set to a valid value, Subversion uses it to
          determine what special processing to perform on the file so
          that the file's line ending style isn't flip-flopping with
          every commit that comes from a different operating
          system.  The valid values are:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>This causes the file to contain the EOL markers
                that are native to the operating system on which
                Subversion was run.  In other words, if a user on a
                Windows machine checks out a working copy that
                contains a file with a
                <tt class="literal">svn:eol-style</tt> property set to
                <tt class="literal">native</tt>, that file will contain
                <tt class="literal">CRLF</tt> EOL markers.  A unix user
                checking out a working copy which contains the same
                file will see <tt class="literal">LF</tt> EOL markers in his
                copy of the file.</p><p>Note that Subversion will actually store the file
                in the repository using normalized
                <tt class="literal">LF</tt> EOL markers regardless of the
                operating system.  This is basically transparent to
                the user, though.</p></dd><dt><span class="term"><tt class="literal">CRLF</tt></span></dt><dd><p>This causes the file to contain
                <tt class="literal">CRLF</tt> sequences for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><tt class="literal">LF</tt></span></dt><dd><p>This causes the file to contain
                <tt class="literal">LF</tt> characters for EOL markers,
                regardless of the operating system in use.</p></dd><dt><span class="term"><tt class="literal">CR</tt></span></dt><dd><p>This causes the file to contain
                <tt class="literal">CR</tt> characters for EOL markers,
                regardless of the operating system in use.  This line
                ending style is not very common.  It was used on older
                Macintosh platforms (on which Subversion doesn't even
                run).</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-2.3.6"></a><tt class="literal">svn:externals</tt></h4></div></div><div></div></div><p>The <tt class="literal">svn:externals</tt> property contains
          instructions for Subversion to populate a versioned
          directory with one or more other checked-out Subversion
          working copies.  For more information on this keyword and
          its use, see <a href="#svn-ch-6-sect-3" title="Externals Definitions">the section called &#8220;Externals Definitions&#8221;</a>.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-3"></a>Externals Definitions</h2></div></div><div></div></div><p>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository, or perhaps from different
      repositories altogether.  You could certainly setup such a
      scenario by hand&#8212;using <span><b class="command">svn checkout</b></span> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</p><p>Fortunately, Subversion provides support for
      <i class="firstterm">externals definitions</i>.  An externals
      definition is a mapping of a local directory to the URL of a
      versioned resource.  In Subversion, you declare externals
      definitions in groups using the <tt class="literal">svn:externals</tt>
      property.  This property is set on a versioned directory, and
      its value is a multi-line table of subdirectories (relative to
      the versioned directory on which the property is set) and
      Subversion repository URLs.</p><pre class="screen">
$ svn propget svn:externals calc
third-party/sounds          http://sounds.red-bean.com/repos
third-party/skins           http://skins.red-bean.com/repositories/skinproj
third-party/skins/toolkit   http://svn.red-bean.com/repos/skin-maker
</pre><p>The convenience of the <tt class="literal">svn:externals</tt>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define those nested
      working copy checkouts, no one else has to
      bother&#8212;Subversion will, upon checkout of the original
      working copy, also checkout the external working copies.</p><p>Note the previous externals definition example.  When
      someone checks out a working copy of the
      <tt class="filename">calc</tt> directory, Subversion also continues
      to checkout the items found in its externals definition.</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A  calc/third-party/sounds/ding.ogg
A  calc/third-party/sounds/dong.ogg
A  calc/third-party/sounds/clang.ogg
&#8230;
A  calc/third-party/sounds/bang.ogg
A  calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
&#8230;
</pre><p>If you need to change the externals definition, you can do
      so using the regular property modification subcommands.  When
      you commit a change to the <tt class="literal">svn:externals</tt>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <span><b class="command">svn update</b></span>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-4"></a>Vendor branches</h2></div></div><div></div></div><p>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up-to-date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&#8212;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</p><p>For example, software developers might be working on an
      application which makes use of a third-party library.
      Subversion has just such a relationship with the Apache Portable
      Runtime library (see <a href="#svn-ch-7-sect-2.1" title="The Apache Portable Runtime Library">the section called &#8220;The Apache Portable Runtime Library&#8221;</a>).  The
      Subversion source code depends on the APR library for all its
      portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the &#8220;<span class="quote">bleeding edge</span>&#8221; of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</p><p>Now, if your project depends on someone else's information,
      there are several ways that you could attempt to synchronize that
      information with your own.  Most painfully, you could issue oral
      or written instructions to all the contributors of your project,
      telling them to make sure that they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively &#8220;<span class="quote">pin down</span>&#8221; specific
      versions of that information to some location in your own
      working copy directory (see <a href="#svn-ch-6-sect-3" title="Externals Definitions">the section called &#8220;Externals Definitions&#8221;</a>).</p><p>But sometimes you want to maintain custom modifications to
      third-party data in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</p><p>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternate versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party data, and
      necessitating regeneration of those changes with each successive
      version of the third-party data that you track.</p><p>The solution to this problem is to use <i class="firstterm">vendor
      branches</i>.  A vendor branch is a directory tree in
      your own version control system which contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor's data that you decide to absorb into your project is
      called a <i class="firstterm">vendor drop</i>.</p><p>Vendor branches provide two key benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, the members of your project never need to question
      whether they have the right version of the vendor's data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Secondly, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place&#8212;you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.1"></a>General Vendor Branch Management Procedure</h3></div></div><div></div></div><p>Managing vendor branches generally works like this.  You
        create a top-level directory (such as
        <tt class="filename">/vendor</tt>) to hold the vendor branches.
        Then you import the third party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (for example,
        <tt class="filename">/trunk</tt>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking you bring
        it into the vendor branch and merge the changes into
        <tt class="filename">/trunk</tt>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</p><p>Perhaps an example will help to clarify this algorithm.
        We'll use a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We'll begin with the
        initial creation of the vendor branch, and the import of the
        first vendor drop.</p><pre class="screen">
&#8230;
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/calc/vendor/libcomplex/current \
             -m 'importing initial 1.0 vendor drop'
&#8230;
</pre><p>We now have the current version of the libcomplex source
        code in <tt class="filename">/vendor/libcomplex/current</tt>.  Now,
        we tag that version (see <a href="#svn-ch-4-sect-6" title="Tags">the section called &#8220;Tags&#8221;</a>)
        and then copy it into the main development branch so we can
        make our customizations to it.</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/vendor/libcomplex/current  \
           http://svn.example.com/repos/calc/vendor/libcomplex/1.0      \
           -m 'tagging libcomplex-1.0'
&#8230;
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'bringing libcomplex-1.0 into the main branch'
&#8230;
</pre><p>We check out our project's main branch&#8212;which now
        includes a copy of the first vendor drop&#8212;and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.
        <sup>[<a name="id2921322" href="#ftn.id2921322">26</a>]</sup>
      </p><p>A few weeks later, the developers of libcomplex release a
        new version of their library&#8212;version 1.1&#8212;which
        contains some features and functionality that we really want.
        But we'd like to upgrade to this new version without losing
        our customizations to the existing version.  As you might have
        guessed, what we essentially would like to do is to replace
        our current baseline version of libcomplex 1.0 with a copy of
        libcomplex 1.1, and then re-apply the custom modifications we
        previously made to that library to the new version.</p><p>To perform this upgrade, we checkout a copy of our vendor
        branch, and replace the <tt class="literal">current</tt> version
        with the new libcomplex 1.1 source code.  After committing
        this change, our <tt class="literal">current</tt> branch now
        contains the new vendor drop.  We tag the new version, and
        then merge the differences between the tag of the previous
        version and the new current version into our main development
        branch.</p><pre class="screen">
$ cd working-copies/calc
$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \
            http://svn.example.com/repos/vendor/libcomplex/current  \
            libcomplex
&#8230; # resolve all the conflicts between their changes and our changes
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
&#8230;
</pre><p>In the trivial use-case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  In other
        words, none of the libcomplex source files would have been
        deleted, renamed or moved to different locations&#8212;in
        short, in a perfect world, our modifications would apply
        cleanly to the new version of the library, with absolutely no
        complications or conflicts.</p><p>But things aren't always that simple, and in fact it is
       quite common for source files to get moved around between
       releases of software.  This complicates the process of ensuring
       that our modifications are still valid for the new version of
       code, and can quickly degrade into a situation where we have to
       manually recreate our customizations in the new version.  Once
       Subversion knows about the history of a given source
       file&#8212;including all its previous locations&#8212;the
       process of merging in the new version of the library is pretty
       simple.  But we are responsible for telling Subversion how the
       source file layout changed from vendor drop to vendor
       drop.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.2"></a><span><b class="command">svn-load-dirs.pl</b></span></h3></div></div><div></div></div><p>Vendor drops that contain more than a few deletes,
        additions and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <span><b class="command">svn_load_dirs.pl</b></span>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure that mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <span><b class="command">svn_load_dirs.pl</b></span>
        can help you more quickly and easily arrive at that
        stage.</p><p>In short, <span><b class="command">svn_load_dirs.pl</b></span> is an
        enhancement to <span><b class="command">svn import</b></span> that has several
        important characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</p></li><li><p>It takes care of complicated series of operations between
            which Subversion requires a intermediate commit&#8212;such
            as before renaming a file or directory twice.</p></li><li><p>It will optionally tag the newly imported directory.</p></li><li><p>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</p></li></ul></div><p><span><b class="command">svn_load_dirs.pl</b></span> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL&#8212;relative the first argument&#8212;into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <span><b class="command">svn_load_dirs.pl</b></span>
        might look like:</p><pre class="screen">
$ svn_load_dirs.pl http://svn.example.com/repos/calc/vendor/libcomplex \
                   current                                             \
                   /path/to/libcomplex-1.1
&#8230;
</pre><p>You can indicate that you'd like
        <span><b class="command">svn_load_dirs.pl</b></span> to tag the new vendor drop
        by passing the <tt class="option">-t</tt> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</p><pre class="screen">
$ svn_load_dirs.pl -t libcomplex-1.1                                   \
                   http://svn.example.com/repos/calc/vendor/libcomplex \
                   current                                             \
                   /path/to/libcomplex-1.1
&#8230;
</pre><p>When you run <span><b class="command">svn_load_dirs.pl</b></span>, it
        examines the contents of your existing &#8220;<span class="quote">current</span>&#8221;
        vendor drop, and compares them with the proposed new vendor
        drop.  In the trivial case, there will be no files that are in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <span><b class="command">svn_load_dirs.pl</b></span> will prompt you for how
        you would like to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <tt class="filename">math.c</tt> in version 1.0 of
        libcomplex was renamed to <tt class="filename">arithmetic.c</tt> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</p><p>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <span class="emphasis"><em>added</em></span> to the
        repository.  This configuration file is specified to
        <span><b class="command">svn_load_dirs.pl</b></span> using the
        <tt class="option">-p</tt> command-line option.  Each line of the
        configuration files is a whitespace-delimited set of two or
        four values: a Perl-style regular expression to match the
        added path against, a control keyword (either
        <tt class="literal">break</tt> or <tt class="literal">cont</tt>), and then
        optionally a property name and value.</p><pre class="screen">
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre><p>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <tt class="literal">break</tt>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <tt class="literal">cont</tt>&#8212;an abbreviation for
        <tt class="literal">continue</tt>&#8212;then matching will continue
        with the next line of the configuration file.</p><p>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quote characters.  You can escape quote characters that
        are not used for wrapping whitespace by preceding them with a
        backslash (<tt class="literal">\</tt>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2909247" href="#id2909247">19</a>] </sup>This offer applies only to those who, like most folks,
          pay nothing for Subversion.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2917948" href="#id2917948">20</a>] </sup>Anyone for potluck dinner?</p></div><div class="footnote"><p><sup>[<a name="ftn.id2918748" href="#id2918748">21</a>] </sup>Fixing spelling errors, grammatical gotchas, and
              &#8220;<span class="quote">just-plain-wrongness</span>&#8221; in commit log
              messages is perhaps the most common use-case for the
              <tt class="option">--revprop</tt> option.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2919168" href="#id2919168">22</a>] </sup>The Windows filesystems use file extensions (such as
              <tt class="literal">.EXE</tt>, <tt class="literal">.BAT</tt>, and
              <tt class="literal">.COM</tt>) to denote executable
              files.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2919648" href="#id2919648">23</a>] </sup>The patterns are strictly for that
              directory&#8212;they do not carry recursively into
              subdirectories.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2919719" href="#id2919719">24</a>] </sup>Isn't that the whole point of a build system?</p></div><div class="footnote"><p><sup>[<a name="ftn.id2920176" href="#id2920176">25</a>] </sup>&#8230; or maybe even a section of a book &#8230;</p></div><div class="footnote"><p><sup>[<a name="ftn.id2921322" href="#id2921322">26</a>] </sup>And entirely bug-free, of course!</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-7"></a>Chapter 7. Developer Information</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-7-sect-1">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-1.1">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.2">Repository Access Layer</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.3">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-2">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-2.1">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.2">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.3">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-3">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-3.1">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-3.2">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-4">WebDAV</a></span></dt><dt><span class="sect1"><a href="#svn-ch-7-sect-5">Programming with Memory Pools</a></span></dt><dt><span class="sect1"><a href="#svn-ch-7-sect-6">Contributing to Subversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-6.1">Join the Community</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.2">Get the Source Code</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.3">Become Familiar with Community Policies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.4">Make and Test Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-6.5">Donate Your Changes</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Subversion is an open-source software project developed
      under an Apache-style software license.  The project is
      financially backed by CollabNet, Inc., a California-based
      software development company.  The community that has formed
      around the development of Subversion always welcomes new members
      who can donate their time and attention to the project.
      Volunteers are encouraged to assist in any way they can, whether
      that means finding and diagnosing bugs, refining existing source
      code, or fleshing out whole new features.</p><p>This chapter is for those who wish to assist in the
      continued evolution of Subversion by actually getting their
      hands dirty with the source code.  We will cover some of the
      software's more intimate details, the kind of technical
      nitty-gritty that those developing Subversion itself&#8212;or
      writing entirely new tools based on the Subversion
      libraries&#8212;should be aware of.  If you don't foresee
      yourself participating with the software at such a level, feel
      free to skip this chapter with confidence that your experience
      as a Subversion user will not be affected.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-1"></a>Layered Library Design</h2></div></div><div></div></div><p>Subversion has a modular design, implemented as a collection
      of C libraries.  Each library has a well-defined purpose and
      interface, and most modules are said to exist in one of three
      main layers&#8212;the Repository Layer, the Repository Access
      (RA) Layer, or the Client Layer.  We will examine these layers
      shortly, but first, see our brief inventory of Subversion's
      libraries in Table 7-1.  For the sake of consistency, we will
      refer to the libraries by their extensionless Unix library names
      (e.g.: libsvn_fs, libsvn_wc, mod_dav_svn).</p><div class="table"><a name="svn-ch-7-table-1"></a><p class="title"><b>Table 7.1. A Brief Inventory of the Subversion Libraries</b></p><table summary="A Brief Inventory of the Subversion Libraries" border="1"><colgroup><col><col></colgroup><thead><tr><th>Library</th><th>Description</th></tr></thead><tbody><tr><td>libsvn_client</td><td>Primary interface for client programs</td></tr><tr><td>libsvn_delta</td><td>Tree and text differencing routines</td></tr><tr><td>libsvn_fs</td><td>The Subversion filesystem library</td></tr><tr><td>libsvn_ra</td><td>Repository Access commons and module loader</td></tr><tr><td>libsvn_ra_dav</td><td>The WebDAV Repository Access module</td></tr><tr><td>libsvn_ra_local</td><td>The local Repository Access module</td></tr><tr><td>libsvn_ra_svn</td><td>A proprietary protocol Repository Access module</td></tr><tr><td>libsvn_repos</td><td>Repository interface</td></tr><tr><td>libsvn_subr</td><td>Miscellaneous helpful subroutines</td></tr><tr><td>libsvn_wc</td><td>The working copy management library</td></tr><tr><td>mod_dav_svn</td><td>Apache module for mapping WebDAV operations to
            Subversion ones</td></tr></tbody></table></div><p>The fact that the word "miscellaneous" only appears once in
      Table 7-1 is a good sign.  The Subversion development team
      is serious about making sure that functionality lives in the
      right layer and libraries.  Perhaps the greatest advantage of
      the modular design is its lack of complexity from a developer's
      point of view.  As a developer, you can quickly formulate that
      kind of "big picture" that allows you to pinpoint the location
      of certain pieces of functionality with relative ease.</p><p>And what could better help a developer gain a "big picture"
      perspective than a big picture?  To help you understand
      how the Subversion libraries fit together, see Figure 7-1, a
      diagram of Subversion's layers.  Program flow begins at the top
      of the diagram (initiated by the user) and flows
      "downward".</p><div class="figure"><a name="svn-ch7-sect1-dia1"></a><p class="title"><b>Figure 7.1. Subversion's "Big Picture"</b></p><div><img src="images/ch07dia1.png" alt="Subversion's &quot;Big Picture&quot;"></div></div><p>Another benefit of modularity is the ability to replace a
      given module with a whole new library that implements the same
      API without affecting the rest of the code base.  In some sense,
      this happens within Subversion already.  The libsvn_ra_dav,
      libsvn_ra_local, and libsvn_ra_svn all implement the same
      interface.  And all three communicate with the Repository
      Layer&#8212; libsvn_ra_dav and libsvn_ra_svn do so across a
      network, and libsvn_ra_local connects to it directly.</p><p>The client itself also highlights modularity in the
      Subversion design.  While Subversion currently comes with only a
      command-line client program, there are already a few other
      programs being developed by third parties to act as GUIs for
      Subversion.  Again, these GUIs use the same APIs that the stock
      command-line client does.  Subversion's libsvn_client library is
      the one-stop shop for most of the functionality necessary for
      designing a working Subversion client (see <a href="#svn-ch-7-sect-1.3" title="Client Layer">the section called &#8220;Client Layer&#8221;</a>).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-1.1"></a>Repository Layer</h3></div></div><div></div></div><p>When referring to Subversion's Repository Layer, we're
        generally talking about two libraries&#8212;the repository
        library, and the filesystem library.  These libraries provide
        the storage and reporting mechanisms for the various revisions
        of your version-controlled data.  This layer is connected to
        the Client Layer via the Repository Access Layer, and is, from
        the perspective of the Subversion user, the stuff at the
        "other end of the line."</p><p>The Subversion Filesystem is accessed via the libsvn_fs
        API, and is not a kernel-level filesystem that one would
        install in an operating system (like the Linux ext2 or NTFS),
        but a virtual filesystem.  Rather than storing "files" and
        "directories" as real files and directories (as in, the kind
        you can navigate through using your favorite shell program),
        it uses a database system for its back-end storage mechanism.
        Currently, the database system in use is Berkeley DB.
        <sup>[<a name="id2926932" href="#ftn.id2926932">27</a>]</sup>
        However, there has been considerable interest by the
        development community in giving future releases of Subversion
        the ability to use other back-end database systems, perhaps
        through a mechanism such as Open Database Connectivity
        (ODBC).</p><p>The filesystem API exported by libsvn_fs contains the
        kinds of functionality you would expect from any other
        filesystem API: you can create and remove files and
        directories, copy and move them around, modify file contents,
        and so on.  It also has features that are not quite as common,
        such as the ability to add, modify, and remove metadata
        ("properties") on each file or directory.  Furthermore, the
        Subversion Filesystem is a versioning filesystem, which means
        that as you make changes to your directory tree, Subversion
        remembers what your tree looked like before those changes.
        And before the previous changes.  And the previous ones.  And
        so on, all the way back through versioning time to (and just
        beyond) the moment you first started adding things to the
        filesystem.</p><p>All the modifications you make to your tree are done
        within the context of a Subversion transaction.  The following
        is a simplified general routine for modifying your
        filesystem:</p><div class="orderedlist"><ol type="1"><li><p>Begin a Subversion transaction.</p></li><li><p>Make your changes (adds, deletes, property
            modifications, etc.).</p></li><li><p>Commit your transaction.</p></li></ol></div><p>Once you have committed your transaction, your filesystem
        modifications are permanently stored as historical artifacts.
        Each of these cycles generates a single new revision of your
        tree, and each revision is forever accessible as an immutable
        snapshot of "the way things were."</p><div class="sidebar"><p class="title"><b>The Transaction Distraction</b></p><p>The notion of a Subversion transaction, especially given
          its close proximity the database code in libsvn_fs, can
          become easily confused with the transaction support provided
          by the underlying database itself.  Both types of
          transaction exist to provide atomicity and isolation.  In
          other words, transactions give you the ability to perform a
          set of actions in an "all or nothing" fashion&#8212;either
          all the actions in the set complete with success, or they
          all get treated as if <span class="emphasis"><em>none</em></span> of them ever
          happened&#8212;and in a way that does not interfere with
          other processes acting on the data.</p><p>Database transactions generally encompass small
          operations related specifically to the modification of data
          in the database itself (such as changing the contents of a
          table row).  Subversion transactions are larger in scope,
          encompassing higher-level operations like making
          modifications to a set of files and directories which are
          intended to be stored as the next revision of the filesystem
          tree.  If that isn't confusing enough, consider this:
          Subversion uses a database transaction during the creation
          of a Subversion transaction (so that if the creation of
          Subversion transaction fails, the database will look as if
          we had never attempted that creation in the first
          place)!</p><p>Fortunately for users of the filesystem API, the
          transaction support provided by the database system itself
          is hidden almost entirely from view (as should be expected
          from a properly modularized library scheme).  It is only
          when you start digging into the implementation of the
          filesystem itself that such things become visible (or
          interesting).</p></div><p>Most of the functionality provided by the filesystem
        interface comes as an action that occurs on a filesystem path.
        That is, from outside of the filesystem, the primary mechanism
        for describing and accessing the individual revisions of files
        and directories comes through the use of path strings like
        <tt class="filename">/foo/bar</tt>, just as if you were addressing
        files and directories through your favorite shell program.
        You add new files and directories by passing their paths-to-be
        to the right API functions.  You query for information about
        them by the same mechanism.</p><p>Unlike most filesystems, though, a path alone is not
        enough information to identify a file or directory in
        Subversion.  Think of a directory tree as a two-dimensional
        system, where a node's siblings represent a sort of
        left-and-right motion, and descending into subdirectories a
        downward motion.  Figure 7-2 shows a typical representation of
        a tree as exactly that.</p><div class="figure"><a name="svn-ch7-sect1.1-dia1"></a><p class="title"><b>Figure 7.2. Files and Directories in Two Dimensions</b></p><div><img src="images/ch07dia2.png" alt="Files and Directories in Two Dimensions"></div></div><p>Of course, the Subversion filesystem has a nifty third
        dimension that most filesystems do not have&#8212;Time!
        <sup>[<a name="id2927046" href="#ftn.id2927046">28</a>]</sup>
        In the filesystem interface, nearly every function that has a
        <i class="parameter"><tt>path</tt></i> argument also expects a
        <i class="parameter"><tt>root</tt></i> argument.  This
        <span class="structname">svn_fs_root_t</span> argument describes
        either a revision or a Subversion transaction (which is
        usually just a revision-to-be), and provides that
        third-dimensional context needed to understand the difference
        between <tt class="filename">/foo/bar</tt> in revision 32, and the
        same path as it exists in revision 98.  Figure 7-3 shows
        revision history as an added dimension to the Subversion
        filesystem universe.</p><div class="figure"><a name="svn-ch7-sect1.1-dia2"></a><p class="title"><b>Figure 7.3. Revisioning Time&#8212;the Third Dimension!</b></p><div><img src="images/ch07dia3.png" alt="Revisioning Time&#8212;the Third Dimension!"></div></div><p>As we mentioned earlier, the libsvn_fs API looks and feels
        like any other filesystem, except that it has this wonderful
        versioning capability.  It was designed to be usable by any
        program interested in a versioning filesystem.  Not
        coincidentally, Subversion itself is interested in that
        functionality.  But while the filesystem API should be
        sufficient for basic file and directory versioning support,
        Subversion wants more&#8212;and that is where libsvn_repos
        comes in.</p><p>The Subversion repository library (libsvn_repos) is
        basically a wrapper library around the filesystem
        functionality.  This library is responsible for creating the
        repository layout, making sure that the underlying filesystem
        is initialized, and so on.  Libsvn_repos also implements a set
        of hooks&#8212;scripts that are executed by the repository
        code when certain actions take place.  These scripts are
        useful for notification, authorization, or whatever purposes
        the repository administrator desires.  This type of
        functionality, and other utility provided by the repository
        library, is not strictly related to implementing a versioning
        filesystem, which is why it was placed into its own
        library.</p><p>Developers who wish to use the libsvn_repos API will find
        that it is not a complete wrapper around the filesystem
        interface.  That is, only certain major events in the general
        cycle of filesystem activity are wrapped by the repository
        interface.  Some of these include the creation and commit of
        Subversion transactions, and the modification of revision
        properties.  These particular events are wrapped by the
        repository layer because they have hooks associated with them.
        In the future, other events may be wrapped by the repository
        API.  All of the remaining filesystem interaction will
        continue to occur directly with libsvn_fs API, though.</p><p>For example, here is a code segment that illustrates the
        use of both the repository and filesystem interfaces to create
        a new revision of the filesystem in which a directory is
        added.  Note that in this example (and all others throughout
        this book), the <tt class="function">SVN_ERR</tt> macro simply
        checks for a non-successful error return from the function it
        wraps, and returns that error if it exists.</p><div class="example"><a name="svn-ch-7-sect-1.1-ex-1"></a><p class="title"><b>Example 7.1. Using the Repository Layer</b></p><pre class="programlisting">
/* Create a new directory at the path NEW_DIRECTORY in the Subversion
   repository located at REPOS_PATH.  Perform all memory allocation in
   POOL.  This function will create a new revision for the addition of
   NEW_DIRECTORY.  */
static svn_error_t *
make_new_directory (const char *repos_path,
                    const char *new_directory,
                    apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH.  */
  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in
     REPOS.  */
  fs = svn_repos_fs (repos);

  /* Ask the filesystem to tell us the youngest revision that
     currently exists.  */
  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
     less likely to have our later commit rejected as conflicting if we
     always try to make our changes against a copy of the latest snapshot
     of the filesystem tree.  */
  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));

  /* Now that we have started a new Subversion transaction, get a root
     object that represents that transaction.  */
  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
     NEW_DIRECTORY.  */
  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
     which includes our added directory path.  */
  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, 
                                 &amp;youngest_rev, txn);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.  */
      printf ("Directory '%s' was successfully added as new revision "
              "'%" SVN_REVNUM_T_FMT "'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT))
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
         (someone else seems to have made changes to the same area 
         of the filesystem that we tried to modify).  Print an error
         message.  */
      printf ("A conflict occurred at path '%s' while attempting "
              "to add directory '%s' to the repository at '%s'.\n", 
              conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.  */
      printf ("An error occurred while attempting to add directory '%s' "
              "to the repository at '%s'.\n", 
              new_directory, repos_path);
    }

  /* Return the result of the attempted commit to our caller.  */
  return err;
} 
</pre></div><p>In the previous code segment, calls were made to both the
        repository and filesystem interfaces.  We could just as easily
        have committed the transaction using
        <tt class="function">svn_fs_commit_txn</tt>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (like, for example, sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        libsvn_repos-wrapped version of that
        function&#8212;<tt class="function">svn_repos_fs_commit_txn</tt>.
        This function will actually first run the "pre-commit" hook
        script if one exists, then commit the transaction, and finally
        will run a "post-commit" hook script.  The hooks provide a
        special kind of reporting mechanism that does not really
        belong in the core filesystem library itself.  (For more
        information regarding Subversion's repository hooks, see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>.)</p><p>The hook mechanism requirement is but one of the reasons
        for the abstraction of a separate repository library from the
        rest of the filesystem code.  The libsvn_repos API provides
        several other important utilities to Subversion.  These
        include the abilities to:</p><div class="orderedlist"><ol type="1"><li><p>create, open, destroy, and perform recovery steps on a
            Subversion repository and the filesystem included in that
            repository.</p></li><li><p>describe the differences between two filesystem
            trees.</p></li><li><p>query for the commit log messages
            associated with all (or some) of the revisions in which a
            set of files was modified in the filesystem.</p></li><li><p>generate a human-readable "dump" of the filesystem, a
            complete representation of the revisions in the
            filesystem.</p></li><li><p>parse that dump format, loading the dumped revisions
            into a different Subversion repository.</p></li></ol></div><p>As Subversion continues to evolve, the repository library
        will grow with the filesystem library to offer increased
        functionality and configurable option support.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-1.2"></a>Repository Access Layer</h3></div></div><div></div></div><p>If the Subversion Repository Layer is at "the other end of
        the line", the Repository Access Layer is the line itself.
        Charged with marshalling data between the client libraries and
        the repository, this layer includes the libsvn_ra module
        loader library, the RA modules themselves (which currently
        includes libsvn_ra_dav, libsvn_ra_local, and libsvn_ra_svn),
        and any additional libraries needed by one or more of those RA
        modules, such as the mod_dav_svn Apache module with which
        libsvn_ra_dav communicates or libsvn_ra_svn's server,
        <span><b class="command">svnserve</b></span>.</p><p>Since Subversion uses URLs to identify its repository
        resources, the protocol portion of the URL schema (usually
        <tt class="literal">file:</tt>, <tt class="literal">http:</tt>,
        <tt class="literal">https:</tt>, or <tt class="literal">svn:</tt>) is used
        to determine which RA module will handle the communications.
        Each module registers a list of the protocols it knows how to
        "speak" so that the RA loader can, at runtime, determine which
        module to use for the task at hand.  You can determine which
        RA modules are available to the Subversion command-line
        client, and what protocols they claim to support, by running
        <span><b class="command">svn --version</b></span>:</p><pre class="screen">
$ svn --version
svn, version 0.25.0 (dev build)
   compiled Jul 18 2003, 16:25:59
 
Copyright (C) 2000-2003 CollabNet.
Subversion is open source software, see http://subversion.tigris.org/
 
The following repository access (RA) modules are available:
 
* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
  - handles 'http' schema
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' schema
* ra_svn : Module for accessing a repository using the svn network protocol.
  - handles 'svn' schema
</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-7-sect-1.2.1"></a>RA-DAV (Repository Access Using HTTP/DAV)</h4></div></div><div></div></div><p>The libsvn_ra_dav library is designed for use by clients
          that are being run on different machines than the servers
          with which they communicating, specifically machines reached
          using URLs that contain the <tt class="literal">http:</tt> or
          <tt class="literal">https:</tt> protocol portions.  To understand
          how this module works, we should first mention a couple of
          other key components in this particular configuration of the
          Repository Access Layer&#8212;the powerful Apache HTTP
          Server, and the Neon HTTP/WebDAV client library.</p><p>Subversion's primary network server is the Apache HTTP
          Server.  Apache is a time-tested, extensible open-source
          server process that is ready for serious use.  It can
          sustain a high network load and runs on many platforms.  The
          Apache server supports a number of different standard
          authentication protocols, and can be extended through the
          use of modules to support many others.  It also supports
          optimizations like network pipelining and caching.  By using
          Apache as a server, Subversion gets all of these features
          for free.  And since most firewalls already allow HTTP
          traffic to pass through, sysadmins typically don't even have
          to change their firewall configurations to allow Subversion
          to work.</p><p>Subversion uses HTTP and WebDAV (with DeltaV) to
          communicate with an Apache server.  You can read more about
          this in the WebDAV section of this chapter, but in short,
          WebDAV and DeltaV are extensions to the standard HTTP 1.1
          protocol that enable sharing and versioning of files over
          the web.  Apache 2.0 comes with mod_dav, an Apache module
          that understands the DAV extensions to HTTP.  Subversion
          itself supplies mod_dav_svn, though, which is another Apache
          module that works in conjunction with (really, as a back-end
          to) mod_dav to provide Subversion's specific implementations
          of WebDAV and DeltaV.</p><p>When communicating with a repository over HTTP, the RA
          loader library chooses libsvn_ra_dav as the proper access
          module.  The Subversion client makes calls into the generic
          RA interface, and libsvn_ra_dav maps those calls (which
          embody rather large-scale Subversion actions) to a set of
          HTTP/WebDAV requests.  Using the Neon library, libsvn_ra_dav
          transmits those requests to the Apache server.  Apache
          receives these requests (exactly as it does generic HTTP
          requests that your web browser might make), notices that the
          requests are directed at a URL that is configured as a DAV
          location (using the <tt class="sgmltag-element">Location</tt> directive in
          <tt class="filename">httpd.conf</tt>), and hands the request off
          to its own mod_dav module.  When properly configured,
          mod_dav knows to use Subversion's mod_dav_svn for any
          filesystem-related needs, as opposed to the generic
          mod_dav_fs that comes with Apache.  So ultimately, the
          client is communicating with mod_dav_svn, which binds
          directly to the Subversion Repository Layer.</p><p>That was a simplified description of the actual
          exchanges taking place, though.  For example, the Subversion
          repository might be protected by Apache's authorization
          directives.  This could result in initial attempts to
          communicate with the repository being rejected by Apache on
          authorization grounds.  At this point, libsvn_ra_dav gets
          back the notice from Apache that insufficient identification
          was supplied, and calls back into the Client Layer to get
          some updated authentication data.  If the data is supplied
          correctly, and the user has the permissions that Apache
          seeks, libsvn_ra_dav's next automatic attempt at performing
          the original operation will be granted, and all will be
          well.  If sufficient authentication information cannot be
          supplied, the request will ultimately fail, and the client
          will report the failure to the user.</p><p>By using Neon and Apache, Subversion gets free
          functionality in several other complex areas, too.  For
          example, if Neon finds the OpenSSL libraries, it allows the
          Subversion client to attempt to use SSL-encrypted
          communications with the Apache server (whose own mod_ssl can
          "speak the language").  Also, both Neon itself and Apache's
          mod_deflate can understand the "deflate" algorithm (the same
          used by the PKZIP and gzip programs), so requests can be
          sent in smaller, compressed chunks across the wire.  Other
          complex features that Subversion hopes to support in the
          future include the ability to automatically handle
          server-specified redirects (for example, when a repository
          has been moved to a new canonical URL) and taking advantage
          of HTTP pipelining.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-7-sect-1.2.2"></a>RA-SVN (Proprietary Protocol Repository Access)</h4></div></div><div></div></div><p>In addition to the standard HTTP/WebDAV protocol,
          Subversion also provides an RA implementation that uses a
          proprietary protocol.  The libsvn_ra_svn module implements
          its own network socket connectivity, and communicates with a
          stand-alone server&#8212;the <tt class="filename">svnserve</tt>
          program&#8212;on the machine that hosts the
          repository.  Clients access the repository using the
          <tt class="literal">svn://</tt> schema.</p><p>This RA implementation lacks most of the advantages of
          Apache mentioned in the previous section; however, it may be
          appealing to some sysadmins nonetheless.  It is dramatically
          easier to configure and run; setting up an
          <tt class="filename">svnserve</tt> process is nearly
          instantaneous.  It is also much smaller (in terms of lines
          of code) than Apache, making it much easier to audit, for
          security reasons or otherwise.  Furthermore, some sysadmins
          may already have an SSH security infrastructure in place,
          and want Subversion to use it.  Clients using ra_svn can
          easily tunnel the protocol over SSH.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-7-sect-1.2.3"></a>RA-Local (Direct Repository Access)</h4></div></div><div></div></div><p>Not all communications with a Subversion repository
          require a powerhouse server process and a network layer.
          For users who simply wish to access the repositories on
          their local disk, they may do so using
          <tt class="literal">file:</tt> URLs and the functionality provided
          by libsvn_ra_local.  This RA module binds directly with the
          repository and filesystem libraries, so no network
          communication is required at all.</p><p>Subversion requires the server name included as part of
          the <tt class="literal">file:</tt> URL be either
          <tt class="literal">localhost</tt> or empty, and that there be no
          port specification.  In other words, your URLs should look
          like either
          <tt class="literal">file://localhost/path/to/repos</tt> or
          <tt class="literal">file:///path/to/repos</tt>.</p><p>Also, be aware that Subversion's
          <tt class="literal">file:</tt> URLs cannot be used in a regular
          web browser the way typical <tt class="literal">file:</tt> URLs
          can.  When you attempt to view a <tt class="literal">file:</tt>
          URL in a regular web browser, it reads and displays the
          contents of the file at that location by examining the
          filesystem directly.  However, Subversion's resources exist
          in a virtual filesystem (see <a href="#svn-ch-7-sect-1.1" title="Repository Layer">the section called &#8220;Repository Layer&#8221;</a>), and your browser will not
          understand how to read that filesystem.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-7-sect-1.2.4"></a>Your RA Library Here</h4></div></div><div></div></div><p>For those who wish to access a Subversion repository
          using still another protocol, that is precisely why the
          Repository Access Layer is modularized!  Developers can
          simply write a new library that implements the RA interface
          on one side and communicates with the repository on the
          other.  Your new library can use existing network protocols,
          or you can invent your own.  You could use inter-process
          communication (IPC) calls, or&#8212;let's get crazy, shall
          we?&#8212;you could even implement an email-based protocol.
          Subversion supplies the APIs; you supply the creativity.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-1.3"></a>Client Layer</h3></div></div><div></div></div><p>On the client side, the Subversion working copy is where
        all the action takes place.  The bulk of functionality
        implemented by the client-side libraries exists for the sole
        purpose of managing working copies&#8212;directories full of
        files and other subdirectories which serve as a sort of local,
        editable "reflection" of one or more repository
        locations&#8212;and propagating changes to and from the
        Repository Access layer.</p><p>Subversion's working copy library, libsvn_wc, is directly
        responsible for managing the data in the working copies.  To
        accomplish this, the library stores administrative information
        about each working copy directory within a special
        subdirectory.  This subdirectory, named
        <tt class="filename">.svn</tt> is present in each working copy
        directory and contains various other files and directories
        which record state and provide a private workspace for
        administrative action.  For those familiar with CVS, this
        <tt class="filename">.svn</tt> subdirectory is similar in purpose
        to the <tt class="filename">CVS</tt> administrative directories
        found in CVS working copies.  For more information about the
        <tt class="filename">.svn</tt> administrative area, see <a href="#svn-ch-7-sect-3" title="Inside the Working Copy Administration Area">the section called &#8220;Inside the Working Copy Administration Area&#8221;</a>in this chapter.</p><p>The Subversion client library, libsvn_client, has the
        broadest responsibility; its job is to mingle the
        functionality of the working copy library with that of the
        Repository Access Layer, and then to provide the highest-level
        API to any application that wishes to perform general revision
        control actions.  For example, the function
        <tt class="function">svn_client_checkout</tt> takes a URL as an
        argument.  It passes this URL to the RA layer and opens an
        authenticated session with a particular repository.  It then
        asks the repository for a certain tree, and sends this tree
        into the working copy library, which then writes a full
        working copy to disk (<tt class="filename">.svn</tt> directories
        and all).</p><p>The client library is designed to be used by any
        application.  While the Subversion source code includes a
        standard command-line client, it should be very easy to write
        any number of GUI clients on top of the client library.  New
        GUIs (or any new client, really) for Subversion need not be
        clunky wrappers around the included command-line
        client&#8212;they have full access via the libsvn_client API
        to same functionality, data, and callback mechanisms that the
        command-line client uses.</p><div class="sidebar"><p class="title"><b>Binding Directly&#8212;A Word About Correctness</b></p><p>Why should your GUI program bind directly with a
          libsvn_client instead of acting as a wrapper around a
          command-line program?  Besides simply being more efficient,
          this can address potential correctness issues as well.  A
          command-line program (like the one supplied with Subversion)
          that binds to the client library needs to effectively
          translate feedback and requested data bits from C types to
          some form of human-readable output.  This type of
          translation can be lossy.  That is, the program may not
          display all of the information harvested from the API, or
          may combine bits of information for compact representation.</p><p>If you wrap such a command-line program with yet another
          program, the second program has access only to
          already-interpreted (and as we mentioned, likely incomplete)
          information, which it must <span class="emphasis"><em>again</em></span>
          translate into <span class="emphasis"><em>its</em></span> representation
          format.  With each layer of wrapping, the integrity of the
          original data is potentially tainted more and more, much
          like the result of making a copy of a copy (of a copy &#8230;)
          of a favorite audio or video cassette.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-2"></a>Using the APIs</h2></div></div><div></div></div><p>Developing applications against the Subversion library APIs
      is fairly straightforward.  All of the public header files live
      in the <tt class="filename">subversion/include</tt> directory of the
      source tree.  These headers are copied into your system
      locations when you build and install Subversion itself from
      source.  These headers represent the entirety of the functions
      and types meant to be accessible by users of the Subversion
      libraries.</p><p>The first thing you might notice is that Subversion's
      datatypes and functions are namespace protected.  Every public
      Subversion symbol name begins with <tt class="literal">"svn_"</tt>,
      followed by a short code for the library in which the symbol is
      defined (such as <tt class="literal">"wc"</tt>,
      <tt class="literal">"client"</tt>, <tt class="literal">"fs"</tt>, etc.),
      followed by a single underscore (<tt class="literal">"_"</tt>) and
      then the rest of the symbol name.  Semi-public functions (used
      among source files of a given library but not by code outside
      that library, and found inside the library directories
      themselves) differ from this naming scheme in that instead of a
      single underscore after the library code, they use a double
      underscore (<tt class="literal">"__"</tt>).  Functions that are private
      to a given source file have no special prefixing, and are declared
      <tt class="literal">static</tt>.  Of course, a compiler isn't
      interested in these naming conventions, but they definitely help
      to clarify the scope of a given function or datatype.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-2.1"></a>The Apache Portable Runtime Library</h3></div></div><div></div></div><p>Along with Subversion's own datatype, you will see many
        references to datatypes that begin with
        <tt class="literal">"apr_"</tt>&#8212;symbols from the Apache
        Portable Runtime (APR) library.  APR is Apache's portability
        library, originally carved out of its server code as an
        attempt to separate the OS-specific bits from the
        OS-independent portions of the code.  The result was a library
        that provides a generic API for performing operations that
        differ mildly&#8212;or wildly&#8212;from OS to OS.  While
        Apache HTTP Server was obviously the first user of the APR
        library, the Subversion developers immediately recognized the
        value of using APR as well.  This means that there are
        practically no OS-specific code portions in Subversion itself.
        Also, it means that the Subversion client compiles and runs
        anywhere that the server does.  Currently this list includes
        all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X.</p><p>In addition to providing consistent implementations of
        system calls that differ across operating systems,
        <sup>[<a name="id2929131" href="#ftn.id2929131">29</a>]</sup>
        APR gives Subversion immediate access to many custom
        datatypes, such as dynamic arrays and hash tables.  Subversion
        uses these types extensively throughout the codebase.  But
        perhaps the most pervasive APR datatype, found in nearly every
        Subversion API prototype, is the apr_pool_t&#8212;the APR
        memory pool.  Subversion uses pools internally for all its
        memory allocation needs (unless an external library requires a
        different memory management schema for data passed through its
        API),
        <sup>[<a name="id2929124" href="#ftn.id2929124">30</a>]</sup>
        and while a person coding against the Subversion APIs is
        not required to do the same, they are required to provide
        pools to the API functions that need them.  This means that
        users of the Subversion API must also link against APR, must
        call <tt class="function">apr_initialize()</tt> to initialize the
        APR subsystem, and then must acquire a pool for use with
        Subversion API calls.  See <a href="#svn-ch-7-sect-5" title="Programming with Memory Pools">the section called &#8220;Programming with Memory Pools&#8221;</a>
        for more information.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-2.2"></a>URL and Path Requirements</h3></div></div><div></div></div><p>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while "remote" might mean "across the office", it could
        just as well mean "across the globe."  To facilitate this, all
        of Subversion's public interfaces that accept path arguments
        expect those paths to be canonicalized, and encoded in UTF-8.
        This means, for example, that any new client binary that
        drives the libsvn_client interface needs to first convert
        paths from the locale-specific encoding to UTF-8 before
        passing those paths to the Subversion libraries, and then
        re-convert any resultant output paths from Subversion back
        into the locale's encoding before using those paths for
        non-Subversion purposes.  Fortunately, Subversion provides a
        suite of functions (see
        <tt class="filename">subversion/include/svn_utf.h</tt>) that can be
        used by any program to do these conversions.</p><p>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing <tt class="systemitem">file:///home/username/My File.txt</tt> as
        the URL of a file named <tt class="literal">My File.txt</tt>, you
        need to pass <tt class="systemitem">file:///home/username/My%20File.txt</tt>.
        Again, Subversion supplies helper functions that your
        application can
        use&#8212;<tt class="function">svn_path_uri_encode</tt> and
        <tt class="function">svn_path_uri_decode</tt>, for URI encoding and
        decoding, respectively.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-2.3"></a>Using Languages Other than C and C++</h3></div></div><div></div></div><p>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program&#8212;say a
        Python script or Java application&#8212;Subversion has some
        initial support for this via the Simplified Wrapper and
        Interface Generator (SWIG).  The SWIG bindings for Subversion
        are located in <tt class="filename">subversion/bindings/swig</tt>
        and are slowly maturing into a usable state.  These bindings
        allow you to call Subversion API functions indirectly, using
        wrappers that translate the datatypes native to your
        scripting language into the datatypes needed by Subversion's
        C libraries.</p><p>There is an obvious benefit to accessing the Subversion
        APIs via a language binding&#8212;simplicity.  Generally
        speaking, languages such as Python and Perl are much more
        flexible and easy to use than C or C++.  The sort of
        high-level datatypes and context-driven type checking provided
        by these languages are often better at handling information
        that comes from users.  As you know, only a human can botch up
        the input to a program as well as they do, and the
        scripting-type language simply handle that misinformation more
        gracefully.  Of course, often that flexibility comes at the
        cost of performance.  That is why using a tightly-optimized,
        C-based interface and library suite, combined with a powerful,
        flexible binding language is so appealing.</p><p>Let's look at an example that uses Subversion's Python
        SWIG bindings.  Our example will do the same thing as our last
        example.  Note the difference in size and complexity of the
        function this time!</p><div class="example"><a name="svn-ch-7-sect-2.3-ex-1"></a><p class="title"><b>Example 7.2. Using the Repository Layer with Python</b></p><pre class="programlisting">
from svn import fs
import os.path

def crawl_filesystem_dir (root, directory, pool):
  """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
  a list of all the paths at or below DIRECTORY.  Use POOL for all 
  allocations."""

  # Get the directory entries for DIRECTORY.
  entries = fs.dir_entries(root, directory, pool)

  # Initialize our returned list with the directory path itself.
  paths = [directory]

  # Loop over the entries
  names = entries.keys()
  for name in names:
    # Calculate the entry's full path.
    full_path = os.path.join(basepath, name)

    # If the entry is a directory, recurse.  The recursion will return
    # a list with the entry and all its children, which we will add to
    # our running list of paths.
    if fs.is_dir(fsroot, full_path, pool):
      subpaths = crawl_filesystem_dir(root, full_path, pool)
      paths.extend(subpaths)

    # Else, it is a file, so add the entry's full path to the FILES list.
    else:
      paths.append(full_path)

  return paths
</pre></div><p>An implementation in C of the previous example would
        stretch on quite a bit longer.  The same routine in C would
        need to pay close attention to memory usage, and need to use
        custom datatypes for representing the hash of entries and the
        list of paths.  Python has hashes and lists (called
        "dictionaries" and "sequences", respectively) as built-in
        datatypes, and provides a wonderful selection of methods for
        operating on those types.  And since Python uses reference
        counting and garbage collection, users of the language don't
        have to bother themselves with allocating and freeing
        memory.</p><p>In the previous section of this chapter, we mentioned the
        <tt class="filename">libsvn_client</tt> interface, and how it
        exists for the sole purpose of simplifying the process of
        writing a Subversion client.  The following is a brief example
        of how that library can be accessed via the SWIG bindings.  In
        just a few lines of Python, you can check out a fully
        functional Subversion working copy!</p><div class="example"><a name="svn-ch-7-sect-2.3-ex-2"></a><p class="title"><b>Example 7.3. A Simple Script to Check Out a Working Copy.</b></p><pre class="programlisting">
#!/usr/bin/env python
import sys
from svn import util, _util, _client

def usage():
  print "Usage: " + sys.argv[0] + " URL PATH\n"
  sys.exit(0)

def run(url, path):
  # Initialize APR and get a POOL.
  _util.apr_initialize()
  pool = util.svn_pool_create(None)

  # Checkout the HEAD of URL into PATH (silently)
  _client.svn_client_checkout(None, None, url, path, -1, 1, None, pool)

  # Cleanup our POOL, and shut down APR.
  util.svn_pool_destroy(pool)
  _util.apr_terminate()

if __name__ == '__main__':
  if len(sys.argv) != 3:
    usage()
  run(sys.argv[1], sys.argv[2])
</pre></div><p>Currently, it is Subversion's Python bindings that are the
        most complete.  Some attention is also being given to the Java
        bindings.  Once you have the SWIG interface files properly
        configured, generation of the specific wrappers for all the
        supported SWIG languages (which currently includes versions of
        Tcl, Python, Perl, Java, Ruby, Mzscheme, Guile, and PHP)
        should theoretically be trivial.  Still, some extra
        programming is required to compensate for complex APIs that
        SWIG needs some help generalizing.  For more information on
        SWIG itself, see the project's website at <tt class="systemitem">http://www.swig.org</tt>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-3"></a>Inside the Working Copy Administration Area</h2></div></div><div></div></div><p>As we mentioned earlier, each directory of a Subversion
      working copy contains a special subdirectory called
      <tt class="filename">.svn</tt> which houses administrative data about
      that working copy directory.  Subversion uses the information in
      <tt class="filename">.svn</tt> to keep track of things like:</p><div class="itemizedlist"><ul type="disc"><li><p>Which repository location(s) are represented by the
          files and subdirectories in the working copy
          directory.</p></li><li><p>What revision of each of those files and directories are
          currently present in the working copy.</p></li><li><p>Any user-defined properties that might be attached
          to those files and directories.</p></li><li><p>Pristine (un-edited) copies of the working copy
        files.</p></li></ul></div><p>While there are several other bits of data stored in the
      <tt class="filename">.svn</tt> directory, we will examine only a
      couple of the most important items.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-3.1"></a>The Entries File</h3></div></div><div></div></div><p>Perhaps the single most important file in the
        <tt class="filename">.svn</tt> directory is the
        <tt class="filename">entries</tt> file.  The entries file is an XML
        document which contains the bulk of the administrative
        information about a versioned resource in a working copy
        directory.  It is this one file which tracks the repository
        URLs, pristine revision, file checksums, pristine text and
        property timestamps, scheduling and conflict state
        information, last-known commit information (author, revision,
        timestamp), local copy history&#8212;practically everything
        that a Subversion client is interested in knowing about a
        versioned (or to-be-versioned) resource!</p><div class="sidebar"><p class="title"><b>Comparing the Administrative Areas of Subversion and
          CVS</b></p><p>A glance inside the typical <tt class="filename">.svn</tt>
          directory turns up a bit more than what CVS maintains in its
          <tt class="filename">CVS</tt> administrative directories.  The
          <tt class="filename">entries</tt> file contains XML which
          describes the current state of the working copy directory,
          and basically serves the purposes of CVS's
          <tt class="filename">Entries</tt>, <tt class="filename">Root</tt>, and
          <tt class="filename">Repository</tt> files combined.</p></div><p>The following is an example of an actual entries
        file:</p><div class="example"><a name="svn-ch-7-sect-3-ex-1"></a><p class="title"><b>Example 7.4. Contents of a Typical <tt class="filename">.svn/entries</tt>
          File</b></p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;wc-entries
   xmlns="svn:"&gt;
&lt;entry
   committed-rev="1"
   name="svn:this_dir"
   committed-date="2002-09-24T17:12:44.064475Z"
   url="http://svn.red-bean.com/tests/.greek-repo/A/D"
   kind="dir"
   revision="1"/&gt;
&lt;entry
   committed-rev="1"
   name="gamma"
   text-time="2002-09-26T21:09:02.000000Z"
   committed-date="2002-09-24T17:12:44.064475Z"
   checksum="QSE4vWd9ZM0cMvr7/+YkXQ=="
   kind="file"
   prop-time="2002-09-26T21:09:02.000000Z"/&gt;
&lt;entry
   name="zeta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   url="http://svn.red-bean.com/tests/.greek-repo/A/B/delta"
   name="delta"
   kind="file"
   schedule="add"
   revision="0"/&gt;
&lt;entry
   name="G"
   kind="dir"/&gt;
&lt;entry
   name="H"
   kind="dir"
   schedule="delete"/&gt;
&lt;/wc-entries&gt;
</pre></div><p>As you can see, the entries file is essentially a list of
        entries.  Each <tt class="sgmltag-element">entry</tt> tag represents one of
        three things: the working copy directory itself (noted by
        having its <i class="structfield"><tt>name</tt></i> attribute set to
        <tt class="literal">"svn:this-dir"</tt>), a file in that working
        copy directory (noted by having its
        <i class="structfield"><tt>kind</tt></i> attribute set to
        <tt class="literal">"file"</tt>), or a subdirectory in that working
        copy (<i class="structfield"><tt>kind</tt></i> here is set to
        <tt class="literal">"dir"</tt>).  The files and subdirectories whose
        entries are stored in this file are either already under
        version control, or (as in the case of the file named
        <tt class="filename">zeta</tt> above) are scheduled to be added to
        version control when the user next commits this working copy
        directory's changes.  Each entry has a unique name, and each
        entry has a node kind.</p><p>Developers should be aware of some special rules that
        Subversion uses when reading and writing its
        <tt class="filename">entries</tt> files.  While each entry has a
        revision and URL associated with it, note that not every
        <tt class="sgmltag-element">entry</tt> tag in the sample file has explicit
        <i class="structfield"><tt>revision</tt></i> or
        <i class="structfield"><tt>url</tt></i> attributes attached to it.
        Subversion allows entries to not explicitly store those two
        attributes when their values are the same as (in the
        <i class="structfield"><tt>revision</tt></i> case) or trivially
        calculable from
        <sup>[<a name="id2929942" href="#ftn.id2929942">31</a>]</sup>
        (in the <i class="structfield"><tt>url</tt></i> case) the data stored
        in the <tt class="literal">"svn:this-dir"</tt> entry.  Note also
        that for subdirectory entries, Subversion stores only the
        crucial attributes&#8212;name, kind, url, revision, and
        schedule.  In an effort to reduce duplicated information,
        Subversion dictates that the method for determining the full
        set of information about a subdirectory is to traverse down
        into that subdirectory, and read the
        <tt class="literal">"svn:this-dir"</tt> entry from its own
        <tt class="filename">.svn/entries</tt> file.  However, a reference
        to the subdirectory is kept in its parent's
        <tt class="filename">entries</tt> file, with enough information to
        permit basic versioning operations in the event that the
        subdirectory itself is actually missing from disk.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-3.2"></a>Pristine Copies and Property Files</h3></div></div><div></div></div><p>As mentioned before, the <tt class="filename">.svn</tt>
        directory also holds the pristine "text-base" versions of
        files.  Those can be found in
        <tt class="filename">.svn/text-base</tt>.  The benefits of these
        pristine copies are multiple&#8212;network-free checks for
        local modifications and "diff" reporting, network-free
        reversion of modified or missing files, smaller transmission
        of changes to the server&#8212;but comes at the cost of having
        each versioned file stored at least twice on disk.  These
        days, this seems to be a negligible penalty for most files.
        However, the situation gets uglier as the size of your
        versioned files grows.  Some attention is being given to
        making the presence of the "text-base" an option.  Ironically
        though, it is as your versioned files' sizes get larger that
        the existence of the "text-base" becomes more
        crucial&#8212;who wants to transmit a huge file across a
        network just because they want to commit a tiny change to
        it?</p><p>Similar in purpose to the "text-base" files are the
        property files and their pristine "prop-base" copies, located
        in <tt class="filename">.svn/props</tt> and
        <tt class="filename">.svn/prop-base</tt> respectively.  Since
        directories can have properties, too, there are also
        <tt class="filename">.svn/dir-props</tt> and
        <tt class="filename">.svn/dir-prop-base</tt> files.  Each of these
        property files ("working" and "base" versions) uses a simple
        "hash-on-disk" file format for storing the property names and
        values.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-4"></a>WebDAV</h2></div></div><div></div></div><p>WebDAV ("Web-based Distributed Authoring and Versioning") is
      an extension of the standard HTTP protocol designed to make the
      web into a read/write medium, instead of the basically read-only
      medium that exists today.  The theory is that directories and
      files can be shared&#8212;as both readable and writable
      objects&#8212;over the web.  RFCs 2518 and 3253 describe the
      WebDAV/DeltaV extensions to HTTP, and are available (along with
      a lot of other useful information) at <tt class="systemitem">http://www.webdav.org/</tt>.</p><p>A number of operating system file browsers are already able
      to mount networked directories using WebDAV.  On Win32, the
      Windows Explorer can browse what it calls "WebFolders" (which
      are just WebDAV-ready network locations) as if they were regular
      shared folders.  Mac OS X also has this capability, as do the
      Nautilus and Konqueror browsers (under GNOME and KDE,
      respectively).</p><p>How does all of this apply to Subversion?  The mod_dav_svn
      Apache module uses HTTP, extended by WebDAV and DeltaV, as its
      primary network protocol.  Rather than implementing a new
      proprietary protocol, the original Subversion designers decided
      to simply map the versioning concepts and actions used by
      Subversion onto the concepts exposed by RFCs 2518 and 3253.
      <sup>[<a name="id2930183" href="#ftn.id2930183">32</a>]</sup>
    </p><p>For a more thorough discussion of WebDAV, how it works, and
      how Subversion uses it, see <a href="#svn-ap-d" title="Appendix D. WebDAV and Autoversioning">Appendix D, <i>WebDAV and Autoversioning</i></a>.  Among
      other things, that appendix discusses the degree to which
      Subversion adheres to the generic WebDAV specification, and how
      that affects interoperability with generic WebDAV
      clients.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-5"></a>Programming with Memory Pools</h2></div></div><div></div></div><p>Almost every developer who has used the C programming
      language has at some point sighed at the daunting task of
      managing memory usage.  Allocating enough memory to use, keeping
      track of those allocations, freeing the memory when you no
      longer need it&#8212;these tasks can be quite complex.  And of
      course, failure to do those things properly can result in a
      program that crashes itself, or worse, crashes the computer.
      Fortunately, the APR library that Subversion depends on for
      portability provides the <span class="structname">apr_pool_t</span>
      type, which represents a "pool" of memory.</p><p>A memory pool is an abstract representation of a chunk of
      memory allocated for use by a program.  Rather than requesting
      memory directly from the OS using the standard
      <tt class="function">malloc()</tt> and friends, programs that link
      against APR can simply request that a pool of memory be created
      (using the <tt class="function">apr_pool_create()</tt> function).
      APR will allocate a moderately sized chunk of memory from the
      OS, and that memory will be instantly available for use by the
      program.  Any time the program needs some of the pool memory, it
      uses one of the APR pool API functions, like
      <tt class="function">apr_palloc()</tt>, which returns a generic
      memory location from the pool.  The program can keep requesting
      bits and pieces of memory from the pool, and APR will keep
      granting the requests.  Pools will automatically grow in size to
      accommodate programs that request more memory than the original
      pool contained, until of course there is no more memory
      available on the system.</p><p>Now, if this were the end of the pool story, it would hardly
      have merited special attention.  Fortunately, that's not the
      case.  Pools can not only be created; they can also be cleared
      and destroyed, using <tt class="function">apr_pool_clear()</tt> and
      <tt class="function">apr_pool_destroy()</tt> respectively.  This
      gives developers the flexibility to allocate several&#8212;or
      several thousand&#8212; things from the pool, and then clean up
      all of that memory with a single function call!  Further, pools
      have hierarchy.  You can make "subpools" of any previously
      created pool.  When you clear a pool, all of its subpools are
      destroyed; if you destroy a pool, it and its subpools are
      destroyed.</p><p>Before we go further, developers should be aware that they
      probably will not find many calls to the APR pool functions we
      just mentioned in the Subversion source code.  APR pools offer
      some extensibility mechanisms, like the ability to have custom
      "user data" attached to the pool, and mechanisms for registering
      cleanup functions that get called when the pool is destroyed.
      Subversion makes use of these extensions in a somewhat
      non-trivial way.  So, Subversion supplies (and most of its code
      uses) the wrapper functions
      <tt class="function">svn_pool_create()</tt>,
      <tt class="function">svn_pool_clear()</tt>, and
      <tt class="function">svn_pool_destroy()</tt>.</p><p>While pools are helpful for basic memory management, the
      pool construct really shines in looping and recursive scenarios.
      Since loops are often unbounded in their iterations, and
      recursions in their depth, memory consumption in these areas of
      the code can become unpredictable.  Fortunately, using nested
      memory pools can be a great way to easily manage these
      potentially hairy situations.  The following example
      demonstrates the basic use of nested pools in a situation that
      is fairly common&#8212;recursively crawling a directory tree,
      doing some task to each thing in the tree.</p><div class="example"><a name="svn-ch-7-sect-5-ex-1"></a><p class="title"><b>Example 7.5. Effective Pool Usage</b></p><pre class="programlisting">
/* Recursively crawl over DIRECTORY, adding the paths of all its file
   children to the FILES array, and doing some task to each path
   encountered.  Use POOL for the all temporary allocations, and store
   the hash paths in the same pool as the hash itself is allocated in.  */
static apr_status_t 
crawl_dir (apr_array_header_t *files,
           const char *directory,
           apr_pool_t *pool)
{
  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */
  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */
  apr_dir_t *dir;
  apr_finfo_t finfo;
  apr_status_t apr_err;
  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;

  apr_err = apr_dir_open (&amp;dir, directory, pool);
  if (apr_err)
    return apr_err;

  /* Loop over the directory entries, clearing the subpool at the top of
     each iteration.  */
  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);
       apr_err == APR_SUCCESS;
       apr_err = apr_dir_read (&amp;finfo, flags, dir))
    {
      const char *child_path;

      /* Skip entries for "this dir" ('.') and its parent ('..').  */
      if (finfo.filetype == APR_DIR)
        {
          if (finfo.name[0] == '.'
              &amp;&amp; (finfo.name[1] == '\0'
                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\0')))
            continue;
        }

      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */
      child_path = svn_path_join (directory, finfo.name, subpool);

      /* Do some task to this encountered path. */
      do_some_task (child_path, subpool);

      /* Handle subdirectories by recursing into them, passing SUBPOOL
         as the pool for temporary allocations.  */
      if (finfo.filetype == APR_DIR)
        {
          apr_err = crawl_dir (files, child_path, subpool);
          if (apr_err)
            return apr_err;
        }

      /* Handle files by adding their paths to the FILES array.  */
      else if (finfo.filetype == APR_REG)
        {
          /* Copy the file's path into the FILES array's pool.  */
          child_path = apr_pstrdup (hash_pool, child_path);

          /* Add the path to the array.  */
          (*((const char **) apr_array_push (files))) = child_path;
        }

      /* Clear the per-iteration SUBPOOL.  */
      svn_pool_clear (subpool);
    }

  /* Check that the loop exited cleanly. */
  if (apr_err)
    return apr_err;

  /* Yes, it exited cleanly, so close the dir. */
  apr_err = apr_dir_close (dir);
  if (apr_err)
    return apr_err;

  /* Destroy SUBPOOL.  */
  svn_pool_destroy (subpool);

  return APR_SUCCESS;
}
</pre></div><p>The previous example demonstrates effective pool usage in
      <span class="emphasis"><em>both</em></span> looping and recursive situations.
      Each recursion begins by making a subpool of the pool passed to
      the function.  This subpool is used for the looping region, and
      cleared with each iteration.  The result is memory usage is
      roughly proportional to the depth of the recursion, not to total
      number of file and directories present as children of the
      top-level directory.  When the first call to this recursive
      function finally finishes, there is actually very little data
      stored in the pool that was passed to it.  Now imagine the extra
      complexity that would be present if this function had to
      <tt class="function">alloc()</tt> and <tt class="function">free()</tt>
      every single piece of data used!</p><p>Pools might not be ideal for every application, but they are
      extremely useful in Subversion.  As a Subversion developer,
      you'll need to grow comfortable with pools and how to wield them
      correctly.  Memory usage bugs and bloating can be difficult to
      diagnose and fix regardless of the API, but the pool construct
      provided by APR has proven a tremendously convenient,
      time-saving bit of functionality.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-7-sect-6"></a>Contributing to Subversion</h2></div></div><div></div></div><p>The official source of information about the Subversion
      project is, of course, the project's website at <tt class="systemitem">http://subversion.tigris.org</tt>.  There
      you can find information about getting access to the source code
      and participating on the discussion lists.  The Subversion
      community always welcomes new members.  If you are
      interested in participating in this community by contributing
      changes to the source code, here are some hints on how to get
      started.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-6.1"></a>Join the Community</h3></div></div><div></div></div><p>The first step in community participation is to find a way
        to stay on top of the latest happenings.  To do this most
        effectively, you will want to subscribe to the main developer
        discussion list (<tt class="email">&lt;<a href="mailto:dev@subversion.tigris.org">dev@subversion.tigris.org</a>&gt;</tt>) and
        commit mail list (<tt class="email">&lt;<a href="mailto:svn@subversion.tigris.org">svn@subversion.tigris.org</a>&gt;</tt>).
        By following these lists even loosely, you will have access
        to important design discussions, be able to see actual changes
        to Subversion source code as they occur, and be able to
        witness peer reviews of those changes and proposed changes.
        These email based discussion lists are the primary
        communication media for Subversion development.  See the
        Mailing Lists section of the website for other
        Subversion-related lists you might be interested in.</p><p>But how do you know what needs to be done?  It is quite
        common for a programmer to have the greatest intentions of
        helping out with the development, yet be unable to find a
        good starting point.  After all, not many folks come to the
        community having already decided on a particular itch they
        would like to scratch.  But by watching the developer
        discussion lists, you might see mentions of existing bugs or
        feature requests fly by that particularly interest
        you.  Also, a great place to look for outstanding, unclaimed
        tasks is the Issue Tracking database on the Subversion
        website.  There you will find the current list of known bugs
        and feature requests.  If you want to start with something
        small, look for issues marked as "bite-sized".</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-6.2"></a>Get the Source Code</h3></div></div><div></div></div><p>To edit the code, you need to have the code.  This means
        you need to check out a working copy from the public
        Subversion source repository.  As straightforward as that
        might sound, the task can be slightly tricky.  Because
        Subversion's source code is versioned using Subversion itself,
        you actually need to "bootstrap" by getting a working
        Subversion client via some other method.  The most common
        methods include downloading the latest binary distribution (if
        such is available for your platform), or downloading the
        latest source tarball and building your own Subversion client.
        If you build from source, make sure to read the INSTALL file in
        the top level of the source tree for instructions.</p><p>After you have a working Subversion client, you are now
        poised to checkout a working copy of the Subversion source
        repository from <tt class="systemitem">http://svn.collab.net/repos/svn/trunk</tt>:
        <sup>[<a name="id2930761" href="#ftn.id2930761">33</a>]</sup></p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk subversion
A  HACKING
A  INSTALL
A  README
A  autogen.sh
A  build.conf
...
</pre><p>The above command will checkout the bleeding-edge, latest
        version of the Subversion source code into a subdirectory
        named <tt class="filename">subversion</tt> in your current working
        directory.  Obviously, you can adjust that last argument as
        you see fit.  Regardless of what you call the new working copy
        directory, though, after this operation completes, you will
        now have the Subversion source code.  Of course, you will
        still need to fetch a few helper libraries (apr, apr-util,
        etc.)&#8212;see the INSTALL file in the top level of the
        working copy for details.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-6.3"></a>Become Familiar with Community Policies</h3></div></div><div></div></div><p>Now that you have a working copy containing the latest
        Subversion source code, you will most certainly want to take a
        cruise through the HACKING file in that working copy's
        top-level directory.  The HACKING file contains general
        instructions for contributing to Subversion, including how to
        properly format your source code for consistency with the rest
        of the codebase, how to describe your proposed changes with an
        effective change log message, how to test your changes, and so
        on.  Commit privileges on the Subversion source repository are
        earned&#8212;a government by meritocracy.
        <sup>[<a name="id2930817" href="#ftn.id2930817">34</a>]</sup>
        The HACKING file is an invaluable resource when it comes to 
        making sure that your proposed changes earn the praises they
        deserve without being rejected on technicalities.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-6.4"></a>Make and Test Your Changes</h3></div></div><div></div></div><p>With the code and community policy understanding in hand,
        you are ready to make your changes.  It is best to try to make
        smaller but related sets of changes, even tackling larger
        tasks in stages, instead of making huge, sweeping
        modifications.  Your proposed changes will be easier to
        understand (and therefore easier to review) if you disturb
        the fewest lines of code possible to accomplish your task
        properly.  After making each set of proposed changes, your
        Subversion tree should be in a state in which the software
        compiles with no warnings.</p><p>Subversion has a fairly thorough
        <sup>[<a name="id2930915" href="#ftn.id2930915">35</a>]</sup>
        regression test suite, and your proposed changes are expected
        to not cause any of those tests to fail.  By running
        <span><b class="command">make check</b></span> (in Unix) from the top of the
        source tree, you can sanity-check your changes.  The fastest
        way to get your code contributions rejected (other than
        failing to supply a good log message) is to submit changes
        that cause failure in the test suite.</p><p>In the best-case scenario, you will have actually added
        appropriate tests to that test suite which verify that your
        proposed changes actually work as expected.  In fact,
        sometimes the best contribution a person can make is solely
        the addition of new tests.  You can write regression tests for
        functionality that currently works in Subversion as a way to
        protect against future changes that might trigger failure in
        those areas.  Also, you can write new tests that demonstrate
        known failures.  For this purpose, the Subversion test suite
        allows you to specify that a given test is expected to fail
        (called an <tt class="literal">XFAIL</tt>), and so long as
        Subversion fails in the way that was expected, a test result
        of XFAIL itself is considered a success.  Ultimately, the
        better the test suite, the less time wasted on diagnosing
        potentially obscure regression bugs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-7-sect-6.5"></a>Donate Your Changes</h3></div></div><div></div></div><p>After making your modifications to the source code,
        compose a clear and concise log message to describe those
        changes and the reasons for them.  Then, send an email to the
        developers list containing your log message and the output of
        <span><b class="command">svn diff</b></span> (from the top of your Subversion
        working copy).  If the community members consider your changes
        acceptable, someone who has commit privileges (permission to
        make new revisions in the Subversion source repository) will
        add your changes to the public source code tree.  Recall that
        permission to directly commit changes to the repository is
        granted on merit&#8212;if you demonstrate comprehension of
        Subversion, programming competency, and a "team spirit", you
        will likely be awarded that permission.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2926932" href="#id2926932">27</a>] </sup>The choice of Berkeley DB brought several automatic
            features that Subversion needed, such as data integrity,
            atomic writes, recoverability, and hot backups.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2927046" href="#id2927046">28</a>] </sup>We understand that this may come as a shock to sci-fi
            fans who have long been under the impression that Time was
            actually the <span class="emphasis"><em>fourth</em></span> dimension, and we
            apologize for any emotional trauma induced by our
            assertion of a different theory.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2929131" href="#id2929131">29</a>] </sup>Subversion uses ANSI system calls and datatypes as much
            as possible.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2929124" href="#id2929124">30</a>] </sup>Neon and Berkeley DB are examples of such libraries.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2929942" href="#id2929942">31</a>] </sup>That is, the URL for the entry is the same as the
            concatenation of the parent directory's URL and the
            entry's name.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2930183" href="#id2930183">32</a>] </sup>As it turns out, Subversion has more recently evolved a
          proprietary protocol anyway, implemented by the libsvn_ra_svn
          module.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2930761" href="#id2930761">33</a>] </sup>Note that the URL checked out in the example above
            ends not with <tt class="literal">svn</tt>, but with a
            subdirectory thereof called <tt class="literal">trunk</tt>.  See
            our discussion of Subversion's branching and tagging model
            for the reasoning behind this.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2930817" href="#id2930817">34</a>] </sup>While this may superficially appear as some sort of
            elitism, this "earn your commit privileges" notion is
            about efficiency&#8212;whether it costs more in time and
            effort to review and apply someone else's changes that are
            likely to be safe and useful, versus the potential costs
            of undoing changes that are dangerous.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2930915" href="#id2930915">35</a>] </sup>You might want to grab some popcorn.  "Thorough", in
            this instance, translates to somewhere around thirty
            minutes of non-interactive machine churn.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-8"></a>Chapter 8. Subversion Complete Reference</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-8-sect-1">The Subversion Command Line Client:
      svn</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-1.1">svn Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-1.2">svn Subcommands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-2">svnadmin</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-2.1">svnadmin Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-2.2">svnadmin Subcommands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-3">svnlook</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-3.1">svnlook Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-3.2">svnlook Subcommands</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>This chapter is intended to be a complete reference to using
      Subversion. This includes the command line client
      (<span><b class="command">svn</b></span>) and all its subcommands, as well as the
      repository administration programs (<span><b class="command">svnadmin</b></span>
      and <span><b class="command">svnlook</b></span>) and their respective subcommands.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-8-sect-1"></a>The Subversion Command Line Client:
      <span><b class="command">svn</b></span></h2></div></div><div></div></div><p>To use the command line client, you type
      <span><b class="command">svn</b></span>, the subcommand you wish to use
      <sup>[<a name="id2934587" href="#ftn.id2934587">36</a>]</sup>, and any switches or targets that
      you wish to operate on&#8212;there is no specific order that the
      subcommand and the switches must appear in.  For example, all of
      the following are valid ways to use <span><b class="command">svn
      status</b></span>:</p><pre class="screen">
$ svn -v status
$ svn status -v 
$ svn status -v myfile
    </pre><p>You can find many more examples of how to use most client
      commands in <a href="#svn-ch-3" title="Chapter 3. Guided Tour">Chapter 3, <i>Guided Tour</i></a> and commands for managing
      properties in <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-1.1"></a><span><b class="command">svn</b></span> Switches</h3></div></div><div></div></div><p>While Subversion has different switches for its
        subcommands, all switches are global&#8212;that is, each
        switch is guaranteed to mean the same thing regardless of
        the subcommand you use it with.  For example,
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) always
        means &#8220;<span class="quote">verbose output</span>&#8221;, regardless of the
        subcommand you use it with.</p><div class="variablelist"><dl><dt><span class="term"><tt class="option">--diff-cmd</tt>
            <i class="replaceable"><tt>CMD</tt></i></span></dt><dd><p>Specifies an external program to use to show
            differences between files.  When <span><b class="command">svn
            diff</b></span> is invoked, it uses Subversion's internal
            diff engine, which provides unified diffs by default.  If
            you want to use an external diff program, use
            <tt class="option">--diff-cmd</tt>.  You can pass switches to the
            diff program with the <tt class="option">--extensions</tt>
            switch (more on that later in this section).</p></dd><dt><span class="term"><tt class="option">--diff3-cmd</tt>
            <i class="replaceable"><tt>CMD</tt></i></span></dt><dd><p>Specifies an external program to use to merge files.</p></dd><dt><span class="term"><tt class="option">--dry-run</tt></span></dt><dd><p>Goes through all the motions of running a command,
              but makes no actual changes&#8212;either on disk or in
              the repository. </p></dd><dt><span class="term"><tt class="option">--editor-cmd</tt>
            <i class="replaceable"><tt>CMD</tt></i></span></dt><dd><p>Specifies an external program to use to edit a log message
              or a property value.</p></dd><dt><span class="term"><tt class="option">--encoding</tt> <i class="replaceable"><tt>ENC</tt></i></span></dt><dd><p>Tells Subversion that your commit message is encoded
              in the charset provided.  The default is your operating
              system's native locale, and you should specify the
              encoding if your commit message is in any other
              encoding.</p></dd><dt><span class="term"><tt class="option">--extensions</tt> (<tt class="option">-x</tt>)
          <i class="replaceable"><tt>"ARGS"</tt></i></span></dt><dd><p>Specifies an argument or arguments that Subversion
              should pass to an external diff command when providing
              differences between files.  If you wish to pass multiple
              arguments, you must enclose all of them in quotes (for
              example, <span><b class="command">svn diff --diff-cmd /usr/bin/diff -x
              "-b -E"</b></span>).  This switch can
              <span class="emphasis"><em>only</em></span> be used if you also pass the
              <tt class="option">--diff-cmd</tt> switch.</p></dd><dt><span class="term"><tt class="option">--file</tt> (<tt class="option">-F</tt>)
            <i class="replaceable"><tt>FILENAME</tt></i>
          </span></dt><dd><p>Uses the contents of the file passed as an argument
              to this switch for the specified subcommand.</p></dd><dt><span class="term"><tt class="option">--force</tt></span></dt><dd><p>Forces a particular command or operation to run.
              There are some operations that Subversion will prevent
              you from doing in normal usage, but you can pass the
              force switch to tell Subversion &#8220;<span class="quote">I know what I'm
              doing as well as the possible repercussions of doing it,
              so let me at 'em</span>&#8221;. This switch is the
              programmatic equivalent of doing your own electrical
              work with the power on&#8212;if you don't know what
              you're doing, you're likely to get a nasty shock.</p></dd><dt><span class="term"><tt class="option">--force-log</tt></span></dt><dd><p>Forces a suspicious parameter passed to the
              <tt class="option">--message</tt> (<tt class="option">-m</tt>) or
              <tt class="option">--file</tt> (<tt class="option">-F</tt>) options to
              be accepted as valid.  By default, Subversion will
              produce an error if parameters to these options look
              like they might instead be targets of the subcommand.
              For example, if you pass a versioned file's path to the
              <tt class="option">--file</tt> (<tt class="option">-F</tt>) option,
              Subversion will assume you've made a mistake, that the
              path was instead intended as the target of the
              operation, and that you simply failed to provide some
              other&#8212;unversioned&#8212;file as the source of your log
              message.  To assert your intent and override these types
              of errors, pass the <tt class="option">--force-log</tt> option 
              to commands that accept log messages.</p></dd><dt><span class="term"><tt class="option">--help</tt> (<tt class="option">-h</tt> or
                <tt class="option">-?</tt>)
          </span></dt><dd><p>If used with one or more subcommands, shows the
              built-in help text for each subcommand.  If used alone,
              it displays the general client help text.</p></dd><dt><span class="term"><tt class="option">--notice-ancestry</tt></span></dt><dd><p>Pay attention to ancestry when calculating 
              differences.</p></dd><dt><span class="term"><tt class="option">--incremental</tt></span></dt><dd><p>Prints output in a format suitable for
              concatenation.</p></dd><dt><span class="term"><tt class="option">--message</tt> (<tt class="option">-m</tt>)
            <i class="replaceable"><tt>MESSAGE</tt></i>
          </span></dt><dd><p>Indicates that you will specify a commit message
              on the command line, following this switch. For
              example:</p><pre class="screen">
$ svn commit -m "They don't make Sunday."
            </pre></dd><dt><span class="term"><tt class="option">--new</tt> <i class="replaceable"><tt>ARG</tt></i></span></dt><dd><p>Uses ARG as the newer target.</p></dd><dt><span class="term"><tt class="option">--no-auth-cache</tt></span></dt><dd><p>Prevents caching of authentication information
              (e.g. username and password) in the Subversion
              administrative directories.</p></dd><dt><span class="term"><tt class="option">--no-diff-deleted</tt></span></dt><dd><p>Prevents Subversion from printing differences for
              deleted files.  The default behavior when you remove a
              file is for <span><b class="command">svn diff</b></span> to print the
              same differences that you would see if you had left
              the file but removed all the content.</p></dd><dt><span class="term"><tt class="option">--no-ignore</tt></span></dt><dd><p>Shows files in the status listing that would
              normally be omitted since they match a pattern in the
              svn:ignore property. See <a href="#svn-ch-6-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a> for more
              information.</p></dd><dt><span class="term"><tt class="option">--non-interactive</tt></span></dt><dd><p>In the case of an authentication failure, or
            insufficient credentials, prevents prompting for credentials
            (e.g. username or password).  This is useful if you're
            running Subversion inside of an automated script and it's
            more appropriate to have Subversion fail than to prompt
            for more information.</p></dd><dt><span class="term"><tt class="option">--non-recursive</tt> (<tt class="option">-N</tt>)</span></dt><dd><p>Stops a subcommand from recursing into
              subdirectories.  Most subcommands recurse by default,
              but some subcommands&#8212;usually those that have the
              potential to remove or undo your local
              modifications&#8212;do not.</p></dd><dt><span class="term"><tt class="option">--old</tt> <i class="replaceable"><tt>ARG</tt></i></span></dt><dd><p>Uses ARG as the older target.</p></dd><dt><span class="term"><tt class="option">--password</tt>
            <i class="replaceable"><tt>PASS</tt></i></span></dt><dd><p>Indicates that you are providing your password for
              authentication on the command line&#8212;otherwise, if
              it is needed, Subversion will prompt you for
              it.</p></dd><dt><span class="term"><tt class="option">--quiet</tt> (<tt class="option">-q</tt>)</span></dt><dd><p>Requests that the client print only essential
              information while performing an operation.</p></dd><dt><span class="term"><tt class="option">--recursive</tt> (<tt class="option">-R</tt>)</span></dt><dd><p>Makes a subcommand recurse into subdirectories.
              Most subcommands recurse by default.</p></dd><dt><span class="term"><tt class="option">--relocate</tt> <i class="replaceable"><tt>FROM TO
          [PATH...]</tt></i></span></dt><dd><p>Used with the <span><b class="command">svn switch</b></span>
              subcommand, changes the location of the repository that
              your working copy references.  This is useful if the
              location of your repository changes and you have an
              existing working copy that you'd like to continue to
              use.  See <span><b class="command">svn switch</b></span> for an
              example.</p></dd><dt><span class="term"><tt class="option">--revision</tt> (<tt class="option">-r</tt>)
            <i class="replaceable"><tt>REV</tt></i>
          </span></dt><dd><p>Indicates that you're going to supply a revision (or
              range of revisions) for a particular operation.  You can
              provide revision numbers, revision keywords or dates (in
              curly braces), as arguments to the revision switch.  If
              you wish to provide a range of revisions, you can
              provide two revisions separated by a colon. For
              example:</p><pre class="screen">
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {12/04/01}:{2/17/02}
$ svn log -r 1729:{2/17/02}
            </pre><p>See <a href="#svn-ch-3-sect-3.2" title="Revision Keywords">the section called &#8220;Revision Keywords&#8221;</a> for more
              information.</p></dd><dt><span class="term"><tt class="option">--revprop</tt></span></dt><dd><p>Operates on a revision property instead of a
              Subversion property specific to a file or directory.
              This switch requires that you also pass a revision
              with the <tt class="option">--revision</tt>
              (<tt class="option">-r</tt>) switch. See <a href="#svn-ch-5-sect-1.2" title="Unversioned Properties">the section called &#8220;Unversioned Properties&#8221;</a> for more details on
              unversioned properties.</p></dd><dt><span class="term"><tt class="option">--show-updates</tt> (<tt class="option">-u</tt>)</span></dt><dd><p>Causes the client to display information about
              which files in your working copy are out-of-date.
              This doesn't actually update any of your
              files&#8212;it just shows you which files will be
              updated if you run <span><b class="command">svn update </b></span>.
            </p></dd><dt><span class="term"><tt class="option">--strict</tt></span></dt><dd><p>Causes Subversion to use strict semantics.  By
            default, the log subcommand will cross copy boundaries
            when generating output for a file&#8212;using this
            switch makes log output log messages that
            &#8220;<span class="quote">strictly</span>&#8221; belong to the path
            specified.</p></dd><dt><span class="term"><tt class="option">--targets</tt>
            <i class="replaceable"><tt>FILENAME</tt></i></span></dt><dd><p>Tells Subversion to get the list of files that you
              wish to operate on from the filename you provide
              instead of listing all the files on the command line.
            </p></dd><dt><span class="term"><tt class="option">--username</tt>
            <i class="replaceable"><tt>NAME</tt></i></span></dt><dd><p>Indicates that you are providing your username for
              authentication on the command line&#8212;otherwise, if
              it is needed, Subversion will prompt you for
              it.</p></dd><dt><span class="term"><tt class="option">--verbose</tt> (<tt class="option">-v</tt>)</span></dt><dd><p>Requests that the client print out as much
              information as it can while running any subcommand.
              This may result in Subversion printing out additional
              fields, detailed information about every file, or
              additional information regarding its actions.</p></dd><dt><span class="term"><tt class="option">--version</tt></span></dt><dd><p>Prints the client version info.  This information
              not only includes the version number of the client,
              but also a listing of all repository access modules
              that the client can use to access a Subversion
              repository.</p></dd><dt><span class="term"><tt class="option">--xml</tt></span></dt><dd><p>Prints output in XML format.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-1.2"></a><span><b class="command">svn</b></span> Subcommands</h3></div></div><div></div></div><div class="refentry" lang="en"><a name="id2935809"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn add &#8212; Adds files and directories</p></div><div class="refsect1" lang="en"><a name="id2935826"></a><h2>Synopsis</h2><pre class="programlisting">svn add PATH...</pre></div><div class="refsect1" lang="en"><a name="id2935841"></a><h2>Description</h2><p>Adds files and directories to your working copy and
            schedules them for addition to the repository.  They
            will be uploaded and added to the repository on your
            next commit.  If you add something and change your mind
            before committing, you can unschedule the addition using
            <span><b class="command">svn revert</b></span>.</p></div><div class="refsect1" lang="en"><a name="id2935869"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2935883"></a><h2>Changes</h2><p>Working Copy</p></div><div class="refsect1" lang="en"><a name="id2935897"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--non-recursive (-N)
--quiet (-q)
          </pre></div><div class="refsect1" lang="en"><a name="id2935912"></a><h2>Examples</h2><p>To add a file to your working copy:</p><pre class="screen">
$ svn add foo.c 
A         foo.c
          </pre><p>When adding a directory, the default behavior of
            <span><b class="command">svn add</b></span> is to recurse:</p><pre class="screen">
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
          </pre><p>You can add a directory without adding its
            contents:</p><pre class="screen">
$ svn add --non-recursive otherdir
A         otherdir
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2935971"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn cat &#8212; Outputs the contents of the specified files or URLs.</p></div><div class="refsect1" lang="en"><a name="id2935989"></a><h2>Synopsis</h2><pre class="programlisting">svn cat TARGET...</pre></div><div class="refsect1" lang="en"><a name="id2936003"></a><h2>Description</h2><p>Outputs the contents of the specified files or URLs.
            For listing the contents of directories, see <span><b class="command">svn
            list</b></span>.</p></div><div class="refsect1" lang="en"><a name="id2936027"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2936041"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2936055"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2936069"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--username USER
--password PASS
          </pre></div><div class="refsect1" lang="en"><a name="id2936084"></a><h2>Examples</h2><p>If you want to view readme.txt in your repository
            without checking it out:</p><pre class="screen">
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
You should read this.
          </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If your working copy is out of date (or you have
            local modifications) and you want to see the HEAD
            revision of a file in your working copy, <span><b class="command">svn
            cat</b></span> will automatically fetch the HEAD revision
            when you give it a path:</p></div><pre class="screen">
$ cat foo.c
This file is in my local working copy 
and has changes that I've made.

$ svn cat foo.c
Latest revision fresh from the repository!
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2936142"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn checkout &#8212; Checks out a working copy from a repository.</p></div><div class="refsect1" lang="en"><a name="id2936159"></a><h2>Synopsis</h2><pre class="programlisting">svn checkout URL... [PATH]</pre></div><div class="refsect1" lang="en"><a name="id2936174"></a><h2>Description</h2><p>Checks out a working copy from a repository. If
            <i class="replaceable"><tt>PATH</tt></i> is omitted, the
            basename of the URL will be used as the
            destination. If multiple URLs are given each will be
            checked out into a sub-directory of PATH, with the
            name of the sub-directory being the basename of the
            URL.</p></div><div class="refsect1" lang="en"><a name="id2936199"></a><h2>Alternate Names</h2><p>co</p></div><div class="refsect1" lang="en"><a name="id2936213"></a><h2>Changes</h2><p>Creates a working copy.</p></div><div class="refsect1" lang="en"><a name="id2936227"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2936241"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2936257"></a><h2>Examples</h2><p>Check out a working copy into a directory called
            'mine':</p><pre class="screen">
$ svn checkout file:///tmp/repos/test mine
A  mine/a
A  mine/b
Checked out revision 2.
$ ls
mine
          </pre><p>Check out 2 different directories into two separate
            working copies:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz
A  test/a
A  test/b
Checked out revision 2.
A  quiz/l
A  quiz/m
Checked out revision 2.
$ ls
quiz  test
          </pre><p>Check out 2 different directories into two separate
            working copies, but place both into a directory called
            'working copies':</p><pre class="screen">
$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies
A  working-copies/test/a
A  working-copies/test/b
Checked out revision 2.
A  working-copies/quiz/l
A  working-copies/quiz/m
Checked out revision 2.
$ ls
working-copies
          </pre><p>If you interrupt a checkout (or something else
            interrupts your checkout like loss of connectivity, etc.),
            you can restart it either by issuing the
            identical checkout command again, or by updating the
            incomplete working copy:</p><pre class="screen">
$ svn checkout file:///tmp/repos/test test
A  test/a
A  test/b
^C
svn: The operation was interrupted
svn: caught SIGINT

$ svn checkout file:///tmp/repos/test test
A  test/c
A  test/d
^C
svn: The operation was interrupted
svn: caught SIGINT

$ cd test
$ svn update
A  test/e
A  test/f
Updated to revision 3.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2936337"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn cleanup &#8212; Recursively clean up the working copy.</p></div><div class="refsect1" lang="en"><a name="id2936355"></a><h2>Synopsis</h2><pre class="programlisting">svn cleanup [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2936369"></a><h2>Description</h2><p>Recursively clean up the working copy, removing
            locks resuming unfinished operations.  If you ever get a
            &#8220;<span class="quote">working copy locked</span>&#8221; error, run this
            command to remove stale locks and get your working copy
            into a usable state again.  See <a href="#svn-ap-c" title="Appendix C. Troubleshooting">Appendix C, <i>Troubleshooting</i></a>.</p></div><div class="refsect1" lang="en"><a name="id2936400"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2936414"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2936428"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="en"><a name="id2936442"></a><h2>Switches:</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2936456"></a><h2>Examples</h2><p>Well, there's not much to the examples here as <span><b class="command">svn
            cleanup</b></span> generates no output.  If you pass no PATH, '.'
            is used.</p><pre class="screen">
$ svn cleanup

$ svn cleanup /path/to/working-copy
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2936492"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn commit &#8212; Send changes from your working copy to the repository.</p></div><div class="refsect1" lang="en"><a name="id2936510"></a><h2>Synopsis</h2><pre class="programlisting">svn commit [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2936524"></a><h2>Description</h2><p>Send changes from your working copy to the
            repository. If you do not supply a log message with your
            commit by using either the <tt class="option">--file</tt> or
            <tt class="option">--message</tt> switch,
            <span><b class="command">svn</b></span> will launch your editor for you
            to compose a commit message.  See the
            <tt class="literal">editor-cmd</tt> section in <a href="#svn-ch-6-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If you begin a commit and Subversion launches your
            editor to compose the commit message, you can still abort
            without committing your changes.  If you want to cancel
            your commit, just quit your editor without saving your
            commit message and Subversion will prompt you to either
            abort the commit, continue with no message, or edit the
            message again.</p></div></div><div class="refsect1" lang="en"><a name="id2934370"></a><h2>Alternate Names</h2><p>ci (short for &#8220;<span class="quote">check in</span>&#8221; not 
            &#8220;<span class="quote">co</span>&#8221;, which is short for 
            &#8220;<span class="quote">checkout</span>&#8221;)</p></div><div class="refsect1" lang="en"><a name="id2934398"></a><h2>Changes</h2><p>Working copy, repository</p></div><div class="refsect1" lang="en"><a name="id2934412"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2934426"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--non-recursive (-N)
--targets FILENAME
--force-log
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2934444"></a><h2>Examples</h2><p>Commit a simple modification to a file with the
            commit message on the command line and an implicit
            target of your current directory (&#8220;<span class="quote">.</span>&#8221;):</p><pre class="screen">
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
          </pre><p>Commit a modification to the file
            <tt class="filename">foo.c</tt> (explicitly specified on the
            command line) with the commit message in a file named
            <tt class="literal">msg</tt>:</p><pre class="screen">
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
          </pre><p>If you want to use a file that's under version
            control for your commit message with
            <tt class="option">--file</tt>, you need to pass the
            <tt class="option">--force-log</tt> switch:</p><pre class="screen">
$ svn commit --file file_under_vc.txt foo.c
svn: The log message file is under version control
svn: Log message file is a versioned file; use `--force-log' to override.

$ svn commit --force-log --file file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
          </pre><p>To commit a file scheduled for deletion:</p><pre class="screen">
svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2936927"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn copy &#8212; Copy a file or directory in a working copy or
            in the repository.</p></div><div class="refsect1" lang="en"><a name="id2936945"></a><h2>Synopsis</h2><pre class="programlisting">svn copy SRC DST</pre></div><div class="refsect1" lang="en"><a name="id2936959"></a><h2>Description</h2><p>Copy a file in a working copy or in the repository.
            SRC and DST can each be either a working copy
            (WC) path or URL:</p><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Copy and schedule an item for
                    addition (with history).</p></dd><dt><span class="term">WC  -&gt; URL</span></dt><dd><p>Immediately commit a copy of WC to URL.</p></dd><dt><span class="term">URL -&gt; WC</span></dt><dd><p>Check out URL into WC, and schedule it for addition.</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Complete server-side copy.  This is
                    usually used to branch and tag.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>You can only copy files within a single repository.
              Subversion does not support cross-repository copying.</p></div></div><div class="refsect1" lang="en"><a name="id2937076"></a><h2>Alternate Names</h2><p>cp</p></div><div class="refsect1" lang="en"><a name="id2937090"></a><h2>Changes</h2><p>Repository if destination is a URL.</p><p>Working copy if destination is a WC path.</p></div><div class="refsect1" lang="en"><a name="id2937109"></a><h2>Accesses Repository</h2><p>If source or destination is in the repository, or if needed
            to look up the source revision number.</p></div><div class="refsect1" lang="en"><a name="id2937125"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2937143"></a><h2>Examples</h2><p>Copy an item within your working copy (just
            schedules the copy&#8212;nothing goes into the repository
            until you commit):</p><pre class="screen">
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +   bar.txt
          </pre><p>Copy an item in your working copy to a URL in the
            repository (an immediate commit, so you must supply a
            commit message):</p><pre class="screen">
$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
          </pre><p>Copy an item from the repository to your working
            copy (just schedules the copy&#8212;nothing goes into the
            repository until you commit):</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>This is the recommended way to resurrect a dead
              file in your repository!</p></div><pre class="screen">
$ svn copy file:///tmp/repos/test/far-away near-here
A         near-here
          </pre><p>And finally, copying between two URLs:</p><pre class="screen">
$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m "remote copy."

Committed revision 9.
          </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>This is the easiest way to 'tag' a revision in
              your repository&#8212;just <span><b class="command">svn copy</b></span>
              that revision (usually HEAD) into your tags directory.</p></div><pre class="screen">
$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
          </pre><p>And don't worry if you forgot to tag&#8212;you can
            always specify an older revision and tag anytime:</p><pre class="screen">
$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m "Forgot to tag at rev 11"

Committed revision 13.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2937266"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn delete  &#8212; Delete an item from a working copy
            or the repository.</p></div><div class="refsect1" lang="en"><a name="id2937284"></a><h2>Synopsis</h2><pre class="programlisting">svn delete PATH...</pre><pre class="programlisting">svn delete URL...</pre></div><div class="refsect1" lang="en"><a name="id2937303"></a><h2>Description</h2><p>Items specified by PATH are scheduled
            for deletion upon the next commit.  Files (and
            directories that have not been committed) are
            immediately removed from the working copy.  The command
            will not remove any unversioned or modified items; use
            the <tt class="option">--force</tt> switch to override this
            behavior.</p><p>Items specified by URL are deleted from
            the repository via an immediate commit.  Multiple URLs are
            committed atomically.</p></div><div class="refsect1" lang="en"><a name="id2937335"></a><h2>Alternate Names</h2><p>del, remove, rm</p></div><div class="refsect1" lang="en"><a name="id2937349"></a><h2>Changes</h2><p>Working copy if operating on files, Repository if operating on URLs</p></div><div class="refsect1" lang="en"><a name="id2937364"></a><h2>Accesses Repository</h2><p>Only if operating on URLs</p></div><div class="refsect1" lang="en"><a name="id2937379"></a><h2>Switches</h2><pre class="screen">
--force
--force-log
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2937396"></a><h2>Examples</h2><p>Using <span><b class="command">svn</b></span> to delete a file from
            your working copy merely schedules it to be
            deleted. When you commit, the file is deleted in the
            repository.</p><pre class="screen">
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
          </pre><p>Deleting a URL, however, is immediate, so you have
          to supply a log message:</p><pre class="screen">
$ svn delete -m "Deleting file 'yourfile'" file:///tmp/repos/test/yourfile

Committed revision 15.
          </pre><p>Here's an example of how to force deletion of a file
            that has local mods:</p><pre class="screen">
$ svn delete over-there 
svn: Attempting restricted operation for modified resource
svn: Use --force to override this restriction
svn: 'over-there' has local modifications

$ svn delete --force over-there 
D         over-there
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2937464"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn diff &#8212; Display the differences between two paths.</p></div><div class="refsect1" lang="en"><a name="id2937480"></a><h2>Synopsis</h2><pre class="programlisting">svn diff [-r N[:M]] [TARGET...]</pre><pre class="programlisting">svn diff URL1[@N] URL2[@M]</pre></div><div class="refsect1" lang="en"><a name="id2937499"></a><h2>Description</h2><p>Display the differences between two paths.  Each
            TARGET can be either a working copy path or URL.  If no
            TARGET is specified, a value of '.' is assumed.</p><p>If TARGET is a URL, then revs N and M must be given
            via the <tt class="option">--revision</tt>.</p><p>If TARGET is a working copy path, then the
          <tt class="option">--revision</tt> switch means:</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">--revision N:M</b></span></span></dt><dd><p>The server compares TARGET@N and TARGET@M.</p></dd><dt><span class="term"><span><b class="command">--revision N</b></span></span></dt><dd><p>The client compares TARGET@N against working copy.</p></dd><dt><span class="term"><span><b class="command">(no --revision)</b></span></span></dt><dd><p>The client compares base and working copies of
                  TARGET.</p></dd></dl></div><p>If the alternate syntax is used, the server compares
            URL1 and URL2 at revisions N and M respectively.  If
            either N or M are omitted, a value of HEAD is
            assumed.</p></div><div class="refsect1" lang="en"><a name="id2937626"></a><h2>Alternate Names</h2><p>di</p></div><div class="refsect1" lang="en"><a name="id2937640"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2937654"></a><h2>Accesses Repository</h2><p>For obtaining differences against anything but BASE
            revision in your working copy</p></div><div class="refsect1" lang="en"><a name="id2937670"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--extensions (-x) "ARGS"
--non-recursive (-N)
--diff-cmd CMD
--username USER
--password PASS
--no-auth-cache
--non-interactive
--no-diff-deleted
          </pre></div><div class="refsect1" lang="en"><a name="id2937687"></a><h2>Examples</h2><p>Compare BASE and your working copy (one of the most
            popular uses of <span><b class="command">svn diff</b></span>):</p><pre class="screen">
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
          </pre><p>See how your working copy's modifications compare
            against an older revision:</p><pre class="screen">
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
          </pre><p>Compare revision 3000 to revision 3500 using '@'
            syntax:</p><pre class="screen">
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
&#8230;
          </pre><p>Compare revision 3000 to revision 3500 using range
            notation (you only pass the one URL in this
            case):</p><pre class="screen">
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
          </pre><p>If you have a working copy, you can obtain the
            differences without typing in the long URLs:</p><pre class="screen">
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
          </pre><p>Use <tt class="option">--diff-cmd</tt>
            <i class="replaceable"><tt>CMD</tt></i> <tt class="option">-x</tt> to
            pass arguments directly to the external diff
            program</p><pre class="screen">
svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2937817"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn export &#8212; Exports a clean directory tree.</p></div><div class="refsect1" lang="en"><a name="id2937834"></a><h2>Synopsis</h2><pre class="programlisting">svn export [-r REV] URL [PATH]</pre><pre class="programlisting">svn export PATH1 PATH2</pre></div><div class="refsect1" lang="en"><a name="id2937854"></a><h2>Description</h2><p>The first form exports a clean directory tree from
            the repository specified by URL, at revision REV if it
            is given, otherwise at HEAD, into PATH. If PATH is
            omitted, the last component of the URL is used for the
            local directory name.</p><p>The second form exports a clean directory tree from
            the working copy specified by PATH1 into PATH2.  All
            local changes will be preserved, but files not under
            version control will not be copied.</p></div><div class="refsect1" lang="en"><a name="id2937882"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2937896"></a><h2>Changes</h2><p>Local disk</p></div><div class="refsect1" lang="en"><a name="id2937910"></a><h2>Accesses Repository</h2><p>Only if exporting from a URL</p></div><div class="refsect1" lang="en"><a name="id2937924"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2937940"></a><h2>Examples</h2><p>Export from your working copy (doesn't print every
            file and directory):</p><pre class="screen">
$ svn export a-wc my-export
pantheon: /tmp&gt;
          </pre><p>Export directly from the repository (prints every
            file and directory):</p><pre class="screen">
$ svn export file:///tmp/repos my-export
A  my-export/test
A  my-export/quiz
&#8230;
Exported revision 15.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2937981"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn help &#8212; Help!</p></div><div class="refsect1" lang="en"><a name="id2937998"></a><h2>Synopsis</h2><pre class="programlisting">svn help [SUBCOMMAND...]</pre></div><div class="refsect1" lang="en"><a name="id2938012"></a><h2>Description</h2><p>This is your best friend when you're using
            Subversion and this book isn't within reach!</p></div><div class="refsect1" lang="en"><a name="id2938028"></a><h2>Alternate Names</h2><p>?, h</p></div><div class="refsect1" lang="en"><a name="id2938042"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2938056"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="en"><a name="id2938070"></a><h2>Switches</h2><pre class="screen">
--version
--quiet (-q)
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2938090"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn import &#8212; Recursively commit a copy of PATH to URL.</p></div><div class="refsect1" lang="en"><a name="id2938108"></a><h2>Synopsis</h2><pre class="programlisting">svn import [PATH] URL</pre></div><div class="refsect1" lang="en"><a name="id2938122"></a><h2>Description</h2><p>Recursively commit a copy of <tt class="literal">PATH</tt>
            to <tt class="literal">URL</tt>.  If <tt class="literal">PATH</tt>
            is omitted '.' is assumed.  Parent directories are created
            in the repository as necessary.</p></div><div class="refsect1" lang="en"><a name="id2938161"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2938175"></a><h2>Changes</h2><p>Repository</p></div><div class="refsect1" lang="en"><a name="id2938189"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2938203"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--non-recursive (-N)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--force-log
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2938220"></a><h2>Examples</h2><p>This imports the local directory 'myproj' into the
            root of your repository:</p><pre class="screen">
$ svn import -m "New import" myproj http://svn.red-bean.com/repos/test
Adding         myproj/sample.txt
&#8230;
Transmitting file data .........
Committed revision 16.
          </pre><p>This imports the local directory 'myproj' into
            'trunk/vendors' in your repository.  The directory
            'trunk/vendors' need not exist before you import into
            it&#8212;<span><b class="command">svn import</b></span> will
            recursively create directories for you:</p><pre class="screen">
$ svn import -m "New import" myproj \
    http://svn.red-bean.com/repos/test/trunk/vendors/myproj
Adding         myproj/sample.txt
&#8230;
Transmitting file data .........
Committed revision 19.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2938276"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn info &#8212; Print information about PATHs.</p></div><div class="refsect1" lang="en"><a name="id2938293"></a><h2>Synopsis</h2><pre class="programlisting">svn info [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2938307"></a><h2>Description</h2><p>Print information about paths in your working copy,
          including:</p><div class="itemizedlist"><ul type="disc"><li><p>Path</p></li><li><p>Name</p></li><li><p>URL</p></li><li><p>Revision</p></li><li><p>Node Kind</p></li><li><p>Last Changed Author</p></li><li><p>Last Changed Revision</p></li><li><p>Last Changed Date</p></li><li><p>Text Last Updated</p></li><li><p>Properties Last Updated</p></li><li><p>Checksum</p></li></ul></div></div><div class="refsect1" lang="en"><a name="id2938397"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2938411"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2938425"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="en"><a name="id2938439"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
          </pre></div><div class="refsect1" lang="en"><a name="id2938454"></a><h2>Examples</h2><p><span><b class="command">svn info</b></span> will show you all the
            useful information that it has for items in your working
            copy.  It will show information for files:</p><pre class="screen">
$ svn info foo.c
Path: foo.c
Name: foo.c
URL: http://svn.red-bean.com/repos/test/foo.c
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: /3L38YwzhT93BWvgpdF6Zw==
          </pre><p>It will also show information for directories:</p><pre class="screen">
$ svn info vendors
Path: trunk
URL: http://svn.red-bean.com/repos/test/vendors
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2938511"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn list &#8212; List directory entries in the repository.</p></div><div class="refsect1" lang="en"><a name="id2938528"></a><h2>Synopsis</h2><pre class="programlisting">svn list [TARGET...]</pre></div><div class="refsect1" lang="en"><a name="id2938542"></a><h2>Description</h2><p>List each TARGET file and the contents of each TARGET
            directory as they exist in the repository.  If TARGET is a
            working copy path, the corresponding repository URL will be
            used.</p><p>The default TARGET is '.', meaning the repository URL
            of the current working copy directory.</p><p>With <tt class="option">--verbose</tt>, the following fields show
            the status of the item:</p><div class="itemizedlist"><ul type="disc"><li><p>Revision number of the last commit</p></li><li><p>Author of the last commit</p></li><li><p>Size (in bytes)</p></li><li><p>Date and time of the last commit</p></li></ul></div></div><div class="refsect1" lang="en"><a name="id2938609"></a><h2>Alternate Names</h2><p>ls</p></div><div class="refsect1" lang="en"><a name="id2938623"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2938636"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2938650"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--verbose (-v)
--recursive (-R)
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2938667"></a><h2>Examples</h2><p><span><b class="command">svn list</b></span> is most useful if you
            want to see what files a repository has without
            downloading a working copy:</p><pre class="screen">
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
&#8230;
          </pre><p>Like UNIX <span><b class="command">ls</b></span>, you can also pass
          the <tt class="option">--verbose</tt> switch for additional
          information:</p><pre class="screen">
svn list --verbose file:///tmp/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
          </pre><p>For further details, see <a href="#svn-ch-3-sect-5.4" title="svn list">the section called &#8220;svn list&#8221;</a>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2938742"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn log &#8212; Displays commit log
          messages.</p></div><div class="refsect1" lang="en"><a name="id2938760"></a><h2>Synopsis</h2><pre class="programlisting">svn log [PATH]</pre><pre class="programlisting">svn log URL [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2938778"></a><h2>Description</h2><p>The default target is the path of your current
            directory.  If no arguments are supplied, <span><b class="command">svn
            log</b></span> shows the log messages for all files and
            directories inside of (and including) the current
            working directory of your working copy.  You can refine
            the results by specifying a path, one or more
            revisions, or any combination of the two.
            The default revision range for a local path is BASE:1.</p><p>If you specify a URL alone, then it prints log
            messages for everything that the URL contains.  If you
            add paths past the URL, only messages for those paths
            under that URL will be printed.  The default revision range
            for a URL is HEAD:1.</p><p>With <tt class="option">--verbose</tt>, <span><b class="command">svn log</b></span>
            will also print all affected paths with each log message.
            With <tt class="option">--quiet</tt>, <span><b class="command">svn log</b></span>
            will not print the log message body itself (this is
            compatible with <tt class="option">--verbose</tt>).</p><p>Each log message is printed just once, even if more
            than one of the affected paths for that revision were
            explicitly requested.  Logs cross copy history by
            default; use <tt class="option">--strict</tt> to disable
            this.</p></div><div class="refsect1" lang="en"><a name="id2938869"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2938883"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2938897"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2938911"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--quiet (-q)
--verbose (-v)
--targets FILENAME
--username USER
--password PASS
--no-auth-cache
--non-interactive
--strict
--incremental
--xml
          </pre></div><div class="refsect1" lang="en"><a name="id2938928"></a><h2>Examples</h2><p>You can see the log messages for all the paths that
            changed in your working copy by running <span><b class="command">svn
            log</b></span> from the top:</p><pre class="screen">
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
&#8230;
          </pre><p>Examine all log messages for a particular file in
            your working copy:</p><pre class="screen">
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&#8230;
          </pre><p>If you don't have a working copy handy, you can log
            a URL:</p><pre class="screen">
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&#8230;
          </pre><p>If you want several distinct paths underneath the
            same URL, you can use the <tt class="literal">URL [PATH...]</tt>
            syntax.</p><pre class="screen">
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
&#8230;
          </pre><p>That is the same as explicitly placing both URLs on
            the command line:</p><pre class="screen">
$ svn log http://svn.red-bean.com/repos/test/foo.c \
          http://svn.red-bean.com/repos/test/bar.c
&#8230;
          </pre><p>When you're concatenating the results of multiple
            calls to the log command, you may want to use the
            <tt class="option">--incremental</tt> switch. <span><b class="command">svn
            log</b></span> normally prints out a dashed line at the
            beginning of a log message, after each subsequent log
            message, and following the final log message.  If you
            ran svn log on a range of two revisions, you would get
            this:</p><pre class="screen">
$ svn log -r 14:15
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r15 | ... 

------------------------------------------------------------------------
          </pre><p>However, if you wanted to gather 2 non-sequential
            log messages into a file, you might do something like
            this:</p><pre class="screen">
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 | ... 

------------------------------------------------------------------------
          </pre><p>You can avoid the clutter of the double dashed lines
            in your output by using the incremental switch:</p><pre class="screen">
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 | ... 

------------------------------------------------------------------------
r19 | ... 

------------------------------------------------------------------------
r27 | ... 
          </pre><p>The <tt class="option">--incremental</tt> switch provides
            similar output control when using the
            <tt class="option">--xml</tt> switch.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If you run <span><b class="command">svn log</b></span> on a specific
              path and provide a specific revision and get no output
              at all</p><pre class="screen">
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
            </pre><p>That just means that the path was not modified in
              that revision.  If you log from the top of the
              repository, or know the file that changed in that
              revision, you can specify it explicitly:</p><pre class="screen">
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
            </pre></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2939183"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn merge &#8212; Apply the differences between two sources to a working copy path.</p></div><div class="refsect1" lang="en"><a name="id2939201"></a><h2>Synopsis</h2><pre class="programlisting">svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]</pre><pre class="programlisting">svn merge -r N:M SOURCE [PATH]</pre></div><div class="refsect1" lang="en"><a name="id2939221"></a><h2>Description</h2><p>In the first form, the source URLs are specified
            at revisions N and M.  These are the two sources to be
            compared.  The revisions default to HEAD if omitted.</p><p>In the second form, SOURCE can be a URL or working
            copy item, in which case the corresponding URL is used.
            This URL, at revisions N and M, defines the two sources
            to be compared.</p><p>WCPATH is the working copy path that will receive
            the changes. If WCPATH is omitted, a default value of
            '.' is assumed, unless the sources have identical
            basenames that match a file within '.': in which case,
            the differences will be applied to that file.</p></div><div class="refsect1" lang="en"><a name="id2939257"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2939271"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2939285"></a><h2>Accesses Repository</h2><p>Only if working with URLs</p></div><div class="refsect1" lang="en"><a name="id2939300"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--force
--dry-run
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2939316"></a><h2>Examples</h2><p>Merge a branch back into the trunk (assuming that
            you have a working copy of the trunk):</p><pre class="screen">
$ svn merge http://svn.red-bean.com/repos/trunk/vendors \
            http://svn.red-bean.com/repos/branches/vendors-with-fix
U  myproj/tiny.txt
U  myproj/thhgttg.txt
U  myproj/win.txt
U  myproj/flo.txt
          </pre><p>If you branched at revision 23, and you want to
            merge changes on trunk into your branch, you could do
            this from inside the working copy of your branch:</p><pre class="screen">
$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors
U  myproj/thhgttg.txt
&#8230;
          </pre><p>To merge changes to a single file:</p><pre class="screen">
$ cd myproj
$ svn merge -r 30:31 thhgttg.txt 
U  thhgttg.txt
        </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2939373"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn mkdir &#8212; Create a new directory under version control.</p></div><div class="refsect1" lang="en"><a name="id2939390"></a><h2>Synopsis</h2><pre class="programlisting">svn mkdir PATH...</pre><pre class="programlisting">svn mkdir URL...</pre></div><div class="refsect1" lang="en"><a name="id2939409"></a><h2>Description</h2><p>Create a directory with a name given by the final component
            of the PATH or URL.  A directory specified by a working copy PATH
            is scheduled for addition in the working copy.
            A directory specified by a URL is created in
            the repository via an immediate commit.  Multiple directory
            URLs are committed atomically.  In both cases all the
            intermediate directories must already exist.</p></div><div class="refsect1" lang="en"><a name="id2939432"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2939446"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939460"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939475"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--force-log
          </pre></div><div class="refsect1" lang="en"><a name="id2939491"></a><h2>Examples</h2><p>Create a directory in your working copy:</p><pre class="screen">
$ svn mkdir newdir
A         newdir
          </pre><p>Create one in the repository (instant commit, so a
            log message is required):</p><pre class="screen">
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2939531"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn move &#8212; Move a file or directory.</p></div><div class="refsect1" lang="en"><a name="id2939548"></a><h2>Synopsis</h2><pre class="programlisting">svn move SRC DST</pre></div><div class="refsect1" lang="en"><a name="id2939562"></a><h2>Description</h2><p>This command moves a file or directory in your
            working copy or in the repository.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>This command is equivalent to an <span><b class="command">svn
              copy</b></span> followed by <span><b class="command">svn
              delete</b></span>.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Subversion does not support moving between working
            copies and URLs.  In addition, you can only move files
            within a single repository&#8212;Subversion does not
            support cross-repository moving.</p></div><div class="variablelist"><dl><dt><span class="term">WC  -&gt; WC</span></dt><dd><p>Move and schedule a file or directory for
                  addition (with history).</p></dd><dt><span class="term">URL -&gt; URL</span></dt><dd><p>Complete server-side rename.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2939664"></a><h2>Alternate Names</h2><p>mv, rename, ren</p></div><div class="refsect1" lang="en"><a name="id2939678"></a><h2>Changes</h2><p>Working copy, repository if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939692"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939707"></a><h2>Switches</h2><pre class="screen">
--message (-m) TEXT
--file (-F) FILE
--revision (-r) REV
--quiet (-q)
--force
--username USER
--password PASS
--no-auth-cache
--non-interactive
--encoding ENC
--force-log
          </pre></div><div class="refsect1" lang="en"><a name="id2939724"></a><h2>Examples</h2><p>Move a file in your working copy:</p><pre class="screen">
$ svn move foo.c bar.c
A         bar.c
D         foo.c
          </pre><p>Move a file in the repository (an immediate commit,
            so it requires a commit message): </p><pre class="screen">
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2939765"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn propdel &#8212; Remove a property from an item.</p></div><div class="refsect1" lang="en"><a name="id2939782"></a><h2>Synopsis</h2><pre class="programlisting">svn propdel PROPNAME [PATH...]</pre><pre class="programlisting">svn propdel PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="en"><a name="id2939802"></a><h2>Description</h2><p>This removes properties from files, directories, or
            revisions.  The first form removes versioned properties
            in working copy, while the second removes unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" lang="en"><a name="id2939820"></a><h2>Alternate Names</h2><p>pdel, pd</p></div><div class="refsect1" lang="en"><a name="id2939834"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939849"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2939863"></a><h2>Switches</h2><pre class="screen">
--quiet (-q)
--recursive (-R)
--revision (-r) REV
--revprop
          </pre></div><div class="refsect1" lang="en"><a name="id2939878"></a><h2>Examples</h2><p>Delete a property from a file in your working
            copy</p><pre class="screen">
$ svn propdel svn:mime-type  some-script
property `svn:mime-type' deleted from 'some-script'.
          </pre><p>Delete a revision property:</p><pre class="screen">
$ svn propdel --revprop -r 26 release-date 
property `release-date' deleted from repository revision '26'
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2939918"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn propedit &#8212; Edit the property of one or more items under version control.</p></div><div class="refsect1" lang="en"><a name="id2939936"></a><h2>Synopsis</h2><pre class="programlisting">svn propedit PROPNAME PATH...</pre><pre class="programlisting">svn propedit PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="en"><a name="id2939956"></a><h2>Description</h2><p>Edits one or more properties using your favorite
            editor. The first form edits versioned properties in
            your working copy, while the second edits unversioned
            remote properties on a repository revision.</p></div><div class="refsect1" lang="en"><a name="id2939974"></a><h2>Alternate Names</h2><p>pedit, pe</p></div><div class="refsect1" lang="en"><a name="id2939988"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940003"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940017"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--revprop
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2940032"></a><h2>Examples</h2><p><span><b class="command">svn propedit</b></span> makes it easy to
            modify properties that have multiple values:</p><pre class="screen">
$ svn propedit svn:keywords  foo.c 
    &lt;svn will launch your favorite editor here, with a buffer open
    containing the current contents of the svn:keywords property.  You
    can add multiple values to a property easily here by entering one
    value per line.&gt;
Set new value for property `svn:keywords' on `foo.c'
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2940076"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn propget &#8212; Prints the value of a property.</p></div><div class="refsect1" lang="en"><a name="id2940093"></a><h2>Synopsis</h2><pre class="programlisting">svn propget PROPNAME [PATH...]</pre><pre class="programlisting">svn propget PROPNAME --revprop -r REV [URL]</pre></div><div class="refsect1" lang="en"><a name="id2940113"></a><h2>Description</h2><p>Prints the value of a property on files,
            directories, or revisions.  The first form prints the
            versioned property of an item or items in your working
            copy, while the second prints unversioned remote
            property on a repository revision.  See <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a> for more information on
            properties.</p></div><div class="refsect1" lang="en"><a name="id2940141"></a><h2>Alternate Names</h2><p>pget, pg</p></div><div class="refsect1" lang="en"><a name="id2940155"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940169"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940184"></a><h2>Switches</h2><pre class="screen">
--recursive (-R)
--revision (-r) REV
--revprop
          </pre></div><div class="refsect1" lang="en"><a name="id2940198"></a><h2>Examples</h2><p>Examine a property of a file in your working
            copy:</p><pre class="screen">
$ svn propget svn:keywords foo.c
Author
Date
Rev
          </pre><p>The same goes for a revision property:</p><pre class="screen">
$ svn propget svn:log --revprop -r 20 
Began journal.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2940237"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn proplist &#8212; Lists all properties.</p></div><div class="refsect1" lang="en"><a name="id2940254"></a><h2>Synopsis</h2><pre class="programlisting">svn proplist [PATH...]</pre><pre class="programlisting">svn proplist --revprop -r REV [URL]</pre></div><div class="refsect1" lang="en"><a name="id2940274"></a><h2>Description</h2><p>Lists all properties on files, directories, or
            revisions.  The first form lists versioned properties in
            working copy, while the second lists unversioned remote
            properties on a repository revision.</p></div><div class="refsect1" lang="en"><a name="id2940292"></a><h2>Alternate Names</h2><p>plist, pl</p></div><div class="refsect1" lang="en"><a name="id2940306"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940321"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940335"></a><h2>Switches</h2><pre class="screen">
--verbose (-v)
--recursive (-R)
--revision (-r) REV
--revprop
          </pre></div><div class="refsect1" lang="en"><a name="id2940350"></a><h2>Examples</h2><p>You can use proplist to see the properties on an
            item in your working copy:</p><pre class="screen">
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
          </pre><p>But with the <tt class="option">--verbose</tt> flag, svn
            proplist is extremely handy as it also shows you the
            values for the properties:</p><pre class="screen">
$ svn proplist --verbose foo.c
Properties on 'foo.c':
  svn:mime-type : text/plain
  svn:keywords : Author Date Rev
  owner : sally
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2940398"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn propset &#8212; Set PROPNAME to PROPVAL on files, directories, or revisions.</p></div><div class="refsect1" lang="en"><a name="id2940416"></a><h2>Synopsis</h2><pre class="programlisting">svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</pre><pre class="programlisting">svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]</pre></div><div class="refsect1" lang="en"><a name="id2940436"></a><h2>Description</h2><p>Set PROPNAME to PROPVAL on files, directories, or
          revisions. The first example creates a versioned, local
          propchange in the working copy, and the second creates an
          unversioned, remote propchange on a repository revision.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Subversion has a number of &#8220;<span class="quote">special</span>&#8221;
              properties that affect its behavior.  See <a href="#svn-ch-6-sect-2.3" title="Special properties">the section called &#8220;Special properties&#8221;</a> for more on these
              properties.</p></div></div><div class="refsect1" lang="en"><a name="id2940480"></a><h2>Alternate Names</h2><p>pset, ps</p></div><div class="refsect1" lang="en"><a name="id2940493"></a><h2>Changes</h2><p>Working copy, repository only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940508"></a><h2>Accesses Repository</h2><p>Only if operating on a URL</p></div><div class="refsect1" lang="en"><a name="id2940522"></a><h2>Switches</h2><pre class="screen">
--file (-F) FILE
--quiet (-q)
--revision (-r) REV
--targets FILENAME
--recursive (-R)
--revprop
--encoding ENC
          </pre></div><div class="refsect1" lang="en"><a name="id2940538"></a><h2>Examples</h2><p>Set the mimetype on a file:</p><pre class="screen">
$ svn propset svn:mime-type image/jpeg foo.jpg 
property `svn:mime-type' set on 'foo.jpg'
          </pre><p>On a UNIX system, if you want a file to have the
            executable permission set:</p><pre class="screen">
$ svn propset svn:executable ON somescript
property `svn:executable' set on 'somescript'
          </pre><p>Perhaps you have an internal policy to set certain
            properties for the benefit of your coworkers:</p><pre class="screen">
$ svn propset owner sally foo.c
property `owner' set on 'foo.c'
          </pre><p>If you made a mistake in a log message for a
            particular revision and want to change it, use
            <tt class="option">--revprop</tt> and set svn:log to the new
            log message:</p><pre class="screen">
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property `svn:log' set on repository revision '25'
          </pre><p>Or, if you don't have a working copy, you can
          provide a URL.</p><pre class="screen">
$ svn propset --revprop -r 26 svn:log "Document nap." http://svn.red-bean.com/repos
property `svn:log' set on repository revision '25'
          </pre><p>Lastly, you can tell propset to take its input from
          a file.  You could even use this to set the contents of a
          property to something binary:</p><pre class="screen">
$ svn propset owner-pic -F sally.jpg moo.c 
property `owner-pic' set on 'moo.c'
          </pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>By default, you cannot modify revision properties
              in a Subversion repository.  Your repository
              administrator must explicitly enable revision property
              modifications by creating a hook named
              'pre-revprop-change'. See <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a> for more information on
              hook scripts.</p></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2940662"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn resolved &#8212; Remove &#8220;<span class="quote">conflicted</span>&#8221; state on
            working copy files or directories.</p></div><div class="refsect1" lang="en"><a name="id2940684"></a><h2>Synopsis</h2><pre class="programlisting">svn resolved PATH...</pre></div><div class="refsect1" lang="en"><a name="id2940698"></a><h2>Description</h2><p>Remove &#8220;<span class="quote">conflicted</span>&#8221; state on working
            copy files or directories. This routine does not
            semantically resolve conflict markers; it merely removes
            conflict-related artifact files and allows PATH to be
            committed again; that is, it tells Subversion that the
            conflicts have been &#8220;<span class="quote">resolved</span>&#8221;.  See <a href="#svn-ch-3-sect-4.4" title="Resolve Conflicts (Merging Others' Changes)">the section called &#8220;Resolve Conflicts (Merging Others' Changes)&#8221;</a> for an in-depth look at
            resolving conflicts.</p></div><div class="refsect1" lang="en"><a name="id2940737"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2940750"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2940764"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="en"><a name="id2940778"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
--quiet (-q)
          </pre></div><div class="refsect1" lang="en"><a name="id2940794"></a><h2>Examples</h2><p>If you get a conflict on an update, your working
            copy will sprout three new files:</p><pre class="screen">
$ svn update
C  foo.c
Updated to revision 31.
$ ls
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
          </pre><p>Once you've resolved the conflict and
            <tt class="filename">foo.c</tt> is ready to be committed, run
            <span><b class="command">svn resolved</b></span> to let your working copy
            know you've taken care of everything.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>You <span class="emphasis"><em>can</em></span> just remove the
              conflict files and commit, but <span><b class="command">svn
              resolved</b></span> fixes up some bookkeeping data
              in the working copy administrative area in addition
              to removing the conflict files, so we recommend that
              you use this command.</p></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2940872"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn revert &#8212; Undo all local edits.</p></div><div class="refsect1" lang="en"><a name="id2940888"></a><h2>Synopsis</h2><pre class="programlisting">svn revert PATH...</pre></div><div class="refsect1" lang="en"><a name="id2940903"></a><h2>Description</h2><p>Reverts any local changes to a file or directory and
            resolves any conflicted states.  <span><b class="command">svn
            revert</b></span> will not only revert the contents of an
            item in your working copy, but also any property
            changes.  Finally, you can use it to undo any scheduling
            operations that you may have done (e.g. files scheduled
            for addition or deletion can be
            &#8220;<span class="quote">unscheduled</span>&#8221;).</p></div><div class="refsect1" lang="en"><a name="id2940936"></a><h2>Alternate Names</h2><p>None</p></div><div class="refsect1" lang="en"><a name="id2940950"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2940964"></a><h2>Accesses Repository</h2><p>No</p></div><div class="refsect1" lang="en"><a name="id2940978"></a><h2>Switches</h2><pre class="screen">
--targets FILENAME
--recursive (-R)
--quiet (-q)
          </pre></div><div class="refsect1" lang="en"><a name="id2940993"></a><h2>Examples</h2><p>Discard changes to a file:</p><pre class="screen">
$ svn revert foo.c
Reverted foo.c
          </pre><p>If you want to revert a whole directory of files,
            use the <tt class="option">--recursive</tt> flag:</p><pre class="screen">
$ svn revert --recursive .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
          </pre><p>Lastly, you can undo any scheduling
            operations:</p><pre class="screen">
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?      mistake.txt
?      whoops
          </pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you provide no targets to <span><b class="command">svn
              revert</b></span>, it will do nothing&#8212;to protect
              you from accidentally losing changes in your working
              copy, <span><b class="command">svn revert</b></span> requires you to
              provide at least one target.</p></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2941080"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn status &#8212; Print the status of working copy files and directories.</p></div><div class="refsect1" lang="en"><a name="id2941098"></a><h2>Synopsis</h2><pre class="programlisting">svn status [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2941111"></a><h2>Description</h2><p>Print the status of working copy files and
            directories.  With no arguments, it prints only locally
            modified items (no repository access).  With
            <tt class="option">--show-updates</tt>, add working revision
            and server out-of-date information.  With
            <tt class="option">--verbose</tt>, print full revision
            information on every item.</p><p>The first five columns in the output are each one
            character wide, and each column gives you information
            about different aspects of each working copy
            item.</p><p>The first column indicates that an item
            was added, deleted, or otherwise changed.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'A'</span></dt><dd><p>Item is scheduled for Addition.</p></dd><dt><span class="term">'D'</span></dt><dd><p>Item is scheduled for Deletion.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Item has been modified.</p></dd><dt><span class="term">'C'</span></dt><dd><p>Item is in conflict with updates received from
                the repository.</p></dd><dt><span class="term">'I'</span></dt><dd><p>Item is being ignored (e.g. with the 
                  svn:ignore property)</p></dd><dt><span class="term">'?'</span></dt><dd><p>Item is not under version control.</p></dd><dt><span class="term">'!'</span></dt><dd><p>Item is missing (e.g. you moved or deleted it
                without using <span><b class="command">svn</b></span>).  This also
                indicates that a directory is incomplete (a checkout
                or update was interrupted).</p></dd><dt><span class="term">'~'</span></dt><dd><p>Item is versioned as a directory, but has
                  been replaced by a file, or vice versa</p></dd></dl></div><p>The second column tells the status of a file's or
            directory's properties.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No modifications.</p></dd><dt><span class="term">'M'</span></dt><dd><p>Properties for this item have been
                  modified.</p></dd><dt><span class="term">'C'</span></dt><dd><p>Properties for this item are in conflict with
                property updates received from the
                repository.</p></dd></dl></div><p>The third column is populated only if the
            working copy directory is locked.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is not locked.</p></dd><dt><span class="term">'L'</span></dt><dd><p>Item is locked.</p></dd></dl></div><p>The fourth column is populated only if the item is
            scheduled for addition-with-history.</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>No history scheduled with commit.</p></dd><dt><span class="term">'+'</span></dt><dd><p>History scheduled with commit.</p></dd></dl></div><p>The fifth column is populated only if the item is
            switched relative to its parent (see <a href="#svn-ch-4-sect-5" title="Switching a Working Copy">the section called &#8220;Switching a Working Copy&#8221;</a>).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>Item is child of its parent directory.</p></dd><dt><span class="term">'S'</span></dt><dd><p>Item is switched.</p></dd></dl></div><p>The out-of-date information appears in the eighth
            column (only if you pass the
            <tt class="option">--show-updates</tt> switch).</p><div class="variablelist"><dl><dt><span class="term">' '</span></dt><dd><p>The item in your working copy is up-to-date.</p></dd><dt><span class="term">'*'</span></dt><dd><p>A newer revision of the item exists on the
                  server.</p></dd></dl></div><p>The remaining fields are variable width and
            delimited by spaces.  The working revision is the next
            field if the <tt class="option">--show-updates</tt> or
            <tt class="option">--verbose</tt> switches are passed.</p><p>If the <tt class="option">--verbose</tt> switch is passed,
            the last committed revision and last committed author
            are displayed next.</p><p>The working copy path is always the final field, so
            it can include spaces.</p></div><div class="refsect1" lang="en"><a name="id2941687"></a><h2>Alternate Names</h2><p>stat, st</p></div><div class="refsect1" lang="en"><a name="id2941701"></a><h2>Changes</h2><p>Nothing</p></div><div class="refsect1" lang="en"><a name="id2941715"></a><h2>Accesses Repository</h2><p>Only if using <tt class="option">--show-updates</tt></p></div><div class="refsect1" lang="en"><a name="id2941733"></a><h2>Switches</h2><pre class="screen">
--show-updates (-u)
--verbose (-v)
--non-recursive (-N)
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
--no-ignore
          </pre></div><div class="refsect1" lang="en"><a name="id2941750"></a><h2>Examples</h2><p>This is the easiest way to find out what changes you
            have made to your working copy:</p><pre class="screen">
$ svn status wc
 M     wc/bar.c
A  +   wc/qax.c
          </pre><p>If you want to find out what files in your working
            copy are out-of-date, pass the
            <tt class="option">--show-updates</tt> switch (this will
            <span class="emphasis"><em>not</em></span> make any changes to your
            working copy).  Here you can see that
            <tt class="filename">wc/foo.c</tt> has changed in the
            repository since we last updated our working
            copy:</p><pre class="screen">
$ svn status --show-updates wc
 M           965    wc/bar.c
       *     965    wc/foo.c
A  +         965    wc/qax.c
Head revision:   981
          </pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p><tt class="option">--show-updates</tt>
            <span class="emphasis"><em>only</em></span> places an asterisk next to items
            that are out of date (that is, items that will be updated
            from the repository if you run <span><b class="command">svn
            update</b></span>).  <tt class="option">--show-updates</tt> does
            <span class="emphasis"><em>not</em></span> cause the status listing to
            reflect the repository's version of the item.</p></div><p>And finally, the most information you can get out of
            the status subcommand:</p><pre class="screen">
$ svn status --show-updates --verbose wc
 M           965       938 sally        wc/bar.c
       *     965       922 harry        wc/foo.c
A  +         965       687 harry        wc/qax.c
             965       687 harry        wc/zig.c
Head revision:   981
          </pre><p>For many more examples of <span><b class="command">svn status</b></span>,
            see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2941888"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn switch &#8212; Update working copy to a different URL.</p></div><div class="refsect1" lang="en"><a name="id2941904"></a><h2>Synopsis</h2><pre class="programlisting">svn switch URL [PATH]</pre></div><div class="refsect1" lang="en"><a name="id2941918"></a><h2>Description</h2><p>This subcommand updates your working copy to mirror
            a new URL&#8212;usually a URL which shares a common
            ancestor with your working copy, although not
            necessarily.  This is the Subversion way to move a
            working copy to a new branch.  See <a href="#svn-ch-4-sect-5" title="Switching a Working Copy">the section called &#8220;Switching a Working Copy&#8221;</a> for an in-depth look at
            switching.</p></div><div class="refsect1" lang="en"><a name="id2941946"></a><h2>Alternate Names</h2><p>sw</p></div><div class="refsect1" lang="en"><a name="id2941959"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2941973"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2941987"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--diff3-cmd CMD
--relocate
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2942004"></a><h2>Examples</h2><p>If you're currently inside the directory 'vendors'
            which was branched to 'vendors-with-fix' and you'd like
            to switch your working copy to that branch:</p><pre class="screen">
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
          </pre><p>And to switch back, just provide the URL to the
            location in the repository from which you originally
            checked out your working copy:</p><pre class="screen">
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U  myproj/foo.txt
U  myproj/bar.txt
U  myproj/baz.c
U  myproj/qux.c
Updated to revision 31.
          </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>You can just switch part of your working copy to a
              branch if you don't want to switch your entire working
              copy.</p></div><p>If the location of your repository changes and you
             have an existing working copy that you'd like to continue
             to use, you can use <span><b class="command">svn switch
             --relocate</b></span> to change your working copy from one
             URL to another:</p><pre class="screen">
$ svn checkout file:///tmp/repos test
A  test/a
A  test/b
&#8230;

$ mv repos newlocation
$ cd test/

$ svn update
svn: Couldn't open a repository.
svn: Unable to open an ra_local session to URL
svn: Unable to open repository 'file:///tmp/repos'

$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .
$ svn update
At revision 3.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2942091"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svn update &#8212; Updates your working copy.</p></div><div class="refsect1" lang="en"><a name="id2942108"></a><h2>Synopsis</h2><pre class="programlisting">svn update [PATH...]</pre></div><div class="refsect1" lang="en"><a name="id2942122"></a><h2>Description</h2><p><span><b class="command">svn update</b></span> brings changes from
            the repository into your working copy.  If no revision
            given, it brings your working copy up-to-date with the
            HEAD revision.  Otherwise, it synchronizes the working
            copy to the revision given by the
            <tt class="option">--revision</tt> switch.</p><p>For each updated item a line will start with a
            character reporting the action taken.  These characters
            have the following meaning:</p><div class="variablelist"><dl><dt><span class="term">A</span></dt><dd><p>Added</p></dd><dt><span class="term">D</span></dt><dd><p>Deleted</p></dd><dt><span class="term">U</span></dt><dd><p>Updated</p></dd><dt><span class="term">C</span></dt><dd><p>Conflict</p></dd><dt><span class="term">M</span></dt><dd><p>Merged</p></dd></dl></div><p>A character in the first column signifies an update
            to the actual file, while updates to the file's
            properties are shown in the second column.</p></div><div class="refsect1" lang="en"><a name="id2942270"></a><h2>Alternate Names</h2><p>up</p></div><div class="refsect1" lang="en"><a name="id2942284"></a><h2>Changes</h2><p>Working copy</p></div><div class="refsect1" lang="en"><a name="id2942298"></a><h2>Accesses Repository</h2><p>Yes</p></div><div class="refsect1" lang="en"><a name="id2942312"></a><h2>Switches</h2><pre class="screen">
--revision (-r) REV
--non-recursive (-N)
--quiet (-q)
--username USER
--password PASS
--no-auth-cache
--non-interactive
          </pre></div><div class="refsect1" lang="en"><a name="id2942329"></a><h2>Examples</h2><p>Pick up repository changes that have happened since
            your last update:</p><pre class="screen">
$ svn update
A  newdir/toggle.c
A  newdir/disclose.c
A  newdir/launch.c
D  newdir/README
Updated to revision 32.
          </pre><p>You can also update your working copy to an older
            revision (Subversion doesn't have the concept of
            &#8220;<span class="quote">sticky</span>&#8221; files like CVS does; see <a href="#svn-ap-a" title="Appendix A. Subversion for CVS Users">Appendix A, <i>Subversion for CVS Users</i></a>):</p><pre class="screen">
svn update -r30
A  newdir/README
D  newdir/toggle.c
D  newdir/disclose.c
D  newdir/launch.c
U  foo.c
Updated to revision 30.
          </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If you want to examine an older revision of a
              single file, you may want to use <span><b class="command">svn
              cat</b></span>.</p></div></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-8-sect-2"></a><span><b class="command">svnadmin</b></span></h2></div></div><div></div></div><p><span><b class="command">svnadmin</b></span> is the administrative tool for
      monitoring and repairing your Subversion repository.  For
      detailed information, see <a href="#svn-ch-5-sect-3.1.2" title="svnadmin">the section called &#8220;svnadmin&#8221;</a></p><p>Since <span><b class="command">svnadmin</b></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-2.1"></a><span><b class="command">svnadmin</b></span> Switches</h3></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term"><tt class="option">--bypass-hooks</tt></span></dt><dd><p>Bypass the repository hook system.</p></dd><dt><span class="term"><tt class="option">--copies</tt></span></dt><dd><p>Follow copy history when examining a path.</p></dd><dt><span class="term"><tt class="option">--in-repos-template ARG</tt></span></dt><dd><p>Specify a template for the repository structure when
              creating a new repository.</p><p>The &#8220;<span class="quote">in-repository</span>&#8221; templates specify
              the layout of the repository itself (which lives in
              Berkeley DB files inside the db/ directory) like
              /trunk, /branches, etc.  These templates can be used
              by an administrator or application to do an initial
              load of the repository (without invoking hooks). There
              is no default; the repository is built
              &#8220;<span class="quote">empty</span>&#8221; unless you tell it otherwise.
            </p></dd><dt><span class="term"><tt class="option">--incremental</tt></span></dt><dd><p>Dump a revision only as a diff against the
              previous revision, instead of the usual
              fulltext.</p></dd><dt><span class="term"><tt class="option">--on-disk-template <i class="replaceable"><tt>ARG</tt></i></tt></span></dt><dd><p>Specify a template to use for the on-disk
              structure (i.e. <tt class="filename">conf/</tt>,
              <tt class="filename">hooks/</tt>, etc.) of the repository
              you want to create.</p><p>The &#8220;<span class="quote">on-disk</span>&#8221; templates describe the
        repository directory itself. Each of the templates have a
        name, and the &#8220;<span class="quote">default</span>&#8221; on-disk template
        contains:</p><div class="itemizedlist"><ul type="disc"><li><p>default/</p></li><li><p>README.txt</p></li><li><p>dav/</p></li><li><p>format</p></li><li><p>hooks/</p></li><li><p>post-commit.tmpl</p></li><li><p>post-revprop-change.tmpl</p></li><li><p>pre-commit.tmpl</p></li><li><p>pre-revprop-change.tmpl</p></li><li><p>start-commit.tmpl</p></li><li><p>locks/</p></li><li><p>db.lock</p></li></ul></div><p>The typical usage for the on-disk structures is to
              predefine the hook scripts that will be created. For
              example, you could prepopulate the
              <tt class="literal">post-commit</tt> script with a commit
              mailer and backup script. Then, each time the
              administrator creates a new repository, she can refer
              to this new template which automagically includes all
              of the hooks.</p></dd><dt><span class="term"><tt class="option">--revision</tt> (<tt class="option">-r</tt>)
          <i class="replaceable"><tt>ARG</tt></i></span></dt><dd><p>Specify a particular revision to operate
              on.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-2.2"></a><span><b class="command">svnadmin</b></span> Subcommands</h3></div></div><div></div></div><div class="refentry" lang="en"><a name="id2942816"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin list-unused-dblogs &#8212; Ask Berkeley DB which logfiles can be safely
          deleted.</p></div><div class="refsect1" lang="en"><a name="id2942834"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin list-unused-dblogs REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2942848"></a><h2>Description</h2><p>Berkeley DB creates logs of all changes to the
            repository, which allow it to recover in the face of
            catastrophe.  Over time, the logfiles accumulate, although
            most are no longer used and can be deleted to reclaim disk
            space. See <a href="#svn-ch-5-sect-3.1.4" title="Berkeley DB Utilities">the section called &#8220;Berkeley DB Utilities&#8221;</a> for more
            information. </p></div><div class="refsect1" lang="en"><a name="id2942877"></a><h2>Examples</h2><p>Remove all unused logfiles from a repository:</p><pre class="screen">
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
        </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2942907"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin create &#8212; Create a new, empty repository at REPOS_PATH.</p></div><div class="refsect1" lang="en"><a name="id2942924"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin create REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2942938"></a><h2>Description</h2><p>Create a new, empty repository at the path provided.
              If the provided directory does not exist, it will be
              created for you.</p></div><div class="refsect1" lang="en"><a name="id2942955"></a><h2>Switches</h2><pre class="screen">
--on-disk-template arg
--in-repos-template arg
          </pre></div><div class="refsect1" lang="en"><a name="id2942970"></a><h2>Examples</h2><p>Creating a new repository is just this easy:</p><pre class="screen">
$ svnadmin create /usr/local/svn/repos
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2942997"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin dump &#8212; Dump the contents of filesystem to stdout.</p></div><div class="refsect1" lang="en"><a name="id2943014"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]</pre></div><div class="refsect1" lang="en"><a name="id2943029"></a><h2>Description</h2><p>Dump the contents of filesystem to stdout in a
            'dumpfile' portable format, sending feedback to stderr.
            Dump revisions LOWER rev through UPPER rev.  If no
            revisions are given, dump all revision trees.  If only
            LOWER is given, dump that one revision tree.  See <a href="#svn-ch-5-sect-3.4" title="Migrating a Repository">the section called &#8220;Migrating a Repository&#8221;</a> for a practical use. </p></div><div class="refsect1" lang="en"><a name="id2943057"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--incremental
          </pre></div><div class="refsect1" lang="en"><a name="id2943072"></a><h2>Examples</h2><p>Dump your whole repository:</p><pre class="screen">
$ svnadmin dump /usr/local/svn/repos
SVN-fs-dump-format-version: 1
Revision-number: 0
* Dumped revision 0.
Prop-content-length: 56
Content-length: 56
&#8230;
          </pre><p>Incrementally dump a single transaction from your
            repository: </p><pre class="screen">
$ svnadmin dump /usr/local/svn/repos -r 21 --incremental 
* Dumped revision 21.
SVN-fs-dump-format-version: 1
Revision-number: 21
Prop-content-length: 101
Content-length: 101
&#8230;
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943115"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin help</p></div><div class="refsect1" lang="en"><a name="id2943127"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin help [SUBCOMMAND...]</pre></div><div class="refsect1" lang="en"><a name="id2943141"></a><h2>Description</h2><p>This subcommand is useful when you're trapped on a
            desert island with neither a net connection nor a copy of
            this book.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943164"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin load &#8212; Read a
            &#8220;<span class="quote">dumpfile-formatted</span>&#8221; stream from
            stdin.</p></div><div class="refsect1" lang="en"><a name="id2943186"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin load REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2943200"></a><h2>Description</h2><p>Read a &#8220;<span class="quote">dumpfile</span>&#8221;-formatted stream from
            stdin, committing new revisions into the repository's
            filesystem.  Send progress feedback to stdout.</p></div><div class="refsect1" lang="en"><a name="id2943222"></a><h2>Example</h2><p>This shows the beginning of loading a repository from
            a backup file (made, of course, with <span><b class="command">svn
            dump</b></span>):</p><pre class="screen">
$ svnadmin load /usr/local/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
&#8230;
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943260"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin lstxns &#8212; Print the names of all uncommitted transactions.</p></div><div class="refsect1" lang="en"><a name="id2943277"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin lstxns REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2943292"></a><h2>Description</h2><p>Print the names of all uncommitted transactions.  See
            <a href="#svn-ch-5-sect-3.2" title="Repository Cleanup">the section called &#8220;Repository Cleanup&#8221;</a> for information on how
            uncommitted transactions are created and what you should
            do with them.</p></div><div class="refsect1" lang="en"><a name="id2943318"></a><h2>Examples</h2><p>List all outstanding transactions in a
            repository.</p><pre class="screen">
$ svnadmin lstxns /usr/local/svn/repos/ 
1w
1x
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943344"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin recover &#8212; Recovers any lost state in a repository.</p></div><div class="refsect1" lang="en"><a name="id2943362"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin recover REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2943376"></a><h2>Description</h2><p>Run this command if you get an error indicating that
            your repository needs to be recovered.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Only run this when you are <span class="emphasis"><em>absolutely
              certain</em></span> you're the only process accessing the
              repository&#8212;it requires exclusive access.  See
              <a href="#svn-ch-5-sect-3.3" title="Repository Recovery">the section called &#8220;Repository Recovery&#8221;</a> for a detailed
              explanation of repository recovery.</p></div></div><div class="refsect1" lang="en"><a name="id2943419"></a><h2>Examples</h2><p>Recover a hung repository:</p><pre class="screen">
$ svnadmin recover /usr/local/svn/repos/ 
Acquiring exclusive lock on repository db.
Recovery is running, please stand by...
Recovery completed.
The latest repos revision is 34.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943447"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin rmtxns &#8212; Deletes transactions from a repository.</p></div><div class="refsect1" lang="en"><a name="id2943464"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin rmtxns REPOS_PATH TXN_NAME...</pre></div><div class="refsect1" lang="en"><a name="id2943479"></a><h2>Description</h2><p>Deletes outstanding transactions from a repository.
            This is covered in detail in <a href="#svn-ch-5-sect-3.2" title="Repository Cleanup">the section called &#8220;Repository Cleanup&#8221;</a></p></div><div class="refsect1" lang="en"><a name="id2943501"></a><h2>Examples</h2><p>Remove named transactions:</p><pre class="screen">
$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x
          </pre><p>Fortunately, the output of svn lstxns works great as
            the input for rmtxns:</p><pre class="screen">
$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`
          </pre><p>Which will remove all uncommitted transactions from
            your repository.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2943546"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnadmin setlog &#8212; Set the log-message on a revision.</p></div><div class="refsect1" lang="en"><a name="id2943563"></a><h2>Synopsis</h2><pre class="programlisting">svnadmin setlog REPOS_PATH -r REVISION FILE</pre></div><div class="refsect1" lang="en"><a name="id2943578"></a><h2>Description</h2><p>Set the log-message on revision REVISION to the
            contents of FILE.</p><p>This is similar to using <span><b class="command">svn propset
            --revprop</b></span> to set the <tt class="literal">svn:log</tt> property
            on a revision, except that you can also use the option
            <tt class="option">--bypass-hooks</tt> to avoid running any pre- or
            post-commit hooks, which is useful if the modification of
            revision properties has not been enabled in the pre-revprop-change
            hook.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Revision properties are not under version control,
              so this command will permanently overwrite the previous
              log message.</p></div></div><div class="refsect1" lang="en"><a name="id2943636"></a><h2>Switches</h2><pre class="screen">
--revision (-r) ARG
--bypass-hooks
          </pre></div><div class="refsect1" lang="en"><a name="id2943651"></a><h2>Examples</h2><p>Set the log message for revision 19 to the contents of
            the file 'msg':</p><pre class="screen">
$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg
          </pre></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-8-sect-3"></a><span><b class="command">svnlook</b></span></h2></div></div><div></div></div><p><span><b class="command">svnlook</b></span> is a command-line utility for
      examining different aspects of a Subversion repository.  It
      does not make any changes to the repository&#8212;it's just
      used for &#8220;<span class="quote">peeking</span>&#8221;.
      <span><b class="command">svnlook</b></span> is typically used by the
      repository hooks, but a repository administrator might find it
      useful for diagnostic purposes.</p><p>Since <span><b class="command">svnlook</b></span> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</p><p>If no revision or transaction is specified,
      <span><b class="command">svnlook</b></span> defaults to the youngest (most
      recent) revision of the repository.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-3.1"></a><span><b class="command">svnlook</b></span> Switches</h3></div></div><div></div></div><p>Switches in <span><b class="command">svnlook</b></span> are global, just
        like in <span><b class="command">svn</b></span> and
        <span><b class="command">svnadmin</b></span>, however, most switches only
        apply to one subcommand since the functionality of
        <span><b class="command">svnlook</b></span> is (intentionally) limited in
        scope.</p><div class="variablelist"><dl><dt><span class="term"><tt class="option">--no-diff-deleted</tt></span></dt><dd><p>Prevents <span><b class="command">svnlook</b></span> from printing
              differences for deleted files.  The default behavior
              when a file is deleted in a transaction/revision is
              to print the same differences that you would see if
              you had left the file but removed all the content.</p></dd><dt><span class="term"><tt class="option">--revision</tt>
            (<tt class="option">-r</tt>)</span></dt><dd><p>Specify a particular revision number that you wish
              to examine.</p></dd><dt><span class="term"><tt class="option">--transaction</tt>
            (<tt class="option">-t</tt>)</span></dt><dd><p>Specify a particular transaction id that you wish to
              examine. </p></dd><dt><span class="term"><tt class="option">--show-ids</tt></span></dt><dd><p>Show the filesystem node revision IDs for each path in the filesystem
              tree.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-8-sect-3.2"></a><span><b class="command">svnlook</b></span> Subcommands</h3></div></div><div></div></div><div class="refentry" lang="en"><a name="id2943962"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook author &#8212; Prints the author.</p></div><div class="refsect1" lang="en"><a name="id2943979"></a><h2>Synopsis</h2><pre class="programlisting">svnlook author REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2943993"></a><h2>Description</h2><p>Prints the author of a revision or transaction in
            the repository.</p></div><div class="refsect1" lang="en"><a name="id2944008"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944023"></a><h2>Examples</h2><p><span><b class="command">svnlook author</b></span> is handy, but not
            very exciting:</p><pre class="screen">
$ svnlook author -r 40 /usr/local/svn/repos 
sally
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944056"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook cat &#8212; Print the contents of a file.</p></div><div class="refsect1" lang="en"><a name="id2944074"></a><h2>Synopsis</h2><pre class="programlisting">svnlook cat REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" lang="en"><a name="id2944088"></a><h2>Description</h2><p>Print the contents of a file.</p></div><div class="refsect1" lang="en"><a name="id2944103"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944118"></a><h2>Examples</h2><p>This shows the contents of a file in transation
            <tt class="literal">ax8</tt>, located at 
            <tt class="filename">/trunk/README</tt>:</p><pre class="screen">
$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
&#8230;
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944166"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook changed &#8212; Print the paths that were changed.</p></div><div class="refsect1" lang="en"><a name="id2944183"></a><h2>Synopsis</h2><pre class="programlisting">svnlook changed REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944198"></a><h2>Description</h2><p>Print the paths that were changed in a particular
            revision or transaction, as well as an &#8220;<span class="quote">svn
            update-style</span>&#8221; status letter in the first column:
            <tt class="literal">A</tt> for added, <tt class="literal">D</tt> for
            deleted, and <tt class="literal">U</tt> for updated
            (modified).</p></div><div class="refsect1" lang="en"><a name="id2944243"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944258"></a><h2>Examples</h2><p>This shows a list of all the changed files in
            revision 39 of a test repository:</p><pre class="screen">
$ svnlook changed -r 39 /usr/local/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944288"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook date &#8212; Print the datestamp.</p></div><div class="refsect1" lang="en"><a name="id2944305"></a><h2>Synopsis</h2><pre class="programlisting">svnlook date REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944320"></a><h2>Description</h2><p>Print the datestamp of a revision or transaction in
            a repository.</p></div><div class="refsect1" lang="en"><a name="id2944335"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944350"></a><h2>Examples</h2><p>This shows the date of revision 40 of a test
            repository:</p><pre class="screen">            
$ svnlook date -r 40 /tmp/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944378"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook diff &#8212; Prints differences of changed files and properties.</p></div><div class="refsect1" lang="en"><a name="id2944396"></a><h2>Synopsis</h2><pre class="programlisting">svnlook diff REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944410"></a><h2>Description</h2><p>Prints GNU-style differences of changed files and
            properties in a repository.</p></div><div class="refsect1" lang="en"><a name="id2944425"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--no-diff-deleted
          </pre></div><div class="refsect1" lang="en"><a name="id2944441"></a><h2>Examples</h2><p>This shows a newly added (empty) file, a deleted
          file, and a copied file:</p><pre class="screen">
$ svnlook diff -r 40 /usr/local/svn/repos/
Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)

Added: trunk/vendors/deli/soda.txt
==============================================================================

Modified: trunk/vendors/deli/sandwich.txt
==============================================================================
--- trunk/vendors/deli/sandwich.txt	(original)
+++ trunk/vendors/deli/sandwich.txt	2003-02-22 17:45:04.000000000 -0600
@@ -0,0 +1 @@
+Don't forget the mayo!

Deleted: trunk/vendors/deli/chips.txt
==============================================================================

Deleted: trunk/vendors/deli/pickle.txt
==============================================================================
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944482"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook dirs-changed &#8212; Print the directories that were themselves changed.</p></div><div class="refsect1" lang="en"><a name="id2944499"></a><h2>Synopsis</h2><pre class="programlisting">svnlook dirs-changed REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944514"></a><h2>Description</h2><p>Print the directories that were themselves changed
            (property edits) or whose file children were
            changed.</p></div><div class="refsect1" lang="en"><a name="id2944530"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944545"></a><h2>Examples</h2><p>This shows the directories that changed in
            revision 40 in our sample repository:</p><pre class="screen">
$ svnlook dirs-changed -r 40 /usr/local/svn/repos
trunk/vendors/deli/
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944573"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook help </p></div><div class="refsect1" lang="en"><a name="id2944585"></a><h2>Synopsis</h2><pre class="programlisting">Also svnlook -h and svnlook -?.</pre></div><div class="refsect1" lang="en"><a name="id2944600"></a><h2>Description</h2><p>Displays the help message for svnlook.  This
            command, like it's brother <span><b class="command">svn help</b></span>, is
            also your friend, even though you never call it anymore
            and forgot to invite it to your last party.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944631"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook history &#8212; Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" lang="en"><a name="id2944650"></a><h2>Synopsis</h2><pre class="programlisting">svnlook history REPOS_PATH 
            [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="en"><a name="id2944665"></a><h2>Description</h2><p>Print information about the history of a path in
            the repository (or the root directory if no path is
            supplied).</p></div><div class="refsect1" lang="en"><a name="id2944682"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--show-ids
          </pre></div><div class="refsect1" lang="en"><a name="id2944696"></a><h2>Examples</h2><p>This shows the history output for the path
            <tt class="filename">/tags/1.0</tt> as of revision 15 in our
            sample repository.</p><pre class="screen">
$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      19   /tags/1.0 &lt;1.2.12&gt;
      17   /branches/1.0-rc2 &lt;1.1.10&gt;
      16   /branches/1.0-rc2 &lt;1.1.x&gt;
      14   /trunk &lt;1.0.q&gt;
      13   /trunk &lt;1.0.o&gt;
      11   /trunk &lt;1.0.k&gt;
       9   /trunk &lt;1.0.g&gt;
       8   /trunk &lt;1.0.e&gt;
       7   /trunk &lt;1.0.b&gt;
       6   /trunk &lt;1.0.9&gt;
       5   /trunk &lt;1.0.7&gt;
       4   /trunk &lt;1.0.6&gt;
       2   /trunk &lt;1.0.3&gt;
       1   /trunk &lt;1.0.2&gt;
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944745"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook info &#8212; Print the author, datestamp, log message size, and log message.</p></div><div class="refsect1" lang="en"><a name="id2944763"></a><h2>Synopsis</h2><pre class="programlisting">svnlook info REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944777"></a><h2>Description</h2><p>Print the author, datestamp, log message size, and
            log message.</p></div><div class="refsect1" lang="en"><a name="id2944793"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944807"></a><h2>Examples</h2><p>This shows the info output for revision 40 in our sample repository.</p><pre class="screen">
$ svnlook info -r 40 /usr/local/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
15
Rearrange lunch.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944836"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook log &#8212; Print the log message.</p></div><div class="refsect1" lang="en"><a name="id2944853"></a><h2>Synopsis</h2><pre class="programlisting">svnlook log REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2944867"></a><h2>Description</h2><p>Print the log message.</p></div><div class="refsect1" lang="en"><a name="id2944882"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
          </pre></div><div class="refsect1" lang="en"><a name="id2944897"></a><h2>Examples</h2><p>This shows the log output for revision 40 in our sample
          repository:</p><pre class="screen">
$ svnlook log /tmp/repos/
Rearrange lunch.
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2944924"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook proplist &#8212; Print the names and values of versioned file and
            directory properties.</p></div><div class="refsect1" lang="en"><a name="id2944943"></a><h2>Synopsis</h2><pre class="programlisting">svnlook proplist REPOS_PATH PATH_IN_REPOS</pre></div><div class="refsect1" lang="en"><a name="id2944957"></a><h2>Description</h2><p>List the properties of a path in the repository.  With
            -v, show the property values too.</p></div><div class="refsect1" lang="en"><a name="id2944973"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--verbose (-v)
          </pre></div><div class="refsect1" lang="en"><a name="id2944988"></a><h2>Examples</h2><p>This shows the names of properties set on the file
            <tt class="filename">/trunk/README</tt> in the HEAD revision:</p><pre class="screen">
$ svnlook proplist /usr/local/svn/repos /trunk/README
  original-author
  svn:mime-type
          </pre><p>This is the same command as in the previous example,
            but this time showing the property values as well:</p><pre class="screen">
$ svnlook proplist /usr/local/svn/repos /trunk/README
  original-author : fitz
  svn:mime-type : text/plain
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2945038"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook tree &#8212; Print the tree</p></div><div class="refsect1" lang="en"><a name="id2945055"></a><h2>Synopsis</h2><pre class="programlisting">svnlook tree REPOS_PATH [PATH_IN_REPOS]</pre></div><div class="refsect1" lang="en"><a name="id2945070"></a><h2>Description</h2><p>Print the tree, starting at PATH_IN_REPOS (if
            supplied, at the root of the tree otherwise), optionally
            showing node revision ids.</p></div><div class="refsect1" lang="en"><a name="id2945086"></a><h2>Switches</h2><pre class="screen">
--revision (-r)
--transaction (-t)
--show-ids
          </pre></div><div class="refsect1" lang="en"><a name="id2945101"></a><h2>Examples</h2><p>This shows the tree output (with node-IDs) for revision
            40 in our sample repository:</p><pre class="screen">
$ svnlook tree -r 40 /usr/local/svn/repos --show-ids
/ &lt;0.0.2j&gt;
 trunk/ &lt;p.0.2j&gt;
  vendors/ &lt;q.0.2j&gt;
   deli/ &lt;1g.0.2j&gt;
    egg.txt &lt;1i.e.2j&gt;
    soda.txt &lt;1k.0.2j&gt;
    sandwich.txt &lt;1j.0.2j&gt;
          </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="id2945133"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>svnlook youngest &#8212; Print the youngest revision number.</p></div><div class="refsect1" lang="en"><a name="id2945150"></a><h2>Synopsis</h2><pre class="programlisting">svnlook youngest REPOS_PATH</pre></div><div class="refsect1" lang="en"><a name="id2945164"></a><h2>Description</h2><p>Print the youngest revision number of a repository.</p></div><div class="refsect1" lang="en"><a name="id2945179"></a><h2>Examples</h2><p>This shows the youngest revision of our sample
            repository:</p><pre class="screen">          
$ svnlook youngest /tmp/repos/ 
42
          </pre></div></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2934587" href="#id2934587">36</a>] </sup>Yes, yes, you don't need a subcommand to use the
      <tt class="option">--version</tt> switch, but we'll get to that in just
      a minute.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-a"></a>Appendix A. Subversion for CVS Users</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-app-a-sect-1">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-2">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-3">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-4">Distinction Between Status and Update</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-5">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-6">Meta-data Properties</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-7">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-8">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn-app-a-sect-9">Versioned Modules</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>This appendix is a guide for CVS users new to Subversion.
      It's essentially a list of differences between the two systems
      as &#8220;<span class="quote">viewed from 10,000 feet</span>&#8221;. For each section, we
      provide backreferences to relevant chapters when
      possible.</p><p>Although the goal of Subversion is to take over the current
      and future CVS user base, some new features and design changes
      were required to fix certain &#8220;<span class="quote">broken</span>&#8221; behaviors
      that CVS had.  This means that, as a CVS user, you may need to
      break habits&#8212;ones that you forgot were odd to begin
      with.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-1"></a>Revision Numbers Are Different Now</h2></div></div><div></div></div><p>In CVS, revision numbers are per-file.  This is because CVS
      uses RCS as a backend; each file has a corresponding RCS file in
      the repository, and the repository is roughly laid out according
      to the structure of your project tree.</p><p>In Subversion, the repository looks like a single
      filesystem.  Each commit results in an entirely new filesystem
      tree; in essence, the repository is an array of trees.  Each of
      these trees is labeled with a single revision number.  When
      someone talks about &#8220;<span class="quote">revision 54</span>&#8221;, they're talking
      about a particular tree (and indirectly, the way the filesystem
      looked after the 54th commit).</p><p>Technically, it's not valid to talk about &#8220;<span class="quote">revision 5
      of <tt class="filename">foo.c</tt></span>&#8221;.  Instead, one would say
      &#8220;<span class="quote"><tt class="filename">foo.c</tt> as it appears in revision
      5</span>&#8221;. Also, be careful when making assumptions about the
      evolution of a file.  In CVS, revisions 5 and 6 of
      <tt class="filename">foo.c</tt> are always different.  In Subversion,
      it's most likely that <tt class="filename">foo.c</tt> did
      <span class="emphasis"><em>not</em></span> change between revisions 5 and
      6.</p><p>For more details on this topic, see <a href="#svn-ch-2-sect-3.2" title="Revisions">the section called &#8220;Revisions&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-2"></a>Directory Versions</h2></div></div><div></div></div><p>Subversion tracks tree structures, not just file contents.
      It's one of the biggest reasons Subversion was written to
      replace CVS.</p><p>Here's what this means to you, as a former CVS user:</p><div class="itemizedlist"><ul type="disc"><li><p>The <span><b class="command">svn add</b></span> and <span><b class="command">svn
          rm</b></span> commands work on directories now, just as they
          work on files.  So do <span><b class="command">svn copy</b></span> and
          <span><b class="command">svn move</b></span>.  However, these commands do
          <span class="emphasis"><em>not</em></span> cause any kind of immediate change
          in the repository.  Instead, the working items are simply
          &#8220;<span class="quote">scheduled</span>&#8221; for addition or deletion.  No
          repository changes happen until you run <span><b class="command">svn
          commit</b></span>.</p></li><li><p>Directories aren't dumb containers anymore; they have
          revision numbers like files.  (Or more properly, it's
          correct to talk about &#8220;<span class="quote">directory
          <tt class="filename">foo/</tt> in revision 5</span>&#8221;.)</p></li></ul></div><p>Let's talk more about that last point.  Directory versioning
      is a hard problem; because we want to allow mixed-revision
      working copies, there are some limitations on how far we can
      abuse this model.</p><p>From a theoretical point of view, we define &#8220;<span class="quote">revision
        5 of directory <tt class="filename">foo</tt></span>&#8221; to mean a
      specific collection of directory-entries and properties.  Now
      suppose we start adding and removing files from
      <tt class="filename">foo</tt>, and then commit.  It would be a lie
      to say that we still have revision 5 of
      <tt class="filename">foo</tt>.  However, if we bumped
      <tt class="filename">foo</tt>'s revision number after the commit,
      that would be a lie too; there may be other changes to
      <tt class="filename">foo</tt> we haven't yet received, because we
      haven't updated yet.</p><p>Subversion deals with this problem by quietly tracking
      committed adds and deletes in the <tt class="filename">.svn</tt>
      area.  When you eventually run <span><b class="command">svn update</b></span>,
      all accounts are settled with the repository, and the
      directory's new revision number is set correctly.
      <span class="emphasis"><em>Therefore, only after an update is it truly safe to
        say that you have a &#8220;<span class="quote">perfect</span>&#8221; revision of a
        directory.</em></span> Most of the time, your working copy will
      contain &#8220;<span class="quote">imperfect</span>&#8221; directory revisions.</p><p>Similarly, a problem arises if you attempt to commit
      property changes on a directory.  Normally, the commit would
      bump the working directory's local revision number.  But again,
      that would be a lie, because there may be adds or deletes that
      the directory doesn't yet have, because no update has happened.
      <span class="emphasis"><em>Therefore, you are not allowed to commit
      property-changes on a directory unless the directory is
      up-to-date.</em></span></p><p>For more discussion about the limitations of directory
    versioning, see <a href="#svn-ch-2-sect-3.4" title="The Limitations of Mixed Revisions">the section called &#8220;The Limitations of Mixed Revisions&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-3"></a>More Disconnected Operations</h2></div></div><div></div></div><p>In recent years, disk space has become outrageously cheap
      and abundant, but network bandwidth has not.  Therefore, the
      Subversion working copy has been optimized around the scarcer
      resource.</p><p>The <tt class="filename">.svn</tt> administrative directory
      serves the same purpose as the <tt class="filename">CVS</tt>
      directory, except that it also stores read-only,
      &#8220;<span class="quote">pristine</span>&#8221; copies of your files.  This allows you
      to do many things off-line:</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">svn status</b></span></span></dt><dd><p>Shows you any local changes you've made (see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>)</p></dd><dt><span class="term"><span><b class="command">svn diff</b></span></span></dt><dd><p>Shows you the details of your changes (see <a href="#svn-ch-3-sect-4.3.2" title="svn diff">the section called &#8220;svn diff&#8221;</a>)</p></dd><dt><span class="term"><span><b class="command">svn revert</b></span></span></dt><dd><p>Removes your local changes (see <a href="#svn-ch-3-sect-4.3.3" title="svn revert">the section called &#8220;svn revert&#8221;</a>)</p></dd></dl></div><p>Also, the cached pristine files allow the Subversion client
      to send differences when committing, which CVS cannot do.</p><p>The last subcommand in the list is new; it will not only
      remove local mods, but it will un-schedule operations such as
      adds and deletes.  It's the preferred way to revert a file;
      running <span><b class="command">rm file; svn update</b></span> will still work, but
      it blurs the purpose of updating.  And, while we're on this
      subject&#8230;

    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-4"></a>Distinction Between Status and Update</h2></div></div><div></div></div><p>In Subversion, we've tried to erase a lot of the confusion
      between the <span><b class="command">cvs status</b></span> and
      <span><b class="command">cvs update</b></span> commands.</p><p>The <span><b class="command">cvs status</b></span> command has two purposes:
      first, to show the user any local modifications in the working
      copy, and second, to show the user which files are out-of-date.
      Unfortunately, because of CVS's hard-to-read status output, many
      CVS users don't take advantage of this command at all.  Instead,
      they've developed a habit of running <span><b class="command">cvs up</b></span>
      to quickly see their mods.  Of course, this has the side effect
      of merging repository changes that you may not be ready to deal
      with!</p><p>With Subversion, we've tried to remove this muddle by making
      the output of <span><b class="command">svn status</b></span> easy to read for
      both humans and parsers.  Also, <span><b class="command">svn update</b></span>
      only prints information about files that are updated,
      <span class="emphasis"><em>not</em></span> local modifications.</p><p>Here's a quick guide to <span><b class="command">svn status</b></span>.  We
      encourage all new Subversion users to use it early and often:</p><div class="variablelist"><p class="title"><b><span><b class="command">svn status</b></span> Prints All Files That Have
        Local Modifications: The Network is not Accessed by
        Default</b></p><dl><dt><span class="term"><tt class="option">-u</tt></span></dt><dd><p>Add out-of-dateness information from repository.</p></dd><dt><span class="term"><tt class="option">-v</tt></span></dt><dd><p>Show <span class="emphasis"><em>all</em></span> entries under
            version control.</p></dd><dt><span class="term"><tt class="option">-N</tt></span></dt><dd><p>Nonrecursive.</p></dd></dl></div><p>The status command has two output formats.  In the default
      &#8220;<span class="quote">short</span>&#8221; format, local modifications look like
      this:</p><pre class="screen">
% svn status
M     ./foo.c
M     ./bar/baz.c
    </pre><p>If you specify the <tt class="option">--show-updates</tt>
      (<tt class="option">-u</tt>) switch, a longer output format is
      used:</p><pre class="screen">
% svn status -u
M             1047    ./foo.c
       *      1045    ./faces.html
       *         -    ./bloo.png
M             1050    ./bar/baz.c
Head revision:   1066
    </pre><p>In this case, two new columns appear.  The second column
      contains an asterisk if the file or directory is out-of-date.
      The third column shows the working-copy's revision number of the
      item.  In the example above, the asterisk indicates that
      <tt class="filename">faces.html</tt> would be patched if we updated,
      and that <tt class="filename">bloo.png</tt> is a newly added file in
      the repository.  (The <span><b class="command">-</b></span> next to bloo.png
      means that it doesn't yet exist in the working copy.)</p><p>Lastly, here's a quick summary of the most common status codes that
      you may see:</p><pre class="screen">
A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local modifications
C    Resource has conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is external to this working copy (comes from another
       repository.  See <a href="#svn-ch-6-sect-2.3.6" title="svn:externals">the section called &#8220;svn:externals&#8221;</a>)
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
    </pre><p>Subversion has combined the CVS <span><b class="command">P</b></span> and
      <span><b class="command">U</b></span> codes into just <span><b class="command">U</b></span>.  When
      a merge or conflict occurs, Subversion simply prints
      <span><b class="command">G</b></span> or <span><b class="command">C</b></span>, rather than a
      whole sentence about it.</p><p>For a more detailed discussion of <span><b class="command">svn
    status</b></span>, see <a href="#svn-ch-3-sect-4.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-5"></a>Branches and Tags</h2></div></div><div></div></div><p>Subversion doesn't distinguish between filesystem space and
      &#8220;<span class="quote">branch</span>&#8221; space; branches and tags are ordinary
      directories within the filesystem.  This is probably the single
      biggest mental hurdle a CVS user will need to climb.  Read all
      about it in <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-6"></a>Meta-data Properties</h2></div></div><div></div></div><p>A new feature of Subversion is that you can attach arbitrary
      metadata to files and directories.  We refer to this data as
      <i class="firstterm">properties</i>, and they can be thought of as
      collections of arbitrary name/value pairs attached to each item
      in your working copy.</p><p>To set or get a property name, use the <span><b class="command">svn
      propset</b></span> and <span><b class="command">svn propget</b></span>
      subcommands.  To list all properties on an object, use
      <span><b class="command">svn proplist</b></span>.</p><p>For more information, see <a href="#svn-ch-6-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-7"></a>Conflict Resolution</h2></div></div><div></div></div><p>CVS marks conflicts with in-line &#8220;<span class="quote">conflict
        markers</span>&#8221;, and prints a <span><b class="command">C</b></span> during an
        update.  Historically, this has caused problems, because CVS
        isn't doing enough.  Many users forget about (or don't see)
        the <span><b class="command">C</b></span> after it whizzes by on their
        terminal.  They often forget that the conflict-markers are
        even present, and then accidentally commit files containing
        conflict-markers.</p><p>Subversion solves this problem by making conflicts more
      tangible.  It remembers that a file is in a state of conflict,
      and won't allow you to commit your changes until you run
      <span><b class="command">svn resolved</b></span>.  See <a href="#svn-ch-3-sect-4.4" title="Resolve Conflicts (Merging Others' Changes)">the section called &#8220;Resolve Conflicts (Merging Others' Changes)&#8221;</a> for more details.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-8"></a>Binary Files and Translation</h2></div></div><div></div></div><p>In the most general sense, Subversion handles binary files
      more gracefully than CVS does.  Because CVS uses RCS, it can
      only store successive full copies of a changing binary file.
      But internally, Subversion expresses differences between files
      using a binary-differencing algorithm, regardless of whether they
      contain textual or binary data.  That means that all files are
      stored differentially (compressed) in the repository, and small
      differences are always sent over the network.</p><p>CVS users have to mark binary files with
      <tt class="option">-kb</tt> flags, to prevent data from being garbled
      (due to keyword expansion and line-ending translations).  They
      sometimes forget to do this.</p><p>Subversion takes the more paranoid route: first, it never
      performs any kind of keyword or line-ending translation unless
      you explicitly ask it do so (see <a href="#svn-ch-6-sect-2.3.4" title="svn:keywords">the section called &#8220;svn:keywords&#8221;</a> and <a href="#svn-ch-6-sect-2.3.5" title="svn:eol-style">the section called &#8220;svn:eol-style&#8221;</a> for more details).  By default,
      Subversion treats all file data as literal byte strings, and
      files are always stored in the repository in an untranslated
      state.</p><p>Second, Subversion maintains an internal notion of whether a
      file is &#8220;<span class="quote">text</span>&#8221; or &#8220;<span class="quote">binary</span>&#8221; data, but
      this notion is <span class="emphasis"><em>only</em></span> extant in the working
      copy.  During an <span><b class="command">svn update</b></span>, Subversion will
      perform contextual merges on locally modified text files, but
      will not attempt to do so for binary files.</p><p>To determine whether a contextual merge is possible,
      Subversion examines the <tt class="literal">svn:mime-type</tt>
      property.  If the file has no <tt class="literal">svn:mime-type</tt>
      property, or has a mime-type that is textual (e.g. text/*),
      Subversion assumes it is text.  Otherwise, Subversion assumes
      the file is binary.  Subversion also helps users by running a
      binary-detection algorithm in the <span><b class="command">svn import</b></span>
      and <span><b class="command">svn add</b></span> commands.  These commands will
      make a good guess and then (possibly) set a binary
      <tt class="literal">svn:mime-type</tt> property on the file being
      added.  (If Subversion guesses wrong, the user can always remove
      or hand-edit the property.)</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-a-sect-9"></a>Versioned Modules</h2></div></div><div></div></div><p>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means that if somebody changes the
      definition of a module, then a call to <span><b class="command">svn update</b></span>
      will update the working copy appropriately.</p><p>Subversion defines modules as a list of directories within a
      directory property:  see <a href="#svn-ch-6-sect-3" title="Externals Definitions">the section called &#8220;Externals Definitions&#8221;</a>.</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-b"></a>Appendix B. CVS Repository Migration</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ap-b-sect-1">Requirements</a></span></dt><dt><span class="sect1"><a href="#svn-ap-b-sect-2">Running cvs2svn.py</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Since Subversion aims to be the successor to CVS, it only
      makes sense to provide tools to help that migration.  Subversion
      has a script that migrates data from a CVS repository to a
      Subversion repository.  Yes, you <span class="emphasis"><em>can</em></span> take
      your CVS history with you into the brave new world.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-b-sect-1"></a>Requirements</h2></div></div><div></div></div><p>The tool is called <tt class="filename">cvs2svn.py</tt>, and it's a
      python script that lives within Subversion's source tree in the
      <tt class="filename">tools</tt> subdirectory.  In order to run this
      program, you need a couple of external things:</p><div class="variablelist"><dl><dt><span class="term">python 2.0</span></dt><dd><p>Make sure you have python 2.0 or later
            installed.  You can get the latest from <tt class="systemitem">http://www.python.org/</tt>.</p></dd><dt><span class="term"><tt class="filename">rcsparse.py</tt></span></dt><dd><p>This is a python module for parsing RCS files,
            and is part of the ViewCVS project.  It's needed to read
            your CVS repository.  For convenience, a copy is provided
            in the same directory as <tt class="filename">cvs2svn.py</tt>,
            although a more recent version may be available from the
            ViewCVS project&#8212; <tt class="systemitem">http://viewcvs.sf.net/.</tt>.  Simply
            drop this module into a place where python can find it,
            somewhere like
            <tt class="filename">/usr/local/lib/python2.2/</tt>.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-b-sect-2"></a>Running cvs2svn.py</h2></div></div><div></div></div><p>Because CVS doesn't have atomic commits,
      <tt class="filename">cvs2svn.py</tt> has the difficult job of
      deducing them.  It does this by examining RCS files and looking
      for per-file revisions with identical log messages.  If two RCS
      revisions have the same log message, and were committed at
      nearly the same time (say, within a couple minutes of each
      other), then <tt class="filename">cvs2svn.py</tt> places them into a
      common change &#8220;<span class="quote">group</span>&#8221;, and commits the change-group
      to a new Subversion repository as a single revision.</p><p>The previous explanation is a bit of a simplification;
      there's much more bookkeeping to do than that.  In fact,
      <tt class="filename">cvs2svn.py</tt> does its work in multiple
      &#8220;<span class="quote">passes</span>&#8221;, creating large amounts of temporary data
      on disk.  If you interrupt the script, you can pass the
      <tt class="option">-p</tt> option to script later on, indicating which
      pass to resume with.</p><p>Invoking the script is simple:</p><pre class="screen">
$ svnadmin create /new/svn/repos
$ cvs2svn.py -s /new/svn/repos /cvs/repos
&#8230;
    </pre><p>The conversion take anywhere from several minutes to dozens
      of hours, depending on the size of your CVS repository.  When
      run on Subversion's own CVS repository (the first year of
      Subversion's history, before it became self-hosting), it takes
      about 30 minutes, and commits about 3000 revisions to the
      Subversion repository.</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-c"></a>Appendix C. Troubleshooting</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ap-c-sect-1">Common Problems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-c-sect-1.2">Problems Using Subversion</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-1.3">Problems Building Subversion</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-c-sect-1"></a>Common Problems</h2></div></div><div></div></div><p>There are a number of problems you may run into in the
        course of installing and using Subversion.  Some of these will
        be resolved once you get a better idea of how Subversion does
        things, while others are caused because you're used to the way
        that other version control systems work.  Still other problems
        might be unsolvable due to bugs in some of the operating
        systems that Subversion runs on (considering the wide array of
        OS'es that Subversion runs on, it's amazing that we don't
        encounter many more of these).</p><p>The following list has been compiled over the course of
        several years of Subversion usage, and they cover just about
        every frequently occurring problem that you'll see in
        Subversion&#8212;from building, to installing, to using
        Subversion.  If you can't find the problem you're having here,
        or you've tried everything we recommend with no success, send
        mail to <tt class="email">&lt;<a href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</tt> with a
        detailed description of the problem you're having
        <sup>[<a name="id2957943" href="#ftn.id2957943">37</a>]</sup> </p><div class="itemizedlist"><p class="title"><b>Problems Using Subversion</b></p><ul type="disc"><li><p>Every time I try to access my repository,
            <span><b class="command">svn</b></span> just hangs.</p></li><li><p>Every time I try to run <span><b class="command">svn</b></span>, it
            says my working copy is locked.</p></li><li><p>I'm getting errors finding or opening a repository,
            but I know my repository URL is correct.</p></li><li><p>How can I specify a Windows drive letter in a
            <tt class="literal">file://</tt> URL?</p></li><li><p>I'm having trouble doing write operations to a
            Subversion repository over a network.</p></li><li><p>Under Windows XP, the Subversion server sometimes
            seems to send out corrupted data.</p></li><li><p>What is the best method of doing a network trace of
            the conversation between a Subversion client and
            server?</p></li></ul></div><div class="itemizedlist"><p class="title"><b>Problems Building Subversion</b></p><ul type="disc"><li><p>I just built the distribution binary, and when I try
            to check out Subversion, I get an error about an
            &#8220;<span class="quote">Unrecognized URL scheme</span>&#8221;.</p></li><li><p>When I run <span><b class="command">configure</b></span>, I get errors
            like <tt class="literal">subs-1.sed line 38: Unterminated `s'
            command</tt>.</p></li><li><p>I'm having trouble building Subversion under Windows
          with MSVC++ 6.0.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ap-c-sect-1.2"></a>Problems Using Subversion</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.1"></a>Every Time I Try to Access My Repository, My
          Subversion Client Just Hangs.</h4></div></div><div></div></div><p>Subversion uses Berkeley DB, which keeps your data in
            a series of database files.  Berkeley DB is journaling
            system, meaning that it logs every action it is about to
            perform before it actually performs the action. If your
            client is interrupted while in the process of talking to
            the database, then a lockfile is left behind in the
            database, along with a logfile describing the unfinished
            actions.</p><p>Any other client that attempts to access the database
            will just hang, waiting for the lockfile to disappear. To
            awaken your repository, you need to tell Berkeley DB to
            either finish the work, or rewind the database to a
            previous state that is known to be consistent.  To do
            this, run the following command from the machine that
            contains your Subversion Repository:</p><pre class="screen">          
$ svnadmin recover /path/to/repos
          </pre><p>Be sure that you disable all access to the repository
            before doing this (by shutting down httpd or
            svnserve). Make sure you run this command as the user that
            owns and manages the database, and not as root, else it
            will leave root-owned files in the
            <tt class="filename">db/</tt> directory which cannot be opened
            by the non-root user that manages the database, which is
            typically either you or your Apache httpd process.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.2"></a>Every Time I Try to Run <span><b class="command">svn</b></span>, It
            Says My Working Copy is Locked.</h4></div></div><div></div></div><p>Subversion's working copy, just like Berkeley DB, uses
            a journaling mechanism to perform all actions. That is, it
            logs everything it is about to do before it does so. If
            <span><b class="command">svn</b></span> is interrupted while performing an
            action, then one or more lockfiles are left behind, along
            with logfiles describing then unfinished
            actions. (<span><b class="command">svn status</b></span> will show an
            <tt class="literal">L</tt> next to locked directories.)</p><p>Any other process that attempts to access the working
            copy will fail when it sees the locks. To awaken your
            working copy, you need to tell the svn client to finish
            the work.  To fix this, run this command from the top of
            your working copy:</p><pre class="screen">
$ svn cleanup working-copy
          </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.3"></a>I'm Getting Errors Finding or Opening a Repository,
            but I Know My Repository URL is Correct.</h4></div></div><div></div></div><p>See <a href="#svn-ap-c-sect-1.2.1" title="Every Time I Try to Access My Repository, My
          Subversion Client Just Hangs.">the section called &#8220;Every Time I Try to Access My Repository, My
          Subversion Client Just Hangs.&#8221;</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.4"></a>How can I specify a Windows drive letter in a
            <tt class="literal">file://</tt> URL?</h4></div></div><div></div></div><p>See <a href="#svn-ch-02-sidebar-1" title="Repository URLs">Repository URLs</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.5"></a>I'm Having Trouble Doing Write Operations to a
            Subversion Repository over a Network</h4></div></div><div></div></div><p>If import works fine over local access:</p><pre class="screen">
$ mkdir test
$ touch test/testfile
$ svn import test file:///var/svn/test -m "Initial import"
Adding         test/testfile
Transmitting file data .
Committed revision 1.
          </pre><p>But not from a remote host:</p><pre class="screen">
$ svn import test http://svn.red-bean.com/test -m "Initial import"
harry's password: xxxxxxx

svn_error: #21110 : 

The specified activity does not exist.
          </pre><p>We've seen this when the
            <tt class="filename">REPOS/dav/</tt> directory is not writable
            by the httpd process. Check the permissions to ensure that
            Apache httpd can write to the <tt class="filename">dav/</tt>
            directory (and to the corresponding
            <tt class="filename">db/</tt> directory, of course).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.6"></a>Under Windows XP, the Subversion Server Sometimes
            Seems to Send Out Corrupted Data.</h4></div></div><div></div></div><p>You need to install Window XP Service Pack 1.  You can
            get all sorts of information about that Service Pack at
            <tt class="systemitem">http://support.microsoft.com/default.aspx?scid=kb;EN-US;q317949</tt>
            for details.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.2.7"></a>What is the Best Method of Doing a Network Trace of
            the Conversation Between a Subversion Client and
            Server?</h4></div></div><div></div></div><p>Use Ethereal to eavesdrop on the conversation:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The following instructions are specific to the
              graphical version of Ethereal, and may not apply to the
              commandline version (whose binary is usually named
              <span><b class="command">tethereal</b></span>).</p></div><div class="itemizedlist"><ul type="disc"><li><p>Pull down the Capture menu, and choose
              Start.</p></li><li><p>Type port 80 for Filter, and turn off promiscuous
                mode.</p></li><li><p>Run your Subversion client.</p></li><li><p>Hit Stop. Now you have a capture. It looks like a
                huge list of lines.</p></li><li><p>Click on the Protocol column to sort.</p></li><li><p>Then, click on the first relevant TCP line to
              select it.</p></li><li><p>Right click, and choose Follow TCP Stream. You'll
                be presented with the request/response pairs of the
                Subversion client's HTTP conversion.</p></li></ul></div><p>Alternatively, you may set the http-debug parameter in
            the server's configuration file to cause neon's debugging
            output to appear when you run the svn client. The numeric
            value of neon-debug is a combination of the
            <tt class="literal">NE_DBG_*</tt> values in the header file
            <tt class="filename">ne_utils.h</tt>. Setting
            <tt class="literal">http-debug</tt> to 130
            (i.e. <tt class="literal">NE_DBG_HTTP + NE_DBG_HTTPBODY</tt>)
            will cause the HTTP data to be shown.</p><p>You may well want to disable compression when doing a
            network trace, see the compression parameter in the config
            configuration file.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ap-c-sect-1.3"></a>Problems Building Subversion</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.3.1"></a>I Just Built the Distribution Binary, and When I Try
            to Check Out Subversion, I Get an Error About an
            &#8220;<span class="quote">Unrecognized URL Scheme</span>&#8221;</h4></div></div><div></div></div><p>Subversion uses a plugin system to allow access to
            repositories. Currently there are three of these plugins:
            <tt class="literal">ra_local</tt> allows access to a local
            repository, <tt class="literal">ra_dav</tt> which allows access
            to a repository via WebDAV, and <tt class="literal">ra_svn</tt>
            allows local or remote access via the svnserve
            server. When you attempt to perform an operation in
            Subversion, the client tries to dynamically load a plugin
            based on the URL scheme. A <tt class="literal">file://</tt> URL
            will try to load <tt class="literal">ra_local</tt>, an
            <tt class="literal">http://</tt> URL will try to load ra_dav,
            and so on.</p><p>The error you are seeing means that the dynamic
            linker/loader can't find the plugins to load. This
            normally happens when you build Subversion with shared
            libraries, then attempt to run it without first running
            <tt class="literal">make install'</tt> Another possible cause is
            that you ran make install, but the libraries were
            installed in a location that the dynamic linker/loader
            doesn't recognize. Under Linux, you can allow the
            linker/loader to find the libraries by adding the library
            directory to <tt class="filename">/etc/ld.so.conf</tt> and
            running <span><b class="command">ldconfig</b></span>. If you don't wish to
            do this, or you don't have root access, you can also
            specify the library directory in the
            <tt class="literal">LD_LIBRARY_PATH</tt> environment
            variable.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.3.2"></a>When I Run <span><b class="command">configure</b></span>, I Get Errors
            Like <tt class="literal">subs-1.sed line 38: Unterminated `s'
            command</tt></h4></div></div><div></div></div><p>You probably have old copies of
            <tt class="filename">/usr/local/bin/apr-config</tt> and
            <tt class="filename">/usr/local/bin/apu-config</tt> on your
            system. Remove them, make sure the
            <tt class="filename">apr/</tt> and
            <tt class="filename">apr-util/</tt> that you're building with
            are completely up-to-date, and try again.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ap-c-sect-1.3.3"></a>I'm Having Trouble Building Subversion Under Windows
          with MSVC++ 6.0.</h4></div></div><div></div></div><p>You need to get the latest platform SDK. The one that
            ships with VCa++ 6.0 is not recent enough.</p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2957943" href="#id2957943">37</a>] </sup>Remember that the amount of detail you provide
        about your setup and your problem is directly proportional to
        the likelihood of getting an answer from the mailing list.
        You're encouraged to include everything short of what you had
        for breakfast and your mother's maiden name.  </p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-d"></a>Appendix D. WebDAV and Autoversioning</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-app-d-sect-1">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect1.1">Just Plain WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect1.2">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-app-d-sect-2">Subversion and DeltaV</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect2.1">Mapping Subversion to DeltaV</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect2.2">Autoversioning Support</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect2.3">The mod_dav_lock Alternative</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-app-d-sect-3">Autoversioning Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-app-d-sect-3.1">Win32 WebFolders</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.2">Mac OS X</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.3">Unix: Nautilus 2</a></span></dt><dt><span class="sect2"><a href="#svn-app-d-sect-3.4">Linux davfs2</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>WebDAV is an extension to HTTP, and is growing more and more
      popular as a standard for file-sharing.  Today's operating
      systems are becoming extremely Web-aware, and many have now
      built-in support for mounting &#8220;<span class="quote">shares</span>&#8221; exported by
      WebDAV servers.</p><p>If you use Apache/mod_dav_svn as your Subversion network
      server, then to some extent, you are also running a WebDAV
      server.  This appendix gives some background on the nature of
      this protocol, how Subversion uses it, and how well Subversion
      interoperates with other software that is WebDAV-aware.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-d-sect-1"></a>Basic WebDAV Concepts</h2></div></div><div></div></div><p>This section provides a very brief, very general overview to
      the ideas behind WebDAV.  It should lay the foundation for
      understanding WebDAV compatibility issues between clients and
      servers.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect1.1"></a>Just Plain WebDAV</h3></div></div><div></div></div><p>RFC 2518 defines a set of concepts and accompanying
        extension methods to HTTP 1.1 that make the web into a more
        universal read/write medium.  The basic idea is that a
        WebDAV-compliant web server can act like a generic file server;
        clients can mount WebDAV &#8220;<span class="quote">shares</span>&#8221; that behave
        much like NFS or SMB shares.</p><p>However, it's important to note that RFC 2518 does
        <span class="emphasis"><em>not</em></span> provide any sort of model for version
        control, despite the &#8220;<span class="quote">V</span>&#8221; in DAV.  Basic WebDAV
        clients and servers assume only one version of each file or
        directory exists, and can be repeatedly overwritten.
        <sup>[<a name="id2960981" href="#ftn.id2960981">38</a>]</sup></p><p>Here are the new concepts and methods introduced in basic
        WebDAV:</p><div class="variablelist"><dl><dt><span class="term">New write methods</span></dt><dd><p>Beyond the standard HTTP <tt class="literal">PUT</tt>
            method (which creates or overwrites a web resource),
            WebDAV defines new <tt class="literal">COPY</tt> and
            <tt class="literal">MOVE</tt> methods for duplicating or
            rearranging resources.</p></dd><dt><span class="term">Collections</span></dt><dd><p>This is simply the WebDAV term for a grouping of
              resources (URIs).  In most cases, it is analogous to a
              &#8220;<span class="quote">directory</span>&#8221;.  You can tell something is a
              collection if it ends with a trailing &#8220;<span class="quote">/</span>&#8221;.
              Whereas file resources can be written or created with a
              <tt class="literal">PUT</tt> method, collection resources are
              created with the new <tt class="literal">MKCOL</tt>
              method.</p></dd><dt><span class="term">Properties</span></dt><dd><p>This is same idea present in
              Subversion&#8212;metadata attached to files and
              collections.  A client can list or retrieve properties
              attached to a resource with the new
              <tt class="literal">PROPFIND</tt> method, and can change them
              with the <tt class="literal">PROPPATCH</tt> method.  Some
              properties are wholly created and controlled by users
              (e.g. a property called &#8220;<span class="quote">color</span>&#8221;), and
              others are wholly created and controlled by the WebDAV
              server (e.g. a property that contains the last
              modification time of a file).  The former kind are
              called &#8220;<span class="quote">dead</span>&#8221; properties, and the latter
              kind are called &#8220;<span class="quote">live</span>&#8221; properties.</p></dd><dt><span class="term">Locking</span></dt><dd><p>A WebDAV server may decide to offer a locking
            feature to clients&#8212;this part of the specification is
            optional, although most WebDAV servers do offer the
            feature.  If present, then clients can use the new
            <tt class="literal">LOCK</tt> and <tt class="literal">UNLOCK</tt>
            methods to mediate access to a resource.  In most cases
            these methods are used to create exclusive write locks (as
            discussed in <a href="#svn-ch-2-sect-2.2" title="The Lock-Modify-Unlock Solution">the section called &#8220;The Lock-Modify-Unlock Solution&#8221;</a>),
            although shared write locks are also possible.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect1.2"></a>DeltaV Extensions</h3></div></div><div></div></div><p>Because RFC 2518 left out versioning concepts, another
        capable group was left with the responsibility of writing RFC
        3253, which adds versioning to WebDAV.  WebDAV/DeltaV clients
        and servers are often called just &#8220;<span class="quote">DeltaV</span>&#8221;
        clients and servers, since DeltaV implies the existence of
        basic WebDAV.</p><p>DeltaV introduces a whole slew of new acronyms, but don't
        be intimidated.  The ideas are fairly straightforward.  Here
        are the new concepts and methods introduced in DeltaV:</p><div class="variablelist"><dl><dt><span class="term">Per-resource versioning</span></dt><dd><p>
              Like CVS and other version-control systems, DeltaV
              assumes that each resource has a potentially infinite
              number of states.  A client begins by placing a resource
              under version control using the new
              <tt class="literal">VERSION-CONTROL</tt> method.  This creates
              a new Version Controlled Resource (VCR).  Every time you
              change the VCR (via <tt class="literal">PUT</tt>,
              <tt class="literal">PROPPATCH</tt>, etc.), a new state of the
              resource is created, called a Version Resource (VR).
              VCRs and VRs are still ordinary web resources, defined
              by URLs.  Specific VRs can have human-friendly names as
              well.
            </p></dd><dt><span class="term">Server-side working-copy model</span></dt><dd><p>Some DeltaV servers support the ability to create a
            virtual &#8220;<span class="quote">workspace</span>&#8221; on the server, where all
            of your work is performed.  Clients use the
            <tt class="literal">MKWORKSPACE</tt> method to create a private
            area, then indicate they want to change specific VCRs by
            &#8220;<span class="quote">checking them out</span>&#8221; into the workspace,
            editing them, and &#8220;<span class="quote">checking them in</span>&#8221; again.
            In HTTP terms, the sequence of methods would be
            <tt class="literal">CHECKOUT</tt>, <tt class="literal">PUT</tt>,
            <tt class="literal">CHECKIN</tt>.  After each
            <tt class="literal">CHECKIN</tt>, a new VR is created, and
            edited VCR's contents now &#8220;<span class="quote">point to</span>&#8221; the
            latest VR.  Each VCR has also has a &#8220;<span class="quote">history</span>&#8221;
            resource which tracks and orders its various VR
            states.</p></dd><dt><span class="term">Client-side working-copy model</span></dt><dd><p>Some DeltaV servers also support the idea that the
            client may have a private working copy full of specific
            VRs.  (This is how CVS and Subversion work.)  When the
            client wants to commit changes to the server, it begins by
            creating a temporary server transaction (called an
            activity) with the <tt class="literal">MKACTIVITY</tt> method.
            The client then performs a <tt class="literal">CHECKOUT</tt> on
            each VR it wishes to change, which creates a number of
            temporary &#8220;<span class="quote">working resources</span>&#8221; in the
            activity, that can be modified using
            <tt class="literal">PUT</tt> and <tt class="literal">PROPPATCH</tt>
            methods.  Finally, the client performs a
            <tt class="literal">CHECKIN</tt> on each working resource, which
            creates a new VR within each VCR, and the entire activity
            is deleted.</p></dd><dt><span class="term">Configurations</span></dt><dd><p>DeltaV allows you define flexible collections of
            VCRs called &#8220;<span class="quote">configurations</span>&#8221;, which don't
            necessarily respond to particular directories.  Each VCR's
            contents can be made to point to a specific VR using the
            <tt class="literal">UPDATE</tt> method.  Once the configuration
            is perfect, the client can create a
            &#8220;<span class="quote">snapshot</span>&#8221; of the whole configuration, called
            a &#8220;<span class="quote">baseline</span>&#8221;.  Clients use the
            <tt class="literal">CHECKOUT</tt> and <tt class="literal">CHECKIN</tt>
            methods to capture specific states of configurations, much
            like they use these methods to create specific VR states
            of VCRs.</p></dd><dt><span class="term">Extensibility</span></dt><dd><p>DeltaV defines a new method,
            <tt class="literal">REPORT</tt>, which allows the client and
            server to perform customized data exchanges.  The client
            sends a <tt class="literal">REPORT</tt> request with a
            properly-labeled XML body full of custom data; assuming
            the server understands the specific report-type, it
            responds with an equally custom XML body.  This technique
            is very similar to XML-RPC.</p></dd><dt><span class="term">Autoversioning</span></dt><dd><p>For many, this is the &#8220;<span class="quote">killer</span>&#8221; feature
            of DeltaV.  If the DeltaV server supports this feature,
            then basic WebDAV clients (i.e. those unaware of
            versioning) can still write to the server, and the server
            will silently perform versioning anyway.  In the simplest
            example, a ignorant <tt class="literal">PUT</tt> from a basic
            WebDAV client might be translated by the server as a
            <tt class="literal">CHECKOUT</tt>, <tt class="literal">PUT</tt>,
            <tt class="literal">CHECKIN</tt>.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-d-sect-2"></a>Subversion and DeltaV</h2></div></div><div></div></div><p>So how &#8220;<span class="quote">compatible</span>&#8221; is Subversion with other
      DeltaV software?  In two words: not very.  At least not yet, not
      in Subversion 1.0.</p><p>While libsvn_ra_dav sends DeltaV requests to the server, the
      Subversion client is <span class="emphasis"><em>not</em></span> a general-purpose
      DeltaV client.  In fact, it expects some custom features from
      the server (especially through custom <tt class="literal">REPORT</tt>
      requests).  Further, mod_dav_svn is <span class="emphasis"><em>not</em></span> a
      general-purpose DeltaV server.  It only implements a strict
      subset of the DeltaV specification.  A more general WebDAV or
      DeltaV client may very well be able to interoperate against it,
      but only if that client operates within the narrow confines of
      those features that the server has implemented.  The Subversion
      development team plans to address general WebDAV
      interoperability in a future release of Subversion.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect2.1"></a>Mapping Subversion to DeltaV</h3></div></div><div></div></div><p>Here is a very &#8220;<span class="quote">high-level</span>&#8221; description of
        how various Subversion client operations use DeltaV.  In many
        cases, these explanations are gross oversimplifications.  They
        should <span class="emphasis"><em>not</em></span> be taken as a substitute for
        reading Subversion's source code or talking with its
        developers.</p><div class="variablelist"><dl><dt><span class="term">svn checkout/list</span></dt><dd><p>
              Perform a <tt class="literal">PROPFIND</tt> of depth 1 on the
              collection to get a list of immediate children.  Perform
              a <tt class="literal">GET</tt> (and possibly a
              <tt class="literal">PROPFIND</tt>) on each child.  Recurse
              into collections and repeat.
            </p></dd><dt><span class="term">svn commit</span></dt><dd><p>
              Create an activity with <tt class="literal">MKACTIVITY</tt>,
              and do a <tt class="literal">CHECKOUT</tt> of each changed
              item, followed by a <tt class="literal">PUT</tt> of new data.
              Finally, a <tt class="literal">MERGE</tt> request causes an
              implicit <tt class="literal">CHECKIN</tt> of all working
              resources.
            </p></dd><dt><span class="term">svn update/switch/status/merge/diff</span></dt><dd><p>
              Send a custom <tt class="literal">REPORT</tt> request that
              describes the mixed-revision (and mixed-url) state of
              the working copy.  The server sends a custom response
              that describes which items need updating.  The client
              loops over the response, performing
              <tt class="literal">GET</tt> and <tt class="literal">PROPFIND</tt>
              requests as needed.  For updates and switches, install
              the new data in the working copy.  For diff and merge
              commands, compare the data to the working copy, possibly
              applying changes as local modifications.
            </p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect2.2"></a>Autoversioning Support</h3></div></div><div></div></div><p>At the time of writing, the truth is that there are very
        few DeltaV clients in the world; RFC 3253 is still relatively
        new.  However users do have access to &#8220;<span class="quote">generic</span>&#8221;
        clients, because almost every modern operating system now has
        a integrated basic WebDAV client.  With this in mind,
        Subversion developers realized that if Subversion 1.0 was to
        have <span class="emphasis"><em>any</em></span> interoperability features,
        support for DeltaV autoversioning would be the best
        approach.</p><p>To activate autoversioning in mod_dav_svn, use the
        <tt class="literal">SVNAutoversioning</tt> directive within the
        <tt class="filename">httpd.conf</tt> <tt class="literal">Location</tt>
        block, like so:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
  SVNAutoversioning on
&lt;/Location&gt;
</pre><p>Normally, if a generic WebDAV client attempted a
        <tt class="literal">PUT</tt> to a path within your repository
        location, mod_dav_svn would outright reject the request.  (It
        normally only allows such operations on &#8220;<span class="quote">working
        resources</span>&#8221; within DeltaV &#8220;<span class="quote">activities</span>&#8221;.)
        With <tt class="literal">SVNAutoversioning</tt> turned on, however,
        the server interprets the <tt class="literal">PUT</tt> request as an
        internal <tt class="literal">MKACTIVITY</tt>,
        <tt class="literal">CHECKOUT</tt>, <tt class="literal">PUT</tt>, and
        <tt class="literal">CHECKIN</tt>.  A generic log message is
        auto-generated, and a new filesystem revision is
        created.</p><p>Because so many operating systems already have integrated
        WebDAV abilities, the use-case for this feature borders on
        fantastical: imagine an office of ordinary users running
        Microsoft Windows or Mac OS.  Each computer
        &#8220;<span class="quote">mounts</span>&#8221; the Subversion repository, which appears
        to be an ordinary network share.  They use the server as they
        always do:  open files from the server, edit them, and
        save them back to the server.  But in this fantasy, the server
        is automatically versioning everything.  Later on, a sysadmin
        can use a Subversion client to search and retrieve all older
        versions.</p><p>Is this fantasy real?  Not quite.  The main snag is that
        Subversion 1.0 has no support whatsoever for the WebDAV
        <tt class="literal">LOCK</tt> or <tt class="literal">UNLOCK</tt> methods.
        Most operating system DAV clients attempt to
        <tt class="literal">LOCK</tt> a resource opened directly from a
        DAV-mounted network share.  For now, users may have to copy a
        file from the DAV share to local disk, edit the file, then
        copy it back again.  Not ideal autoversioning, but still
        doable.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect2.3"></a>The mod_dav_lock Alternative</h3></div></div><div></div></div><p>The mod_dav Apache module is a complex beast:  it
        understands and parses all of the WebDAV and DeltaV methods,
        yet it depends on a back-end &#8220;<span class="quote">provider</span>&#8221; to
        access the resources themselves.</p><p>In its simplest incarnation, a user can use mod_dav_fs as
        a provider for mod_dav.  mod_dav_fs uses the ordinary
        filesystem to store files and directories, and only
        understands vanilla WebDAV methods, not DeltaV.</p><p>Subversion, on the other hand, uses mod_dav_svn as a
        provider for mod_dav.  mod_dav_svn understands all WebDAV
        methods except <tt class="literal">LOCK</tt>, and understands a
        sizable subset of DeltaV methods.  It accesses data in the
        Subversion repository, rather than in the real filesystem.
        Subversion 1.0 doesn't support locking, because it would
        actually quite difficult to implement, since Subversion uses
        the copy-modify-merge model.<sup>[<a name="id2962172" href="#ftn.id2962172">39</a>]</sup></p><p>In Apache httpd-2.0, mod_dav supports the
        <tt class="literal">LOCK</tt> method by tracking locks in a private
        database, assuming that the provider is willing to accept
        them.  In Apache httpd-2.1 or later, however, this locking
        support has been broken into an independent module,
        mod_dav_lock.  It allows any mod_dav provider to take
        advantage of the lock database, including mod_dav_svn, even
        though mod_dav_svn doesn't actually understand locking.</p><p>Confused yet?</p><p>In a nutshell, you can use mod_dav_lock in Apache
        httpd-2.1 (or later) to create the
        <span class="emphasis"><em>illusion</em></span> that mod_dav_svn is honoring
        <tt class="literal">LOCK</tt> requests.  Make sure mod_dav_lock is
        either compiled into httpd, or being loaded in your
        <tt class="filename">httpd.conf</tt>.  Then simply add the
        <tt class="literal">DAVGenericLockDB</tt> directive to your
        <tt class="literal">Location</tt> like so:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
  SVNAutoversioning on
  DavGenericLockDB /path/to/store/locks
&lt;/Location&gt;
</pre><p>This technique is a risky business; in some sense, the
        mod_dav_svn is now lying to the WebDAV client.  It claims to
        accept the <tt class="literal">LOCK</tt> request, but in reality the
        lock isn't being enforced at all levels.  If a second WebDAV
        client attempts to <tt class="literal">LOCK</tt> the same resource,
        then mod_dav_lock will notice and correctly deny the request.
        But there's absolutely nothing preventing an ordinary
        Subversion client from changing the file via a normal
        <span><b class="command">svn commit</b></span>!  If you use this technique,
        you're giving users the opportunity to stomp on each others'
        changes.  In particular, a WebDAV client might accidentally
        overwrite a change committed by regular svn client.</p><p>On the other hand, if you set up your environment very
        carefully, you may mitigate the risk.  For example, if
        <span class="emphasis"><em>all</em></span> of your users are working though
        basic WebDAV clients (rather than svn clients), then things
        should be fine.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-app-d-sect-3"></a>Autoversioning Interoperability</h2></div></div><div></div></div><p>In this section, we'll describe the most common generic
        WebDAV clients (at the time of writing), and how well they
        operate against a mod_dav_svn server using the
        <tt class="literal">SVNAutoversioning</tt> directive.  RFC 2518 is a
        bit large, and perhaps a bit too flexible.  Every WebDAV
        client behaves slightly differently, and creates slightly
        different problems.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect-3.1"></a>Win32 WebFolders</h3></div></div><div></div></div><p>Windows 98, 2000, and XP have an integrated WebDAV client
        known as &#8220;<span class="quote">WebFolders</span>&#8221;.  On Windows 98, the
        feature might need to be explicitly installed;  if present, a
        &#8220;<span class="quote">WebFolders</span>&#8221; directory appears directly within My
        Computer.  On Windows 2000 and XP, simply open My Network
        Places, and run the Add Network Place icon.  When prompted,
        enter the WebDAV URL.  The shared folder will appear within My
        Network Places.</p><p>Most write operations work fine against an autoversioning
        mod_dav_svn server, but there are few problems:</p><div class="itemizedlist"><ul type="disc"><li><p>If the computer is a member of an NT Domain, then it
            seems to be unable to connect to the WebDAV share.  It
            repeatedly asks for a name and password, even when the
            Apache server isn't issuing an authentication challenge!
            Some have speculated that this might happen because
            WebFolders is specifically designed to operate against
            Microsoft's SharePoint DAV server.  If the machine isn't
            part of an NT Domain, then the share is mounted without a
            problem.  This mystery is not yet solved.</p></li><li><p>A file can't be opened for direct editing from the
            share; it always comes up read-only.  The mod_dav_lock
            technique doesn't help, because WebFolders doesn't use the
            <tt class="literal">LOCK</tt> method at all.  The previously
            mentioned &#8220;<span class="quote">copy, edit, re-copy</span>&#8221; method does
            work, however.  The file on the share can be successfully
            overwritten by a locally edited copy.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect-3.2"></a>Mac OS X</h3></div></div><div></div></div><p>Apple's OS X operating system has an integrated WebDAV
        client.  From the Finder, select the &#8220;<span class="quote">Connect to
          Server</span>&#8221; item from the Go menu.  Enter a WebDAV URL,
        and it appears as a disk on the desktop, just like any file
        server.<sup>[<a name="id2962477" href="#ftn.id2962477">40</a>]</sup></p><p>Unfortunately, this client refuses to work against an
        autoversioning mod_dav_svn because of its lack of
        <tt class="literal">LOCK</tt> support.  Mac OS X discovers the
        missing <tt class="literal">LOCK</tt> ability during the initial
        HTTP <tt class="literal">OPTIONS</tt> feature exchange, and thus
        decides to mount the Subversion repository as a read-only
        share.  After that, no write operations are possible at all.
        In order to mount the repository as a read-write share, you
        <span class="emphasis"><em>must</em></span> use the mod_dav_lock trick discussed
        previously.  Once locking seems to work, the share behaves
        very nicely: files can be opened directly in read/write mode,
        although each save operation will cause the client to do a
        <tt class="literal">PUT</tt> to a temporary location, a
        <tt class="literal">DELETE</tt> of original file, and a
        <tt class="literal">MOVE</tt> of the temporary resource to the
        original filename.  That's three new Subversion revisions per
        save!</p><p>One more word of warning: OS X's WebDAV client can be
        overly sensitive to HTTP redirects.  If you're unable to mount
        the repository at all, you may need to enable the
        <tt class="literal">BrowserMatch</tt> directive in your
        <tt class="filename">httpd.conf</tt>:</p><pre class="screen">
BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect-3.3"></a>Unix: Nautilus 2</h3></div></div><div></div></div><p>Nautilus is the official file manager/browser for the
        GNOME desktop.  Its main home page is at <tt class="systemitem">http://www.gnome.org/projects/nautilus/</tt>.
        By simply typing a WebDAV URL into the Nautilus window,
        the DAV share appears like a local filesystem.</p><p>In general, Nautilus 2 works reasonably well against an
        autoversioning mod_dav_svn, with the following caveats:</p><div class="itemizedlist"><ul type="disc"><li><p>Any files opened directly from the share are treated
            as read-only.  Even the mod_dav_lock trick seems to have
            no effect.  It seems that Nautilus never issues the
            <tt class="literal">LOCK</tt> method at all.  The &#8220;<span class="quote">copy
            locally, edit, copy back</span>&#8221; trick does work, however.
            Unfortunately, Nautilus overwrites the old file by issuing
            a <tt class="literal">DELETE</tt> first, which creates an extra
            revision.</p></li><li><p>When overwriting or creating a file , Nautilus first
            does a <tt class="literal">PUT</tt> of an empty file, then
            overwrites it with a second <tt class="literal">PUT</tt>.  This
            creates two Subversion filesystem revisions, rather than
            one.</p></li><li><p>When deleting a collection, it issues an HTTP
          <tt class="literal">DELETE</tt> on each individual child instead
          of on the collection itself.  This creates a whole bunch of
          new revisions.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-app-d-sect-3.4"></a>Linux davfs2</h3></div></div><div></div></div><p>Linux davfs2 is a filesystem module for the Linux kernel,
        whose development is located at <tt class="systemitem">http://dav.sourceforge.net/</tt>.  Once
        installed, a WebDAV network share can be mounted with the
        usual Linux <span><b class="command">mount</b></span> command.</p><p>The word on the street is that this DAV client doesn't
        work at all with mod_dav_svn's autoversioning.  Every single
        attempt to write to the server is preceded by a
        <tt class="literal">LOCK</tt> request, which mod_dav_svn doesn't
        support.  At this time, there is no data indicating whether
        the use of mod_dav_lock resolves this problem.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2960981" href="#id2960981">38</a>] </sup>For this reason, some people jokingly refer to
        generic WebDAV clients as &#8220;<span class="quote">WebDA</span>&#8221;
        clients!</p></div><div class="footnote"><p><sup>[<a name="ftn.id2962172" href="#id2962172">39</a>] </sup>Subversion may
        someday develop a reserved-checkout locking model that can
        live peaceably with copy-modify-merge, but it probably won't
        happen soon.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2962477" href="#id2962477">40</a>] </sup>Unix users can also run <span><b class="command">mount
        -t webdav URL /mountpoint</b></span>.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-e"></a>Appendix E. Other Subversion Clients</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ap-e-sect-1">Out of One, Many</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-e-sect-1"></a>Out of One, Many</h2></div></div><div></div></div><p>The Subversion command line client,
        <span><b class="command">svn</b></span>, is the official<sup>[<a name="id2963349" href="#ftn.id2963349">41</a>]</sup> implementation of a
        Subversion client.  Fortunately for those interested in
        developing additional Subversion clients, Subversion is
        implemented as a series of libraries.  These libraries are
        accessible via C API, as well as other languages (see <a href="#svn-ch-7-sect-2.3" title="Using Languages Other than C and C++">the section called &#8220;Using Languages Other than C and C++&#8221;</a>).</p><p>This component design means that it's easy (well, at least
        <span class="emphasis"><em>easier</em></span>) to write clients and utilities
        using these libraries.  As a result, even pre-1.0, there are a
        number of GUI clients available for Subversion, each in
        various phases of development.</p><div class="table"><a name="svn-ap-e-table-1"></a><p class="title"><b>Table E.1. GUI Clients for Subversion</b></p><table summary="GUI Clients for Subversion" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>name</th><th>Language</th><th>Portable</th><th>License</th><th>URL</th></tr></thead><tbody><tr><td>RapidSVN</td><td>C++</td><td>Yes, native widgets</td><td>Apache-style</td><td><tt class="systemitem">http://rapidsvn.tigris.org/</tt></td></tr><tr><td>gsvn</td><td>Python</td><td>Unix only, non-native widgets</td><td>GPL</td><td><tt class="systemitem">http://gsvn.tigris.org/</tt></td></tr><tr><td>TortoiseSVN</td><td>C++</td><td>Win32 only</td><td>GPL</td><td><tt class="systemitem">http://tortoisesvn.tigris.org/</tt></td></tr><tr><td>svnup</td><td>Java, JNI bindings</td><td>Yes</td><td>Apache-style</td><td><tt class="systemitem">http://svnup.tigris.org/</tt></td></tr><tr><td>jsvn</td><td>Java, wrapping the svn command-line client</td><td>Yes</td><td>Academic Free License</td><td><tt class="systemitem">http://jsvn.alternatecomputing.com</tt></td></tr></tbody></table></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2963349" href="#id2963349">41</a>] </sup>Because
        we says so, that's why.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ap-f"></a>Appendix F. Third Party Tools</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ap-f-sect-1">ViewCVS</a></span></dt><dt><span class="sect1"><a href="#svn-ap-f-sect-2">SubWiki</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Subversion's modular design (covered in <a href="#svn-ch-7-sect-1" title="Layered Library Design">the section called &#8220;Layered Library Design&#8221;</a>) and the availability of language
      bindings (as described in <a href="#svn-ch-7-sect-2.3" title="Using Languages Other than C and C++">the section called &#8220;Using Languages Other than C and C++&#8221;</a>)
      make Subversion a likely candidate for use as an extension or
      backend to other pieces of software.  In this appendix, we'll
      introduce you to some of the third-party tools which are using
      Subversion.  We will not cover actual Subversion
      clients&#8212;see <a href="#svn-ap-e" title="Appendix E. Other Subversion Clients">Appendix E, <i>Other Subversion Clients</i></a> for those.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-f-sect-1"></a>ViewCVS</h2></div></div><div></div></div><p>Perhaps the first&#8212;and definitely the most
      popular&#8212;utility to take advantage of Subversion's public
      API is ViewCVS.  ViewCVS is essentially a CGI script which
      enables browsing of the files and directories of a version
      control system.  Originally designed as a Python-based
      replacement for the popular cvsweb utility,
      <sup>[<a name="id2963624" href="#ftn.id2963624">42</a>]</sup>
      ViewCVS provides a full-featured Web-based interface to CVS
      repositories, allowing folks to see the version control history
      of the files in those repositories and to perform such nifty
      tasks as generating differences between arbitrary versions of
      those files.</p><p>In the early part of 2002, the repository accessing portion
      of ViewCVS was modularized into a semi-generic interface, and a
      pair of modules were grown to provide that functionality for CVS
      repositories.  Later that year, Subversion's Python language
      bindings sufficiently matured, and a Subversion repository
      module was written for the ViewCVS interface.  Now, ViewCVS is
      able to browse Subversion repositories, providing essentially
      the same history and differencing mechanisms for those
      repositories as are available for CVS ones.</p><p>For more information on ViewCVS, see the project's website at
      <tt class="systemitem">http://viewcvs.sf.net/</tt>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ap-f-sect-2"></a>SubWiki</h2></div></div><div></div></div><p>SubWiki is a Subversion-backed Wiki program.  Wikis have
      sprung up on the World Wide Web as unique publishing and
      community tools&#8212;essentially, web-based interfaces for
      editing web pages.  SubWiki takes the Wiki concept one step
      further by using a version control system for its backend
      storage mechanism.  The result is a CGI program which allows web
      pages to be essentially edited in-place, yet never loses old
      versions of those web pages.</p><p>To learn more about SubWiki, visit that project's website at
      <tt class="systemitem">http://subwiki.tigris.org/</tt>.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2963624" href="#id2963624">42</a>] </sup>CVSWeb was written in Perl.</p></div></div></div><div class="glossary"><div class="titlepage"><div><div><h2 class="title"><a name="svn-glossary"></a>Glossary</h2></div></div><div></div></div><dl></dl></div><div class="colophon" lang="en"><h2 class="title"><a name="svn-colophon"></a>Colophon</h2><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Etc.</p></div></div></div></body></html>
